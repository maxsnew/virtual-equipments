\documentclass{llncs}

\usepackage{tikz-cd} \usepackage{amssymb} \usepackage{amsmath}
%% \usepackage{amsthm}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{mathpartir}
\usepackage{bbm}
\usepackage{cleveref}

\DeclareMathOperator*{\colim}{colim}

\begin{document}
%% \newtheorem{theorem}{Theorem}
%% \newtheorem{lemma}{Lemma}
\newtheorem{construction}{Construction}
%% \newtheorem{definition}{Definition}
\newcommand{\vett}{VETT}
\newcommand{\ohol}{\vett}
\newcommand{\sem}[1]{\llbracket{#1}\rrbracket}
\newcommand{\pto}{\nrightarrow}
\newcommand{\pfrom}{\nleftarrow}
\newcommand{\vcat}{\mathcal}
\newcommand{\cat}{\mathbbm}
\newcommand{\isaSet}{\,\,\textrm{Set}}
\newcommand{\isaTy}{\,\,\textrm{Type}}
\newcommand{\isaCat}{\,\,\textrm{Cat}}
\newcommand{\isSmall}{\,\,\textrm{Small}}
\newcommand{\Set}{\textrm{Set}}
\newcommand{\MonCat}{\textrm{MonCat}}
\newcommand{\SymMonCat}{\textrm{SymMonCat}}
\newcommand{\vtkmnd}{\mathbb{K}\text{Mod} (\vcat{V},T)}
\newcommand{\rmod}{\text{RMod}}
\newcommand{\lmod}{\text{LMod}}

\newcommand{\smallCats}{\text{SmallCat}}
\newcommand{\Cats}{\text{Cat}}
\newcommand{\varr}[2]{\text{Fun}\,{#1}\,{#2}}
\newcommand{\harr}[2]{\text{Prof}\,{#1}\,{#2}}
\newcommand{\harrapp}[3]{#1(#2;#3)}

\newcommand{\defaultObCtx}{\Gamma\pipe\alpha:\cat C}

\newcommand{\jnctx}{\curlyveedownarrow}

\newcommand{\id}{\textrm{id}}
\newcommand{\for}{\textrm{for}\,}
\newcommand{\when}{\textrm{when}\,}
\newcommand{\lett}{\textrm{let}\,}
%% \newcommand{\sort}{\,\,\textrm{sort}}
\newcommand{\Sort}{\textrm{Sort}}
\newcommand{\isadtctx}{\,\,\textrm{type context}}
\newcommand{\isavectx}{\,\,\textrm{trans. context}}
%% \newcommand{\obctx}{\,\,\textrm{object context}}
\newcommand{\boundary}{\,\,\textrm{set context}}
\newcommand{\prof}{\,\,\textrm{span}}
\newcommand{\subst}{\,\,\textrm{subst}}
\newcommand{\sigctx}{\,\,\textrm{sig-ctx}}
\newcommand{\sig}{\,\,\textrm{sig}}
\newcommand{\pipe}{\mathrel{|}}

\newcommand{\punitinXfromYtoZ}[3]{#2 \mathop{\to_{#1}} #3}
\newcommand{\punitrefl}[1]{\textrm{id}_{#1}}
\newcommand{\punitelimtoYwithkontZ}[2]{\textrm{ind}_{\to}(#1,#2)}
\newcommand{\punitelimkontZatABC}[4]{\textrm{ind}_{\to}(#1,#2, #3, #4)}

\newcommand{\odotexists}[1]{\mathop{\overset{\exists #1}\odot}}
\newcommand{\tensorexistsXwithYandZ}[3]{#2 \odotexists{#1} #3}
\newcommand{\tensorintroofXandY}[2]{\textrm{pair}_\odot(#1,#2)}
\newcommand{\tensorintroatXwithYandZ}[3]{(#2,#1,#3)}
\newcommand{\tensorelimXtoYwithkontZ}[3]{\textrm{ind}_{\to}(#1,#2,#3)}
\newcommand{\tensorelimfromWXtoYwithkontZ}[4]{\textrm{ind}_{\odot}(#1,#2,#3,#4)}
\newcommand{\tensorelimVatWtoXtoYwithkontZ}[5]{\textrm{ind}_{\odot}(#4,#2,#1,#3,#5)}
\newcommand{\tensorelimWfromXtoYkontZ}[4]{\textrm{ind}_{\odot}(#4;#1,#2,#3)}
\newcommand{\tensorelimWkontZ}[2]{\textrm{ind}_{\odot}(#2;#1)}

\newcommand{\tlwith}[1]{\mathop{\prescript{#1}{}\triangleleft}}
\newcommand{\tlforall}[1]{\tlwith{\forall #1}}

\newcommand{\trwith}[1]{\mathop{\triangleright^{#1}}}
\newcommand{\trforall}[1]{\trwith {\forall #1}}

\newcommand{\homrallXYtoZ}[3]{#2 \trforall {#1} #3}

\newcommand{\homlallXYtoZ}[3]{#3 \tlforall {#1} #2}

\newcommand{\homrlambdaXatYdotZ}[3]{\lambda^\triangleright (#1, #2). #3}
\newcommand{\homllambdaXatYdotZ}[3]{\lambda^\triangleleft (#2, #1). #3}

\newcommand{\homrappXtoYatZ}[3]{#1 \trwith{#3} #2}
\newcommand{\homlappXtoYatZ}[3]{#2 \tlwith{#3} #1}

\newcommand{\homunary}[4]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} {#4}}}
\newcommand{\hombinary}[6]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} \homrallXYtoZ {#5} {#4} {#6}}}
\newcommand{\homtrinary}[8]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} \homrallXYtoZ {#5} {#4} \homrallXYtoZ {#7} {#6} {#8}}}

\newcommand{\homlunary}[4]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} {#4}}}
\newcommand{\homlbinary}[6]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} \homrallXYtoZ {#5} {#4} {#6}}}
\newcommand{\homltrinary}[8]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} \homrallXYtoZ {#5} {#4} \homrallXYtoZ {#7} {#6} {#8}}}

\newcommand{\lambdaunary}[4]{\pendlambdaXdotY {#1} {\homrlambdaXatYdotZ {#2} {#3} {#4}}}
\newcommand{\lambdabinary}[6]{\lambdaunary{#1}{#2}{#3}{\homrlambdaXatYdotZ{#4}{#5}{#6}}}
\newcommand{\lambdatrinary}[8]{\lambdabinary{#1}{#2}{#3}{#4}{#5}{\homrlambdaXatYdotZ{#6}{#7}{#8}}}

\newcommand{\appunary}[4]{\homrappXtoYatZ {\pendappXtoY {#1} {#2}} {#3} {#4}}
\newcommand{\appbinary}[6]{\homrappXtoYatZ {\appunary{#1}{#2}{#3}{#4}}{#5}{#6}}
\newcommand{\apptrinary}[8]{\homrappXtoYatZ {\appbinary{#1}{#2}{#3}{#4}{#5}{#6}}{#7}{#8}}

\newcommand{\pendallXdotY}[2]{\forall #1. #2}
\newcommand{\pendlambdaXdotY}[2]{\lambda #1. #2}
\newcommand{\pendappXtoY}[2]{#1^{#2}}

\newcommand{\Cat}{\textrm{Cat}}
\newcommand{\Id}[3]{\textrm{Id} #1\,#2\,#3}
\newcommand{\vlambda}[1]{\lambda^{F}{#1}.}
\newcommand{\hlambda}[2]{\lambda^{P}{#1};{#2}.}
\newcommand{\ran}[1]{\textrm{Ran}_{#1}\,}
\newcommand{\weightedLimitDW}[2]{\textrm{lim}^{#2}{#1}\,}

\newcommand{\equalizeVofWbyXeqYatZ}[5]{\{ {#1} : {#2} \pipe {#3} = {#4} : {#5} \}}

\newcommand{\paramPresheaf}[1]{\mathcal P^{#1}}
\newcommand{\pmPresheaf}{\paramPresheaf\pm}
\newcommand{\posPresheaf}{\paramPresheaf+}
\newcommand{\negPresheaf}{\paramPresheaf-}
\newcommand{\negPresheafAppPtoX}[2]{#2\in #1}
\newcommand{\posPresheafAppPtoX}[2]{#1 \ni #2}
\newcommand{\negPresheafApp}{\negPresheafAppPtoX}
\newcommand{\posPresheafApp}{\posPresheafAppPtoX}

\newcommand{\graphProf}[3]{\sum_{{#1};{#2}} #3}

% Algebraic notation
\newcommand{\algCtx}{\textrm{Ctx}}
\newcommand{\algSubst}{\textrm{Subst}}
\newcommand{\algTy}{\textrm{Type}}
\newcommand{\algTm}{\textrm{Term}}
\newcommand{\algCat}{\textrm{Cat}}
\newcommand{\algVarr}{\textrm{Functor}}
\newcommand{\algHCtx}{\textrm{ProfCtx}}
\newcommand{\algHSubst}{\textrm{ProfSubst}}
\newcommand{\algHarr}{\textrm{Prof}}
\newcommand{\algTrans}{\textrm{Trans}}
\newcommand{\algElts}{\textrm{Elts}}
\newcommand{\algEltsI}{\textrm{EltsI}}

\newcommand{\algLHom}{\textrm{LHom}}
\newcommand{\algLHomI}{\textrm{LHomI}}
\newcommand{\algLHomE}{\textrm{LHomE}}
\newcommand{\algRHom}{\textrm{RHom}}
\newcommand{\algRHomI}{\textrm{RHomI}}
\newcommand{\algRHomE}{\textrm{RHomE}}

\newcommand{\algUnit}{\textrm{Unit}}
\newcommand{\algUnitI}{\textrm{UnitI}}
\newcommand{\algUnitE}{\textrm{UnitE}}

\newcommand{\algTensor}{\textrm{Tensor}}
\newcommand{\algTensorI}{\textrm{TensorI}}
\newcommand{\algTensorE}{\textrm{TensorE}}

\newcommand{\algCatTy}{\textrm{Cat}}
\newcommand{\algCatQt}{\textrm{CatQt}}
\newcommand{\algCatUnqt}{\textrm{CatUnQt}}

\newcommand{\algTransTy}{\textrm{Trans}}
\newcommand{\algTransQt}{\textrm{TransQt}}
\newcommand{\algTransUnqt}{\textrm{TransUnQt}}

\newcommand{\algVarrQt}{\textrm{FunctQt}}
\newcommand{\algVarrUnqt}{\textrm{FunctUnQt}}

\newcommand{\quoth}[1]{\lceil{} {#1}\rceil{}}
\newcommand{\unquoth}[1]{\lfloor{} {#1}\rfloor{}}

\newcommand{\citet}[1]{\cite{#1}}
\newcommand{\citep}[1]{(\cite{#1})}

\title{A Constructive Ordered Predicate Logic for Category Theory}
\author{Max S. New\inst{1,2} and Daniel R. Licata\inst{2}}
\institute{University of Michigan \and Wesleyan University}

\maketitle

\begin{abstract}
  We present a domain-specific type theory for constructions and proofs
  in category theory. The type theory axiomatizes notions of category,
  functor, profunctor and a generalized form of natural
  transformations. The type theory imposes an ordered linear restriction
  on standard predicate logic, which guarantees that all functions
  between categories are functorial, all relations are profunctorial,
  and all transformations are natural by construction, with no separate
  proofs necessary. Important category theoretic proofs such as the
  Yoneda lemma and Co-yoneda lemma become simple type theoretic proofs
  about the relationship between unit, tensor and (ordered) function
  types, and can be seen to be ordered refinements of theorems in
  predicate logic.  The type theory is sound and complete for a
  categorical model in \emph{virtual equipments}, which model both
  internal and enriched category theory. While the proofs in our type
  theory look like standard set-based arguments, the syntactic
  discipline ensure that all proofs and constructions carry over to
  enriched and internal settings as well.
\end{abstract}

\section{Introduction}

Category theory is a branch of mathematics that studies
higher-dimensional typed algebraic structures.
%
Originally developed for applications to homological algebra, it was
quickly discovered that categorical structures were common in logic and
computer science.  Formal systems like logics, type theories and
programming languages typically have sound and complete models given by
notions of structured categories,\cite{lawvere,goguen,lambek,moggi}.
%
This Curry-Howard-Lambek correspondence~\cite{curry-howard-lambek}
applies to simply typed lambda calculus~\cite{lambekscott},
computational lambda calculus~\cite{moggi}, linear logic~\cite{girard}
dependent type theory\cite{cartmell1986}, and many other type theories
designed based on category-theoretic semantics.
%
The syntax of a type theory should present an initial object in its
category of models, a category-theoretic reformulation of logical
soundness and completeness.

% TODO: do we have citations for this?
While this research program has been quite successful,
category-theoretic techniques in computer science are sometimes
criticized for being overly complex and hard to learn, especially for
computer scientists who do not have a strong background in pure
mathemantics.
%
While in some ways this could be remedied by better introductory
materials, in some ways category theory is objectively complex.
%
In a traditional set-theoretic formulation, notions such as adjoint
functors and limits produce a proliferation of ``naturality'' and
``functoriality'' side-conditions that must be discharged.
%
For example, when constructing an adjoint pair of
functors between two categories, a na\"ive approach would define all of
the data of the action on objects, action on arrows, prove the
functoriality of such actions, as well as construct two families of
transformations, prove they are natural and then finally proving a pair
of equalities relating compositions of natural transformations.
%
Carrying out these proofs explicitly is quite tedious and many newcomers
to are left with the impression that category theory is full of long,
but ultimately trivial constructions.
%
This complexity is compounded when we move from ordinary category theory to
enriched and internal category theory, where constructions must be
additionally proven continuous, monotone, etc, in addition to natural
or functorial.
%
Moreover, these generalizations are often what is needed for programming
language applications; for example, domain- and metric- and
step-index-enriched categories have been used to model recursive
programming languages and internal categories have been used to model
parametricity and gradual
typing\cite{order-enriched-cats,topos-of-trees,reflexive-graphs,double-cats-gradual-typing}.

Fortunately, the tools of category theory itself can be employed to
simplify this complexity, specifically the tools of \emph{higher}
category theory.
%
As an analogy in differential calculus, when an adept analyst writes
down a function, they do not expand out the $\epsilon\mathord{-}\delta$
definition of continuity for a function and proceed from first
principles, but rather use certain \emph{syntactic principles} for
defining functions that are continuous by construction --- e.g. that
composition of continuous functions is continuous and that previously
defined functions are known to be continuous.
%
Similar principles apply to category theory itself: functors and
natural transformations are closed under composition and whiskering
operations, and experienced category theorists rely on these syntactic
principles to eliminate the tedium of explicit proofs.
%
In the case of category theory, these principles can be formalized
using algebraic structures such as 2-categories, bicategories,
(virtual) double categories and pro-arrow equipments\cite{TODO}, an
approach known as \emph{formal category theory}.
%
In these structures, rather than defining notions of category, functor
and natural transformation from first principles, they are axiomatized
in a manner similar to how a category axiomatizes a notion of space
and homomorphism.
%
The formal approaches also apply to enriched and internal settings, so
\emph{formal} category theory proofs apply to these settings.
%
A downside is that these algebraic structures are quite complicated, and
practitioners typically employ either an algebraic combinator syntax or
a 2-dimensional diagrammatic language that can be quite beautiful and
elegant, but is also somewhat removed from the traditional formulation
of category theory in terms of sets and functions.

In this work, we apply the techniques of categorical logic to define a
more familiar logical syntax for carrying out constructions and proofs
in formal category theory.  
%
We call the resulting theory \emph{virtual equipment type theory} (VETT)
as (hyperdoctrines of) \emph{virtual
  equipments}~\cite{virtualequipments}, a particular semantic model of
formal category theory, provide a sound and complete notion of model for
the theory.
%
VETT provides syntax for categories, functors, profunctors, and natural
transformations, which are defined using familiar term syntax and
$\beta\eta$ reasoning principles for $\lambda$-functions, bound
variables, tuples, etc.  
%
By adhering to a \emph{syntactic discipline}, the logic guarantees
that all functor terms are automatically functorial, all and natural
transformation terms are natural.
%
More specifically, the syntax for transformations is a kind of
\emph{indexed, ordered linear} $lambda$ calculus, where the indexing
ensures that transformations are correctly natural and the ordering and
linearity ensure that the proofs are valid in a large class of enriched
and internal categories, such as enrichment in a non-symmetric monoidal
category.
%
VETT provides an alternative alternative to algebraic and
string-diagram syntaxes for working with virtual equipments,
similar to how the lambda calculus provides an alternative to
categorical combinators and string diagram calculi for cartesian
closed categories.


%% The type theoretic syntax allows us to write all of our 
%% constructions are written as if they were
%% ordinary functors and profunctors in set-based category theory.


%%
%% DRL: I know what you mean, but I think conflating set theory and
%% type theory will put some people off... 
%% 
%% This is analogous to the situation in intuitionistic type theory,
%% where the syntax is similar to that of informal set theory, but by
%% restricting to intuitionistic reasoning, the constructions can all be
%% interpreted in models where types are spaces and terms are continuous
%% functions ``for free''.
%

The syntax of \vett{} is an indexed, ordered linear, proof-relevant
variant of predicate logic over a unary type theory.
%
Just as a predicate logic has a notion of type, term, relation and
implication, \vett{} is based on four analogous category theoretic
concepts: categories, functors, profunctors and natural transformations
of profunctors.
%
Categories are treated like types, and the unary functors we consider in
this paper are each represented by a term whose type is a category and
whose one free variable ranges over a category.
%
The analogue of a relation is a \emph{profunctor} (defined below), which
are written as a kind of set with free category variables.  Like the
restriction to unary functors, we restrict to profunctors with two free
variables.
%
The logic is proof-relevant in that the implications of relations are
generalized to natural transformations of profunctors, and we use a
$\lambda$-calculus notation to describe these ``proof terms''.
%
We can strenghten this analogy into a formal construction: any
construction in \vett{} can be erased to a corresponding construction
or proof in predicate logic, as sets, functions and relations define a 
(somewhat degenerate) virtual equipment.
%% %
%% Our syntax highlights this analogy in that some of our constructions
%% are generalizations of set comprehension or power-sets and we use
%% similar notation.

While the restricted syntax developed in this paper does not express
important concepts such as functor categories or opposite categories,
the restriction is natural in that it corresponds exactly to a
well-understood notion of model, virtual equipments, which can express a
great deal of fundamental results and constructions in category
theory~\cite{elements-of-oo-category-theory,
  enriched-indexed-categories}.
%
Moveover, we can work around these unary/binary restrictions to some
extent by viewing the type theory as a domain-specific language embedded
in a metalanguage.  For example, while we cannot talk about functor
categories, we can state a theorem that quantifies over functors using
the meta-language's ``external'' universal quantifier (which does not
have automatic functoriality/naturality properties).  To support this,
\vett includes a third layer, an extensional dependent type theory in
the style of Martin-L\"of type theory. All of our ordered predicate
logic judgments are also be indexed by a context from this dependent
type theory, and the type theory includes universe types for categories,
functors, profunctors and natural transformations.  This allow us to
formalize theorems the logic is too restrictive to encode, analogous to
2-level~\cite{voevodsky13hts,altenkirch+16strict} or indexed type
theories~\cite{isaev21indexed,cervesatopfenning02llf,vakar15linear,krishnaswami+15linear}.

%% This is analogous to the notion of a
%% \emph{2-level type theory}: we add a
%% dependent type theory for reasoning about the terms of our virtual
%% equipment type theory.  The dependent type theory layer also has an
%% additional purpose: since we can quantify over the structures in
%% \vett{}, we can additionally encode \emph{signatures} for \vett{} as
%% simply contexts of the dependent type theory. This allows for a clean
%% formalization of many categorical structures such as monoidal
%% categories, or strong monads.

While we emphasize the applications to enriched and internal category
theory in this work, there is potential for more direct application to
programming language semantics.
%
Ordinary predicate logic is the foundation for logical presentations of
logical relations, such as Abadi-Plotkin logic for parametricity and
LSLR and Iris for step-indexed logical relations proofs
\cite{abadi-plotkin,lslr,iris}.
%
We conjecture that \vett{} might similarly serve as the foundation for
a logic of \emph{ordered} structures, which abound in applications:
rewriting and approximation relations can both be modeled as orderings
and logical relations involving these structures are proven to respect
orderings: operational logical relations must be downward-closed and
approximation relations should satisfy transitivity.
%
Just as LSLR and Iris release the user from the syntactic burden of
explicit step-indexing, \vett{} may be used to release the user from
the syntactic burden of proving downward-closure or transitivity
side-conditions.
%
Additionally, \vett{} may serve as the basis of a future domain specific
proof assistant for category theoretic proofs.  To pilot-test this, we
have formalized the syntax of \vett{} in Agda 2.6.2.2, using the rewrite
mechanism to make \vett's substitution and $\beta$-reduction rules
definitional
equalities.\footnote{\url{https://github.com/maxsnew/virtual-equipments/blob/master/agda/STC.agda}}
We have used this lightweight implementation to check a number of
examples.  

\paragraph{Basics of Profunctors.}
While we assume the reader has some background knowledge of category
theory, we briefly define profunctors, which are not included in many
introductory texts.  Recall that a category $\cat C$ has a collection of
objects and morphisms with identity and composition, and a functor $F :
\cat C \to \cat D$ is a function on objects and a function on morphisms
that preserves identity and composition.  A category can be thought of
as a generalization of a preordered set, which has a set of elements and
a binary \emph{relation} on its objects satisfying reflexivity and
transitivity.  A category is then a \emph{proof-relevant preorder},
where morphisms are the proofs of ordering, and the reflexivity and
transitivity proofs must identity and unit equations. A functor is then
a \emph{proof-relevant monotone function}.  Given categories $\mathcal
C$ and $\mathcal D$, a profunctor $R$ from $\mathcal C$ to $\mathcal D$,
written $R : \cat C \pto \cat D$ is a functor $R : {\cat C}^{op} \times
{\cat D} \to \Set$.  Because a profunctor outputs a $\Set$ rather than a
proposition, it is itself a \emph{proof-relevant relation}.  Thinking of
categories as proof-relevant preorders, functoriality says that the
profunctor is downward-closed in $\cat C$ and upward-closed in $\cat D$.
Given profunctors $R, S : \cat C \pto \cat D$, a homomorphism from
$R$ to $S$ is simply a natural transformation, which in the preordered
setting is simply an implication of relations.

%% We can think of each set $R(c,d)$ as a set of
%% ``heteromorphisms'' from $c$ (an object of $\cat C$) to $d$ (an object
%% of $\cat D$).  These ``heteromorphisms'' differ from the usual
%% ``homomorphisms'' in a single category $\cat C$ because they relate two
%% objects from two different categories.  Functoriality then defines a
%% notion of composition of heteromorphisms with homomorphisms in $\cat C$
%% and $\cat D$.

Profunctors are very useful for formalizing category theory, but an
additional reason we make them a basic concept of \vett{} is that they
allow us to give a \emph{universal property} for the type of ``morphisms
in a category ${\cat C}$''.  This is analogous to how the $J$
elimination rule for the identity type in Martin-L\"of type theory gives
a universal property for morphisms in a groupoid (the special case of a
category where all morphisms are
invertible)~\cite{hofmann98groupoid,awodeywarren09identity,voevodsky11wollic}. The reason
profunctors are useful for this purpose is that, for any category $\cat
C$, $\text{Hom}_{\cat C} : \cat C \pto \cat C$ is a profunctor. On
preorders this is just the preorder's ordering relation
itself. Moreover, the hom profunctor is the unit for a composition of
profunctors $R \odot S$ which is defined as a \emph{co-end}.
%% The
%% heteromorphisms of $(R \odot S)(c,e)$ are triples $(d \in \cat D, f \in
%% R(c,d), g \in S(d,e))$ modulo the equivalence relation generated by
%% $(d,f,g) ~ (d', f', g')$ if there exists $h \in D(d,d')$ such that
%% $h\circ f = f'$ and $g'\circ h = g$.
The composition of profunctors is a generalization of the composition of
relations, and just as the equality relation is the identity for the
composition of relations, the hom profunctor is the identity for this
composition.  The unit law for the hom profunctor can be seen as a
``morphism induction'' principle, analogous to the ``path induction''
used in homotopy type theory (though in this paper we consider only
ordinary 1-dimensional categories, not higher generalizations).

%% orphaned --- move later? 
%% For any profunctor $R : \cat C \pto \cat D$ and functors $F : \cat C'
%% \to \cat C$ and $G : \cat D' \to \cat D$, by composition we can define a
%% profunctor $R(F,G)$, the ``restriction'' of $R$ along $F$ and $G$.
The remainder of this paper is organized as follows.  
In Section~\ref{sec:syntax} we introduce the syntax of \vett{}.  In
Section~\ref{sec:examples} we demonstrate how to use our syntax for formal
category theory.  In Section~\ref{sec:semantics}, we develop some model theory
for \vett{}, including a sound and complete notion of categorical model
and sound interpretation in virtual equipments modeling ordinary,
enriched and internal category theory.  In Section~\ref{sec:discussion}, we
discuss related type theories and potential extensions.

\section{Syntax of VETT}
\label{sec:syntax}

In Figure~\ref{fig:hol-cats} we give a table summarizing the
relationship between the judgments and connectives of higher-order
predicate logic with our ordered variant. Due to the incorporation of
variance, some unorderd concepts generalize to multiple different
ordered notions. For instance, covariant and contravariant presheaf
categories generalize the power set. Further, because we only have
binary relations rather than relations of arbitrary arity, we have
only restricted forms of universal and existential quantification
which come combined with implications and conjunctions.

\begin{figure}
  \begin{center}
    \begin{tabular}{ |c|c| } 
      \hline
      Higher-Order Logic & Virtual Equipment Type Theory \\
      \hline
      Set $X$ & Category $\mathbb{C}$\\
      $X \times Y$ & $\mathbb C \times \mathbb D$ \\ 
      1 & $1$ \\
      $\mathcal P X$ & $\mathcal P^+ X$ \text{ and } $\mathcal P^- X$ \\
      $\{ (x,y) \in X \times Y | R(x,y) \}$ & $\sum_{\alpha:C;\beta:D} R$\\
      Function $f(x:X) : Y$ & Functor/Object $\alpha:\cat C \vdash A : \cat D$\\
      Relation $R(x,y)$ & Profunctor/Set $\alpha:\cat C; \beta:\cat D \vdash R$\\
      $R \wedge Q$ & $R \times Q$\\
      $\top$ & $1$\\
      $\forall x. P \Rightarrow Q$ & $\homrallXYtoZ {\alpha:\cat C} P Q \text{ and } \homlallXYtoZ {\alpha:\cat C} P Q$ \\
      $\exists x. P \wedge Q$ & $\tensorexistsXwithYandZ {\alpha:\cat C} P Q$\\
      $x =_X y$ & $\punitinXfromYtoZ {\cat C} \alpha \beta$\\
      Proof $\forall \overrightarrow \alpha. R_1 \wedge \cdots \Rightarrow Q$ & Nat. Trans./Element $\alpha_1,x_1: R_1(\alpha_1,\alpha_2),\ldots \vdash t : Q$\\
      \hline
    \end{tabular}
  \end{center}
  \caption{Analogy between Higher-Order Logic and \vett{} Judgments and Connectives}
\label{fig:hol-cats}
\end{figure}

The syntactic forms of \vett{} are given in
Figure~\ref{fig:syntax}.
%
First, we have categories, which are analogous to sorts in a
first-order theory. We have $M$ a base sort, product and unit sorts,
as well as the graph of a profunctor and the negative and positive
presheaf categories.
%
Next, objects $a,b,c$ are the syntax for the \emph{functors} between
categories. We call them objects rather than functors, because in
type-theoretic style, a functor is viewed as a ``generalized object''
parameterized by an input variable $\alpha : \cat C$.
%
Next, sets $P,Q,R$ are the syntax for \emph{sets}. These sets denote
\emph{profunctors}, i.e., a categorification of relations. Similar to
functors, rather than writing profunctors as functions ${\cat
  C}^o\times {\cat D} \to \Set$, we write them as sets with a
contravariant variable $\alpha:\cat C$ and a covariant variable
$\beta:\cat D$. The sets we can define are the Hom-set, the tensor and
internal hom, as well as products of sets, profunctors applied to two
objects and elements of positive and negative presheaves. Finally we
have elements of sets, which correspond to natural transformations of
multiple inputs, where again we view natural transformations valued in
a profunctor as generalized elements of profunctors.

After these forms we have types and terms, which represent the
meta-language that we use to talk about categories/profunctors/natural
transformations.  The types include the usual $\Pi$ and $\Sigma$ and
identity types of dependent type theory, along with universes of
categories, functors, profunctors and natural transformations.

Finally we have several forms of context which are used in the theory.
The contexts $\Gamma$ of term variables with their types are as usual;
we write ${\Gamma \isadtctx}$ to indicate that a context is well-formed.
The category contexts $\Gamma \vdash \Xi \boundary$ contain object
variables with their categories; the two forms of category context are
$\alpha : \cat C$, containing one variable that can be used both
contravariantly and covariantly, and $\alpha : \cat C ; \beta : \cat D$,
containing a contravariant variable $\alpha$ and covariant variable
$\beta$.  Finally, we have contexts $\Phi$ of element variables with
their sets, alternating with those sets' object variables.  A typical
$\Phi$ has the shape
\[
\alpha_1 : \cat C_1, x_1:R_1(\alpha_1,\alpha_2), \alpha_2 : \cat C_2,
x_2:R_2(\alpha_2,\alpha_3), \ldots, R_n(\alpha_n,\alpha_{n+1}), \alpha_{n+1} : C_{n+1}
\]
and represents the composition of the relations $R_1, R_2, R_3, \ldots,
R_n$.  We write $d^-(\Phi)$ for the first category variable in $\Phi$
(which we regard as the negative/contravariant position), $d^+(\Phi)$
for the last category variable in $\Phi$ (which we regard as the
positive/covariant position), and $\Phi_1 \jnctx \Phi_2$ for the append
of two category contexts where the last variable in $\Phi_1$ is equal to
the first variable in $\Phi_2$.  Formal inductive definitions are in the
appendix, but intuitively we have: 
\[
\begin{array}{ccl}
d^-(\alpha_1 : \cat C_1, x_1:R_1(\alpha_1,\alpha_2), \ldots, x_n:R_n(\alpha_n,\alpha_n), \alpha_{n+1} : \cat C_{n+1}) & = & \alpha_1 : \cat C_1\\
d^+(\alpha_1 : \cat C_1, x_1:R_1(\alpha_1,\alpha_2), \ldots, x_n:R_n(\alpha_n,\alpha_n), \alpha_{n+1} : \cat C_{n+1}) & = & \alpha_{n+1}:\cat C_{n+1}\\
(\Phi_1,\beta:\cat D) \jnctx (\beta:\cat D, \Phi_2) & = & \Phi_1, \beta : \cat D, \Phi_2
\end{array}
\]

%% %
%% First, we have the types and terms of the logic over our category
%% theory. Types include the usual dependent sum, product and identity
%% types of dependent type theory, as well as several forms that allow us
%% to abstract over the category theoretic constructions: a type $\Cat$
%% of categories, a type $\varr{\cat C}{\cat D}$ for functors from $\cat
%% C$ to $\cat D$, a type $\harr{\cat C}{\cat D}$ for profunctors
%% contravariant in $\cat C$ and covariant in $\cat D$, and finally a
%% type $\pendallXdotY {\alpha:{\cat C}} R$ that, when combined with
%% other constructions on profunctors, allows for abstraction over
%% arbitrary natural transformations.
%% %
%% Terms $L,M,N$ describe the elements of our logic's types, and include
%% the usual constructions as well as forms for defining categories,
%% functors, profunctors and natural transformations.
%% %
%% Next, we have a syntax for categories, which are written using a
%% blackboard font $\cat C, \cat D, \cat E$. Categories include terms $M$
%% of the category type (allowing for abstraction), in addition to
%% primitives for product and unit categories.
%% %
%% Next, we have a syntax for objects of a category, which, because they
%% are typed with respect to an input variable, provide a syntax for
%% functors.
%% %
%% The objects we can define are object variables, application of a
%% functor $M a$, and pairs of objects (for the product category) and the
%% unique object of the unit category.
%% %
%% Next, $P,Q,R$ stand for \emph{sets}, but similar to objects, they are
%% always typed with respect to a contravariant and covariant variable,
%% and so denote profunctors.
%% %
%% These include first the multiplicatives: the hom set
%% $\punitinXfromYtoZ {\cat C} a b$ representing the morphisms from $a$
%% to $b$ in $\cat C$, a tensor product $\tensorexistsXwithYandZ
%% {\beta:\cat D} P Q$, and two kinds of ``ordered function types''
%% $\homrallXYtoZ \beta P Q$ and $\homlallXYtoZ \alpha R S$. 
%% %
%% We also include application of a profunctor term $M$ to two objects,
%% and cartesian product and unit sets.
%% %
%% Next, we have transformations $s,t,u$, which are typed with respect
%% to (0 or more) input and (one) output set.

%% Finally, we have three forms of contexts, type contexts $\Gamma$, set
%% contexts $\Xi$ and transformation contexts $\Phi$. A type context
%% $\Gamma$ is the familiar notion of context from dependent type
%% theory. We use uppercase $X,Y,Z$ for term variables to distinguish
%% them from set variables. Every set expression $P$ must depend on an
%% object of one category covariantly and an object of one category
%% contravariantly, however these are allowed to be the same
%% object. These two scenarios are captured by the notion of set context
%% $\Xi$. The set context $\alpha:\cat C; \beta: \cat D$ gives the common
%% case where the contravariant variable $\alpha$ is different from the
%% covariant variable $\beta$, and the set context $\alpha: \cat C$ alone
%% gives the case where the profunctor depends on the same variable both
%% covariantly and contravariantly. Note that we write object variables
%% as greek letters $\alpha, \beta$. Transformation contexts $\Phi$
%% describe the inputs to a natural transformation. The input variables
%% of a natural transformation $x: R$ stand for elements of sets, but as
%% just described, sets always have covariant and contravariant
%% dependencies. For this reason, transformation contexts include
%% category variables $\alpha: \cat C$ interleaved with the set variables
%% $x : R$, a typical context $\Phi$ would look like $\alpha_1:\cat C_1,
%% x_1:R_1, \alpha_2: \cat C_2, x_2 : R_2, \alpha_3: \cat C_3$, where
%% $R_1$ is parameterized by $\alpha_1$ contravariantly and $\alpha_2$
%% covariantly and $R_2$ is similarly parameterized by
%% $\alpha_2;\alpha_3$. Note that we consider transformation contexts up
%% to associativity in that $(\Phi, x:R, \Psi), y : S, \Sigma$ should be
%% considered equal to $\Phi, x:R, (\Psi, y: S, \Sigma)$.  In this
%% calculus there is no single ``empty'' transformation context, but
%% rather the empty context is one that consists of a single category
%% variable $\alpha:\cat C$ and no set variables. Each form of context
%% has a corresponding form of substitution, denoted using the lower-case
%% form of the same greek letters.

\begin{figure}[t]
  \begin{mathpar}
    \begin{array}{rccl}
      \textrm{Categories} &\cat C, \cat D, \cat E & ::= & M \pipe \cat C \times \cat D \pipe \cat 1
      \pipe \graphProf \alpha \beta P \pipe \negPresheaf {\cat C} \pipe \posPresheaf {\cat C}
      \\
      \textrm{Objects} & a, b, c & ::= & \alpha \pipe M a \pipe (a,b) \pipe () \ldots\\
      \textrm{Sets} & P,Q,R & ::= & \punitinXfromYtoZ {\cat C} a b \pipe \tensorexistsXwithYandZ {\beta} P Q \pipe \homrallXYtoZ \beta P Q \pipe \homlallXYtoZ \alpha R S \\
      &&& 1 \pipe P \times Q\\
      &&& \pipe \harrapp M a b \pipe \negPresheafAppPtoX a b \pipe \posPresheafAppPtoX a b\\
      \textrm{Elements} & s,t,u & ::= & \ldots \\
      \\
      \textrm{Type} & A,B,C & ::= &
      \sum_{X:A} B \pipe \prod_{X:A} B \pipe \Id A M N \\
      &&& \Cat \pipe \varr{\cat C}{\cat D}\pipe \harr {\cat C} {\cat D}\pipe \pendallXdotY {\alpha:{\cat C}} R\\
      \textrm{Term} & L,M,N & ::= & X \pipe \lambda X:M. N \pipe M\,N \pipe (M,N) \pipe \pi_1 M \pipe \pi_2 M \mid \text{refl}_{M} \\
      &&&\lceil \cat C \rceil \pipe \vlambda {\alpha:\cat C} a \pipe \hlambda {\alpha:\cat C}{\beta: \cat D} R \mid \ldots \\
      \textrm{Type Context} & \Gamma, \Delta & ::= & \cdot \pipe \Gamma, X : A\\
      \textrm{Category Context} & \Xi, Z & ::= & \alpha:\cat C \pipe \alpha:\cat C;\beta: \cat D\\
      \textrm{Set Context} & \Phi,\Psi & ::= & \alpha : \cat C \pipe \Phi , x : P,\beta:\cat D\\
    \end{array}
  \end{mathpar}
  \caption{\vett{} Syntactic Forms}
  \label{fig:syntax}
\end{figure}

Next, we overview our basic judgement forms.  We have
\begin{itemize}
\item Categories: ${\Gamma\vdash \cat C \isaCat}$, where ${\Gamma \isadtctx}$.
  
\item Objects/functors: ${\Gamma \pipe \alpha : \cat C \vdash a : \cat
  D}$, where $\Gamma \vdash \cat C\isaCat$ and $\Gamma \vdash \cat D
  \isaCat$.  Objects are typed with an input object variable $\alpha :
  \cat C$ and an output category $\cat D$; in the semantics, objects are
  modeled as functors $\cat C \to \cat D$.
  
\item Sets/profunctors: ${\Gamma \pipe \Xi \vdash S \isaSet}$, where
  $\Gamma \vdash \Xi \boundary$. A set $S$ is typed with respect to a set
  context $\Xi$ to describe its covariant/contravariant dependence on
  some input objects. Sets are semantically modeled as profunctors.
  
\item Elements/natural transformations: ${\Gamma \pipe \Phi \vdash s :
  R}$, where ${\Gamma \vdash \Phi \isavectx}$ and $\Gamma\pipe
  \underline \Phi \vdash R \isaSet$.  A transformation $s$ has a context
  of transformation variable and a single set output. To be well formed,
  the context and set must be parameterized by the same contravariant
  and covariant object variables. To ensure this, we use a coercion
  operation $\underline \Phi$ that erases everything in the context but
  the left-most and right-most object variables, i.e. $\underline{\alpha
    : \cat C} = \alpha : \cat C$ and $\underline{\Phi} =
  d^-(\Phi);d^+(\Phi)$ otherwise.

\item Meta-language types and terms: $\Gamma \vdash A \isaTy$ and
  $\Gamma \vdash M : A$ as in standard dependent type theory.
\end{itemize}

%% \begin{figure}
%%   \begin{mathpar}
%%     \inferrule*[right=Cat-form]
%%     {\Gamma \isadtctx}
%%     {\Gamma\vdash \cat C \isaCat}

%%     \inferrule*[right=Ob-form]
%%     {\Gamma \vdash \cat C\isaCat\and \Gamma \vdash \cat D \isaCat}
%%     {\Gamma \pipe \alpha : \cat C \vdash a : \cat D}\\

%%     \inferrule*[right=SetForm]
%%     {\Gamma \isadtctx \and \Gamma \vdash \Xi \boundary}
%%     {\Gamma \pipe \Xi \vdash S \isaSet}

%%     \inferrule*[right=TransFormation]
%%     {\Gamma \vdash \Phi \isavectx\and
%%      \Gamma\pipe \underline \Phi \vdash R \isaSet}
%%     {\Gamma \pipe \Phi \vdash s : R}
%%   \end{mathpar}
%%   \caption{Selected Formation Rules}
%%   \label{fig:formation}
%% \end{figure}

%% The following figures present the basic formation, primitive and
%% admissible equality rules of our type theory, an internal language for
%% virtual double categories with restrictions.
%% %
%% The type theory has 4 central concepts, which we will refer to
%% sometimes using type theoretic/set theoretic and at other times
%% category-theoretic terminology.
%% %
%% In type theoretic terminology, judgment theory has \emph{sorts} $\cat
%% C, \cat D, \cat E$, and \emph{types} $A,B,C$ which have a given sort
%% and are also \emph{parameterized} by an object of some other sort, and
%% so can also be thought of as \emph{functions} with input and output
%% sorts.
%% %
%% Next there are \emph{judgments} $P,Q,R,S$ which are parameterized by
%% two variables.
%% %
%% In $\alpha^o:\cat C;\beta : \cat D \pipe R$, we say $R$ depends on
%% $\alpha$ \emph{contravariantly} and in $\beta$ \emph{covariantly}.
%% %
%% Finally, we have \emph{terms} $s,t,u$ that are elements of some
%% judgment $R$ but are also parameterized by elements of some other
%% judgments which are given by a \emph{context} $\Phi$, which is a
%% ``compatible string'' of judgments where the covariant variable of one
%% judgment is the same as the contravariant variable of the next.
%% %
%% Since these terms are parameterized by other terms, we can see these
%% as \emph{inference rules} for the judgments.

%% At other times we will want to think of these using set-theoretic
%% terminology, in which case we have sets $\cat C,\cat D, \cat E$,
%% functions/elements $A,B,C$, \emph{spans} $R,\ldots$ and morphisms of
%% spans $s,t,u$.
%% %
%% Finally when we develop multicategory theory we will use
%% category-theoretic terminology, in which the structure is most
%% familiar and we have categories, objects/functors,
%% \emph{profunctors}/bimodules and 2-cells/homomorphisms of bimodules.

%% Figure\ref{fig:formation} introduces the formation rules for the basic
%% constructs. Sorts give a syntax for objects of the double
%% category. Types have an output sort and a sorted input variable, and
%% model vertical arrows. Next, judgments have two sorted variables, one
%% contravariant and one covariant, which can be the same
%% variable. Judgments model the horizontal arrows. Next are contexts,
%% whose formation rule is the same as judgments, and which give a syntax
%% for ``compatible strings'' of judgments. Then terms have an input
%% context and an output judgment, which must have the same covariant and
%% contravaiant variables, modeling ``globular'' 2-cells. Finally, we
%% have substitutions for terms, which are typed with respect to an input
%% context, an output context and two types, forming a kind of
%% square. These model the ``compatible string'' of 2-cells that arise in
%% the composition laws.

%% Next, Figure~\ref{fig:basic-rules} gives the basic structural rules of
%% judgment theory, which model composition and restrictions in a virtual
%% double category. First, we have varialbes and substitution for types,
%% modeling identity and composition of vertical arrows. Next, we have
%% restriction of a judgment to more specific types, which is given by
%% substitution of types for the judgment's parameter variables. Next, we
%% have rules for constructing an ``empty'' context, which is just a

All syntactic forms typed in context admit an action of
substitution. For (meta-language) types and terms, this is as
usual. Objects $\alpha:\cat C \vdash a : \cat D$ can be substituted for
object variables $\beta : \cat D$ in other objects. We can also
substitute objects into \emph{sets}, that is, if we have a set $P$
parameterized by a contravariant variable $\alpha : \cat C$ and a
covariant variable $\beta: \cat D$, then we can substitute objects $a :
\cat C$ and $b : \cat D$ for these variables $P[a/\alpha;b/\beta]$. This
generalizes the ordinary precomposition of a relation by a function.
Semantically this is the ``restriction'' of a profunctor along two
functors, which is just composition of functors if a profunctor is
viewed as a functor to $\Set$. Modeling this operation as a substitution
considerably simplifies reasoning using profunctors.
%
Finally we have the action of substitution on elements/natural transformations.
First, we can substitute elements/natural transformations for the set
variables in elements, denoting the composition of natural
transformations.  Second, an element is also parameterized
by a contravariant and a covariant category variable $\alpha;\beta$. We
can think of natural transformations as \emph{polymorphic} in the
categories involved, and so when we make a transformation substitution,
we also \emph{instantiate} the polymorphic category variables with
objects.
%
The full syntactic details of substitution are included in the appendix.

\subsection{Category Connectives}

In this section we discuss some connectives for constructing categories,
which are specified by introduction and elimination rules in
Figure~\ref{fig:category-connectives} (the $\beta\eta$ equality and
substitution rules are included in the appendix).  The introduction and
elimination rules make use of functors, profunctors, and natural
transformations.
%
First we introduce the additives: the unit category $1$ and product
category $\cat C \times \cat D$ have the usual introduction and
elimination rules defining functors to/from them.  
%
Next, we introduce the \emph{graph of a profunctor} $\graphProf \alpha
\beta P$. Just as a relation $R : A \times B \to \Set$ can be viewed
as a subset $\{ (a,b) \in A\times B | R(a,b)\}$, any profunctor $P :
C_-^o\times C_+ \to \Set$ can be viewed as a category with a functor
to $C_- \times C_+$ (no op), specifically a two-sided discrete
fibration. In set-based category theory, the objects are triples
$(a_-, a_+, s : P(a_-,a_+))$ and morphisms from $(a_-,a_+, s)$ to
$(a_-',a_+', s')$ are pairs of morphisms $f_- : a_- \to a_-'$ and $f_+
: a_+ \to a_+'$ such that $P(\id,f_+)(s) = P(f_-,\id)(s')$.
%
With various choices of $P$, this connective can be used to define the
arrow category, slice category and comma category constructions.
%
In our syntax we define it as the universal category $\cat C$ equipped
with functors to $\cat C_-$ and $\cat C_+$ and a morphism to $P$.

Lastly, we define the \emph{negative} and \emph{positive} presheaf
categories $\negPresheaf \cat C$ and $\posPresheaf \cat D$. These are
given a syntax suggestive of the fact that they generalize the notion
of a powerset, and so can be thought of as ``power categories''.
%
Note that we include a restriction that the input category is
\emph{small}, which is an inductively defined by saying all base
categories are small, the unit is small, product of small categories
is small and the graph of a profunctor over small categories is
small. Notably, the presheaf categories themselves are not small.
%
The negative presheaf category is defined by its universal property
that a functor into it $\cat D \to \negPresheaf \cat C$ is equivalent
to a profunctor $\cat C^o \times \cat D \to \Set$.
%
The introduction rule constructs an object of the negative presheaf
category from such a profunctor and the elimination rule inverts
it. We use the notation $\negPresheafApp a p$ for the elements of the
induced profunctor.
%
The positive presheaf category is then the dual. In ordinary
set-theoretic category theory the negative presheaf category is the
usual presheaf category $\Set^{\cat C^o}$, and the positive presheaf
category is the opposite of the dual presheaf category $(\Set^{\cat
  D})^o$.

\begin{figure}[t]
  \begin{scriptsize}
  \[
  \begin{array}{l}
    \text{Unit:} \quad
    \inferrule{ ~ }{\Gamma \vdash 1 \isaCat}
    \quad
    \inferrule*{ ~ }{\Gamma\pipe\alpha:C \vdash () : 1}\\\\
    
    \text{Product:} \quad
    \inferrule
        {\Gamma \vdash \cat C_1 \isaCat \and \cat C_2 \isaCat}
        {\Gamma \vdash {\cat C_1} \times {\cat C_2} \isaCat}
    \quad    
    \inferrule
    {\Gamma \pipe \alpha:\cat C \vdash a_1 : \cat C_1 \and \Gamma \pipe \alpha:\cat C \vdash a_2 : \cat C_2}
    {\Gamma \pipe\alpha:\cat C \vdash (a_1,a_2) : {\cat C_1} \times {\cat C_2}}
    \quad
    \inferrule
    {\Gamma \pipe\alpha:\cat C \vdash a : {\cat C_1} \times {\cat C_2}}
    {\Gamma\pipe\alpha:\cat C\vdash \pi_i a : \cat C_i}
    \\\\
    
    \text{Graph of a profunctor:} \\
    \inferrule
    {\Gamma \pipe \alpha:\cat C;\beta:\cat D \vdash P \isaSet}
    {\Gamma \vdash \graphProf{\alpha}{\beta} P \isaCat}
    \quad
    \inferrule
    {\defaultObCtx \vdash a_- : C_-\and
      \defaultObCtx \vdash a_+ : C_+\and
      \defaultObCtx \vdash s : P[a_-/\alpha;a_+/\beta]}
    {\defaultObCtx \vdash (a_-,a_+,s) : \graphProf{\alpha:\cat C_-}{\beta:\cat C_+} P}
    \\
    \inferrule
    {\defaultObCtx \vdash a : \graphProf{\alpha:\cat C_-}{\beta} P}
    {\defaultObCtx \vdash \pi_- a : \cat C_-}
    \quad
    \inferrule
    {\defaultObCtx \vdash a : \graphProf{\alpha}{\beta:C_+} P}
    {\defaultObCtx \vdash \pi_+ a : \cat C_+}
    \quad
    \inferrule
    {\defaultObCtx \vdash a : \graphProf{\alpha}{\beta} P}
    {\defaultObCtx \vdash \pi_e a : P[\pi_-a/\alpha;\pi_+a/\beta]}
    \\\\
    \text{Negative Presehaf:} \\
    \inferrule
    {\Gamma \vdash \cat C \isaCat \and \cat C \isSmall}
    {\Gamma \vdash \negPresheaf {\cat C} \isaCat}
    \quad
    \inferrule
    {\Gamma \pipe d^-\Xi \vdash a : \cat C \and
     \Gamma \pipe d^+\Xi \vdash p : \negPresheaf {\cat C}
    }
    {\Gamma \pipe \Xi \vdash \negPresheafAppPtoX p a \isaSet}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C;\beta:\cat D \vdash R : \isaSet}
    {\Gamma \pipe \beta:\cat D \vdash \lambda \alpha:\cat C. R : \negPresheaf {\cat C}}
    \\
    \\
    \text{Positive Presehaf:} \\
    \inferrule
    {\Gamma \vdash \cat D \isaCat \and \cat D \isSmall}
    {\Gamma \vdash \posPresheaf {\cat D} \isaCat}
    \quad
    \inferrule
    {\Gamma \pipe d^-\Xi \vdash p : \posPresheaf {\cat D}\and
     \Gamma \pipe d^+\Xi \vdash a : \cat D
    }
    {\Gamma \pipe \Xi \vdash \posPresheafAppPtoX p a \isaSet}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C;\beta:\cat D \vdash R : \isaSet}
    {\Gamma \pipe \alpha:\cat C \vdash \lambda \beta:\cat D. R : \posPresheaf {\cat D}}
  \end{array}
  \]
  \end{scriptsize}
  \caption{Category Conectives}
  \label{fig:category-connectives}
\end{figure}

\subsection{Set Connectives}

Next, in Figure~\ref{fig:set-connectives}, we cover the connectives for
the sets/profunctors, which classify elements/natural transformations
(the $\beta/eta$-rules are in the appendix).
%% %
%% The top of the figure includes the formation rules for tensor products
%% $\tensorexistsXwithYandZ \beta P Q$, the covariant $\homrallXYtoZ
%% \alpha R P$ and contravariant homs $\homlallXYtoZ {\alpha} R P$ and
%% the unit type $\punitinXfromYtoZ {\cat C} {a_1}{a_2}$, and
%% the cartesian unit and product types $1$ and $R \times S$.  
%% %
%% The remainder of the figure gives the introduction and elimination rules
%% for these sets .  
%% %
First, the unit set is our syntax for the profunctor of morphisms of a
category $\cat C$, which is well-formed when given two objects of the
same category.  
%
Its introduction and elimination rules are analogous to the usual rules
for equality in Martin-L\"of type theory.  The introduction rule is the
identity morphism (reflexivity) and the elimination rule is an induction
principle: we can use a term of $s : \punitinXfromYtoZ {\cat C} A B$ by
specifying the behavior when $s$ is of the form $\punitrefl \alpha$ in
the form of a continuation $\alpha. t$.  Like the $J$ elimination rule
for equality in Martin-L\"of type theory, $P$ must be ``fully general'',
i.e. well-typed for variables $\alpha$ and $\beta$; this is because for
distinct variables $\alpha$ and $\beta$, $\punitinXfromYtoZ{\cat
  C}{\alpha}{\beta}$ denotes the unit, which has a universal property,
but $\punitinXfromYtoZ{\cat C} A B$ denotes a restriction of a unit,
which in general does not.  Those familiar with linear
logic~\cite{polakawpfenning} might expect a more general rule, with the
continuation $t$ typed in a context $\Phi_l \jnctx \Phi_r$ and $\Phi_l
\jnctx \Phi \jnctx \Phi_r$ as the context of the conclusion of the rule.
Because of dependency, this is not necessarily well-formed in cases
where the endpoints $A$ and $B$ of $\punitinXfromYtoZ{\cat C} A B$ are
not fully general (i.e. not distinct variables).  However, the instances
of this more general rule that do type check are derivable from our more
restricted rule using right/left-hom types.

The tensor product of sets is a kind of combined existential quantifier
and monoidal product, which we combine into a single notation
$\tensorexistsXwithYandZ \beta P Q$, where $\beta$ is the covariant
variable of $P$ and the contravariant variable of $Q$. Then the
covariant variable of the tensor product is the covariant variable of
$Q$ and the contravariant variable similarly comes from $P$.
%
In ordinary category theory, this is the \emph{composition} of
profunctors, and is defined by a coend of a product. We require that
the variable $\beta$ quantifies over a small category $\cat D$, as in
general this composite doesn't exist for large categories.
%
The introduction and elimination are like those for a combined tensor
product and existential type: the introduction rule is a pair of
terms, with an appropriate instantiation of $\beta$, and the
elimination rule says to use a term of a tensor product, it is
sufficient to specify the behavior on two elements typed with an
arbitrary middle object $\beta$.

Next, we introduce the contravariant ($\homlallXYtoZ \alpha R P$) and
covariant ($\homrallXYtoZ \alpha R P$) homs of sets, which are
different from each other because we are in an ordered logic.
%
These are a kind of universally quantified
function type, where the universally quantified variable must occur
with the same variance in domain and codomain. In the contravariant
case, it occurs as the contravariant variable in both, and vice-versa
for the covariant case.
%
To highlight this, the notation for the contravariant dependence puts
the quantified variable on the \emph{left} of the triangle, as
contravariant variables occur to the left of the covariant variable,
and similarly the covariant hom has the quantified variable on the
right.
%
Then the
covariant variable of the contravariant hom set is the covariant
variable of the codomain and, and the contravariant variable of the
hom set is the \emph{covariant} variable of the domain, as the two
contravariances cancel. The covariant hom is dual.
%
Semantically, in ordinary category theory these are known as the
\emph{hom} of profunctors and are constructed using a combination of
an end and a function set.
%
The two connectives have similar introduction and elimination rules in
the form of $\lambda$ terms abstracting over both the object of the
category and the element of the set, and appropriate application
forms.
%
To keep with our invariant that the variable occurrences occur left to
right in the term syntax in a manner matching the context, we write
the covariant application in the usual order $\homrappXtoYatZ s t a$
where the function is on the left and the argument is on the right,
and the contravariant application in the flipped order.
%
We also write the instantiating object as a superscript to
de-emphasize it, as in practice it can often be inferred.

Finally, we have the cartesian unit and product sets, which are
analogous to the normal unit and product of types. The most notable
point to emphasize is that in the formation rule for the product, the
two subformulae should have the same covariant and contravariant
dependence (as with linear logic, some constructions can
syntactically use a variable more than once and still be ``linear'').  
%% the
%% unit constructor ``uses'' all variables and the product ``uses'' all
%% variables in both cases.

\begin{figure}[t]
  % unit,
  \begin{scriptsize}
  \[
  \begin{array}{l}
    
    \text{Unit/morphism set:}\\
    \inferrule
  {\Gamma \pipe d^-\Xi \vdash a_1 : \cat C\\\\ \Gamma \pipe d^+ \Xi \vdash a_2 : \cat C}
  {\Gamma \pipe \Xi \vdash \punitinXfromYtoZ {\cat C} {a_1} {a_2} \isaSet}
  \quad
    \inferrule
    {\Gamma\pipe\beta: \cat D \vdash a : \cat C}
    {\Gamma \pipe \beta : \cat D \vdash \punitrefl a : \punitinXfromYtoZ {\cat C} a a}
    \quad
%%     \inferrule*[right=Unit Elim]
%%     {\Gamma\vdash Q : \harr {\cat C} {\cat C}\and
%%      \Gamma\vdash t : \pendallXdotY {\alpha:\cat C} {\harrapp Q \alpha \alpha}}
%%     {\Gamma \vdash \punitelimtoYwithkontZ Q N :
%%       \pendallXdotY {\alpha_1} {\homrallXYtoZ {\alpha_2} {\punitinXfromYtoZ {\cat C} {\alpha_1}{\alpha_2}} {\harrapp Q {\alpha_1}{\alpha_2}}}}
    \inferrule
    {\Gamma\pipe \alpha:\cat C; \beta:\cat C \vdash P \isaSet \\\\
     \Gamma\pipe \alpha:\cat C\vdash t : P[\alpha/\alpha;\alpha/\beta]\\\\
     \Gamma\pipe\Phi \vdash s : \punitinXfromYtoZ {\cat C} A B}
    {\Gamma \pipe \Phi \vdash \punitelimkontZatABC {\alpha. t} A s B : P[A/\alpha;B/\beta]}
    \\
  %% \inferrule*[right=Tensor intro function]
  %% {}
  %% {\alpha : \cat C, q : Q, \beta : \cat D, r : R, \gamma : \cat E \vdash (q, \beta,r) : \exists \beta : \cat D. Q \odot R}

  %% \inferrule*[right=Tensor introduction]
  %% {\Gamma \vdash P : \harr C D \and
  %%   \Gamma \vdash Q : \harr D E}
  %% {\Gamma\pipe\cdot\vdash \tensorintroofXandY P Q : \pendallXdotY {\alpha} \homrallXYtoZ \beta {\harrapp P \alpha \beta} {\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta}{\harrapp Q \beta \gamma})}}}

    \\
    \text{Tensor product:}\\
    \inferrule
    {\cat D \isSmall\\\\
      \Gamma \pipe d^-\Xi; \beta:D\vdash P \isaSet\\\\
     \Gamma \pipe \beta:D;d^+\Xi \vdash Q \isaSet}
    {\Gamma \pipe \Xi \vdash \tensorexistsXwithYandZ {\beta:D} P Q \isaSet}
    \quad
  \inferrule
  {\Gamma \pipe d^+\Psi_s \vdash b : \cat D\\\\
   \Gamma \pipe \Psi_s \vdash s : P[b/\beta] \\\\
   \Gamma \pipe \Psi_t \vdash t : Q[b/\beta]}
  {\Gamma\pipe\Psi_s \jnctx \Psi_t\vdash \tensorintroatXwithYandZ b s t : \tensorexistsXwithYandZ {\beta : \cat D} P Q}
  \quad
  \inferrule
  {
   \Gamma\pipe \Phi_l \jnctx x:P, \beta:\cat D, y:Q \jnctx \Phi_r \vdash t : R\\\\
   \Gamma \pipe\Phi_m \vdash s : \tensorexistsXwithYandZ {\beta} P Q}
  {\Gamma\pipe\Phi_l\jnctx \Phi_m \jnctx \Phi_r \vdash \tensorelimWkontZ s {x.\beta.y. t} : R}
  \\
  %% \tensorintroatXwithYandZ B M N [\phi,B'/\beta',\psi] = \tensorintroatXwithYandZ {B[B'\beta]} {M[\phi]} {N[\psi]}

  %% \inferrule*[right=Tensor simpl]
  %% {\Gamma\pipe\cdot \vdash R : \harr {C} {E}\and
  %%  \Gamma\pipe\cdot \vdash N : \pendallXdotY {\alpha:C} {\homrallXYtoZ {\beta:D} P {\homrallXYtoZ {\gamma:E} Q {\harrapp R \alpha\gamma}}}}
  %% {\Gamma\pipe\alpha:C,p:\tensorexistsXwithYandZ {\beta:D} P Q,\gamma:E \vdash\tensorelimVatWtoXtoYwithkontZ p \alpha \gamma R N : \harrapp R A G}

%%   \inferrule*[right=Tensor-elim]
%%   {\Gamma \pipe \vdash P : \harr {\cat C} {\cat D}\and\Gamma \vdash Q : \harr {\cat D}{\cat E}\and
%%    \Gamma \vdash R : \harr {\cat C}{\cat E}\and
%%    \Gamma \vdash N : \hombinary \alpha {\harrapp P \alpha \beta} \beta {\harrapp Q \beta \gamma} \gamma {\harrapp R \alpha \gamma}}
%%   {\Gamma \vdash \tensorelimfromWXtoYwithkontZ P Q R N : \homunary \alpha {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\gamma} {\harrapp R \alpha \gamma}}

  \\
  \text{Right hom:} \quad
  \inferrule
  {d^+\Xi \isSmall\\\\ \Gamma \pipe d^+\Xi; \alpha : \cat C \vdash  R
    \isaSet \\\\ \Gamma \pipe  d^-\Xi; \alpha : \cat C \vdash P \isaSet}
  {\Gamma \pipe \Xi \vdash \homrallXYtoZ {\alpha:\cat C} R P \isaSet}
  \quad
  \inferrule
  {\Gamma \pipe \Phi, x : R, \alpha : \cat C \vdash t : P}
  {\Gamma \pipe \Phi \vdash
   \homrlambdaXatYdotZ {x : R} {\alpha : \cat C} t : \homrallXYtoZ \alpha R P}
  \quad
  \inferrule
  {\Gamma\pipe\Phi_f \vdash s : \homrallXYtoZ {\alpha:\cat C} R P \\\\
    d^+\Phi_a \vdash a : \cat C\\\\
    \Phi_a \vdash t : R[a/\alpha]
  }
  {\Gamma\pipe \Phi_f \jnctx \Phi_a \vdash \homrappXtoYatZ s t a : P[a/\alpha]}\\
  \quad

      %% \inferrule*[right=Covar Hom elim simple]
      %% {}
      %% {\alpha: \cat C, f:\forall \gamma. P \triangleleft R, \beta : \cat D, x : R, \gamma : \cat E \vdash f\triangleleft (x, \gamma) : P}

  \\ 
  \text{Left hom:} \quad
  \inferrule
    {d^-\Xi \isSmall\\\\
      \Gamma \pipe \alpha:\cat C; d^-\Xi\vdash R \isaSet \\\\ \Gamma
      \pipe \alpha : \cat C; d^+\Xi\vdash P \isaSet }
    {\Gamma \pipe \Xi \vdash \homlallXYtoZ {\alpha: \cat C} R P \isaSet}
  \quad
  \inferrule
  {\Gamma\pipe\alpha:\cat C, x : R, \Phi \vdash t : P}
  {\Gamma\pipe\Phi \vdash \homllambdaXatYdotZ {x : R} {\alpha : \cat C} t : \homlallXYtoZ \alpha R P}
  \quad
  \inferrule
  {\Gamma \pipe d^-\Phi_a \vdash a : \cat C\\\\
   \Gamma \pipe \Phi_a \vdash s : R[a/\alpha] \\\\
   \Gamma \pipe \Phi_f \vdash t : \homlallXYtoZ {\alpha:\cat C} R P}
  {\Gamma \pipe \Phi_a \jnctx \Phi_f \vdash \homlappXtoYatZ t s a : P[a/\alpha]}\\
  % tensor,
  % hom,
  % cartesian products,
  % 

  \\
  \text{Cartesian unit and products:} \quad
      \inferrule{~}{\Gamma\pipe \Xi \vdash 1 \isaSet}
      \quad
      \inferrule{~}{\Gamma\pipe \Phi \vdash () :  1}
      \\ 
    \inferrule{\Gamma\pipe\Xi \vdash R \isaSet \\\\ \Gamma\pipe\Xi \vdash S\isaSet}
              {\Gamma\pipe\Xi \vdash R \times S\isaSet}
    \quad
    \inferrule{\forall i \in \{1,2\}.~ \Gamma \pipe\Phi \vdash M_i : R_i}{\Gamma \pipe\Phi \vdash (M_1,M_2) : R_1 \times R_2}
    \quad
    \inferrule{\Gamma \pipe\Phi\vdash M : R_1 \times R_2}{\Gamma \pipe\Phi \vdash \pi_i M : R_i}
  \end{array}
  \]
  \end{scriptsize}
  \caption{Set Connectives}
  \label{fig:set-connectives}
\end{figure}

\subsection{Type Connectives}

Finally, we briefly describe the connectives for the ``meta-logic'',
which extends Martin-L\"of type theory with $\Pi$/$\Sigma$ and extensional
identity types (with their standard rules)~\cite{emltt}. We use
extensional identity types so that the description of models is simpler,
but intensional identity types could be used instead.
%
The types we include are \emph{universes} for the object categorical
logic: types of small categories and locally small categories, functors,
profunctors and natural transformations.
%
The rule for the types of small categories and (large) categories are
very similar: any definable category defines an element of type $\Cats$,
and any element of that type can be reflected back into a category. The
only difference for $\smallCats$ is that the categories involved
additionally satisfy $\cat C \isSmall$. Again we elide the $\beta\eta$
principles, which state that $\quoth{-}$ and $\unquoth{-}$ are mutually
inverse.
%
Since every small category $\cat C \isSmall$ is a category $\cat C
\isaCat$, there is a definable inclusion function from $\smallCats$ to
$\Cat$ and the $\beta\eta$ properties ensure that this is a
monomorphism.

Next, we have the types of all functors and profunctors between any
two fixed categories.
%
The introduction and elimination forms are those for unary and binary
function types respectively, where metalanguage terms of type
$\varr{\cat C}{\cat D}$ can be used to construct an object/functor,
while metalanguage terms of type $\harr{\cat C}{\cat D}$ can be used to
construct a set/profunctor.

Finally we include a type $\pendallXdotY {\alpha:\cat C} P$ which we
call the set of ``natural elements'' of $P$.
%
The name comes from the case that $P$ is of the form
$\punitinXfromYtoZ {}{F(\alpha)}{G(\alpha)}$ in which case the type
$\pendallXdotY {\alpha:\cat C} \punitinXfromYtoZ
{}{F(\alpha)}{G(\alpha)}$ can be interpreted as the set of all natural
transformations from $F$ to $G$.
%
More generally this is modeled as an end, and we notate it with a
universal quantifier (just as we do for the quantifiers in left/right
hom types).  Syntactically, $\pendallXdotY{\alpha}{P}$ is a
meta-language type that represents elements/natural transformations with
exactly one free variable.  

\begin{figure}
  \begin{scriptsize}
  \[
  \begin{array}{l}
    \inferrule
    {~}
    {\Gamma\vdash \smallCats}
    \quad
    \inferrule
    {\Gamma \vdash \cat C \isSmall}
    {\Gamma \vdash \quoth {\cat C} : \smallCats}
    \quad
    \inferrule
    {\Gamma \vdash M : \smallCats}
    {\Gamma \vdash \unquoth M \isSmall}
    \quad
    \inferrule
    {~}
    {\Gamma\vdash \Cats}
    \quad
    \inferrule
    {\Gamma \vdash \cat C \isaCat}
    {\Gamma \vdash \quoth {\cat C} : \Cat}
    \quad
    \inferrule
    {\Gamma \vdash M : \Cat}
    {\Gamma \vdash \unquoth M \isaCat}
    \\ \\
    
    \inferrule
    {\Gamma \vdash \cat C \isaCat \and\Gamma \vdash \cat D \isaCat}
    {\Gamma\pipe\cdot \vdash \varr{\cat C}{\cat D} \isaTy}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C \vdash A : \cat D}
    {\Gamma \vdash \lambda \alpha:\cat C. A : \varr{\cat C}{\cat D}}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C \vdash A : \cat D\and
      \Gamma\pipe\cdot \vdash M : \varr{\cat D}{\cat E}}
    {\Gamma\pipe \alpha:\cat C \vdash M A : \cat E}
    \\ \\
    
    \inferrule
    {\Gamma \vdash \cat C \isaCat \and\Gamma \vdash \cat D \isaCat}
    {\Gamma\pipe\cdot \vdash \harr{\cat C}{\cat D} \isaTy}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C;\beta:\cat D \vdash R \,\isaSet}
    {\Gamma \vdash \lambda \alpha:\cat C;\beta:\cat D. R : \harr{\cat C}{\cat D}}
    \quad
    \inferrule
    {\Gamma \vdash M : \harr{\cat C}{\cat D}\\\\
     \Gamma \pipe d^- \Xi \vdash A : \cat C\\\\
     \Gamma \pipe d^+ \Xi \vdash B : \cat C}
    {\Gamma \pipe \Xi \vdash M A\, B \isaSet}
    \\ \\
    
    \inferrule
    {\Gamma \pipe \alpha:\cat C\vdash P \isaSet}
    {\Gamma \vdash \pendallXdotY {\alpha:{\cat C}} P \isaTy}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C\vdash t : P}
    {\Gamma \vdash \pendlambdaXdotY \alpha t : \pendallXdotY \alpha P}
    \quad
    \inferrule
    {\Gamma \vdash M : \pendallXdotY \alpha P\and
     \Gamma \pipe \beta:\cat D \vdash a : \cat C}
    {\Gamma \pipe \beta:\cat D \vdash \pendappXtoY M a : P[a/\alpha]}
  \end{array}
  \]
  \end{scriptsize}
  \caption{Type Connectives}
\end{figure}

\section{Formal Category Theory in VETT}
\label{sec:examples}

To demonstrate what formal category theory in VETT looks like, we
demonstrate some basic definitions and theorems.  While it is well known
that much category theory can be formalized in virtual equipments, we
show these examples to demonstrate how the VETT syntax gives a more
familiar syntax to these constructions, while still avoiding the need
for explicit naturality and functoriality side conditions.  We have
checked some of the results in this section (e.g. Lemma~\ref{lem:yoneda}
and Lemma~\ref{lem:fubini-short} and the maps in
Lemma~\ref{lem:adjunction}) in
Agda.\footnote{\url{https://github.com/maxsnew/virtual-equipments/blob/master/agda/Examples.agda}}

First, we using the elimination for the unit set, we can see that all
constructions are (pro-)functorial:
\begin{construction}
  For any small category $\cat C$, we can construct natural elements
  \begin{enumerate}
  \item Identity: $\pendallXdotY {\alpha} {\punitinXfromYtoZ {\cat C}{\alpha}{\alpha'}}$
  \item Composition: $\hombinary {\alpha_1} {\punitinXfromYtoZ {}{\alpha_1}{\alpha_2}} {\alpha_2} {\punitinXfromYtoZ {}{\alpha_1}{\alpha_2}} {\alpha_3} {\punitinXfromYtoZ {}{\alpha_1}{\alpha_3}}$
  \item Functoriality: for any $F : \varr {\cat C}{\cat D}$, $\homunary {\alpha_1} {\punitinXfromYtoZ {}{\alpha_1}{\alpha_2}} {\alpha_2} {\punitinXfromYtoZ {} {F(\alpha_1)}{F(\alpha_2)}}$.
   \item Profunctoriality: for any $R : \harr {\cat C}{\cat D}$ if
     $\cat D$ is small then \\ $\homtrinary {\alpha_1}
     {\punitinXfromYtoZ{} {\alpha_1}{\alpha_2}} {\alpha_2}
     {R{\alpha_2}{\beta_2}} {\beta_2} {\punitinXfromYtoZ{} {\beta_2}
       {\beta_1}} {\beta_1} {R\alpha_1\beta_1}$
  \end{enumerate}
\end{construction}
Reflexivity and transitivity generalize the corresponding properties
of equality, with the lack of symmetry being a key feature of the
generalization.
%
In addition, we can prove that the (pro)-functoriality axioms commute
with the composition proof by the $\eta$ principle for the unit.
%
(Pro-)Functoriality generalizes the statement that all functions and
relations respect equality.
%
Naturality is more complex to state, and it is a statement about the
\emph{proofs} so it has no analogue in ordinary higher-order
logic. The following version is stated for any \emph{profunctor}, with
the usual case of naturality arising when $R \alpha \beta =
\punitinXfromYtoZ {\cat C}{F \alpha}{G \beta}$.
\begin{lemma}[Naturality]
  For any $t : \pendallXdotY {\alpha:\cat C}{\harrapp R \alpha
    \alpha}$, by composing with profunctoriality, we can construct
  terms $\alpha_1, f : \punitinXfromYtoZ {\cat C} {\alpha_1}
  {\alpha_2}, \alpha_2 \vdash \textrm{lcomp}(f,\pendappXtoY t
  {\alpha_2})$ and $\textrm{rcomp}(\pendappXtoY t {\alpha_1}, f) :
  \harrapp R {\alpha_1}{\alpha_2}$ that are both equal to
  $\punitelimtoYwithkontZ f {t}$.
\end{lemma}

Next, we turn to some of the central theorems of category theory, the
Yoneda and Co-Yoneda lemmas. Despite being ulimately quite elementary,
these are notoriously abstract. In \ohol{}, we can view these as
ordered generalizations of some very simple tautologies about
equality. For instance, the Yoneda lemma generalizes
the equivalence between the formulae $\forall x. \forall y. x = y
\Rightarrow P y$ and $P x$.
\begin{lemma} \label{lem:yoneda}
  Let $\alpha^o : \cat C$ and $\pi : \negPresheaf {\cat C}$. Then
  \begin{enumerate}
  \item (Yoneda) The profunctor $\homrallXYtoZ {\alpha'} {\punitinXfromYtoZ {\cat C} {\alpha'}{\alpha}} {\negPresheafAppPtoX \pi {\alpha'}}$ is isomorphic to $\negPresheafAppPtoX \pi \alpha$
  \item (Co-Yoneda) The profunctor $\tensorexistsXwithYandZ {\alpha'}{\punitinXfromYtoZ{}{\alpha}{\alpha'}} {\negPresheafAppPtoX \pi \alpha}$ is isomorphic to $\negPresheafAppPtoX \pi \alpha$
  \end{enumerate}
\end{lemma}
The proofs both follow from the unit elimination rule, which is
essential the Yoneda lemma---the two cases of showing (1) is an
isomorphism are precisely the $\beta$ and $\eta$ rules for the unit.

Next, we have the ``Fubini'' theorems, which are analogous to simple
theorems relating tensor and hom types in ordered logic, and whose proofs are 
\begin{lemma}[{Fubini}]
  \label{lem:fubini-short}
  The following isomorphisms hold when the corresponding profunctors
  are well typed.
  \begin{enumerate}
  \item $\tensorexistsXwithYandZ {\beta} {\harrapp P \alpha \beta} {(\tensorexistsXwithYandZ \gamma {\harrapp Q \beta \gamma} {\harrapp R \gamma \delta})} \cong \tensorexistsXwithYandZ {\gamma} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp R \gamma \delta}$
  \item $\homrallXYtoZ {\gamma} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp S \alpha \gamma} \cong \homrallXYtoZ \beta {\harrapp P \alpha \beta} {\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {\harrapp S \alpha \gamma}}$
  \item $\homlallXYtoZ {\alpha} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp S \alpha \gamma} \cong \homlallXYtoZ \beta {\harrapp Q \beta \gamma} {\homlallXYtoZ \alpha {\harrapp P \alpha \beta} {\harrapp S \alpha \gamma}}$
  \item $\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {(\homlallXYtoZ \alpha {\harrapp P \alpha \beta} {\harrapp S \alpha \gamma})} \cong \homlallXYtoZ \alpha {\harrapp P \alpha \beta} {(\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {\harrapp S \alpha \gamma})}$
  \item $\pendallXdotY \alpha \homrallXYtoZ \beta P {P'} \cong \pendallXdotY \beta \homlallXYtoZ \alpha P {P'}$
  \end{enumerate}  
\end{lemma}
\begin{proof}
  Straightforward, for instance the forward direction of (1) is given
  by $\lambdaunary \alpha {x} \delta {\tensorelimWkontZ x
    {p.\beta.y. \tensorelimWkontZ y
      {q.\gamma.r. \tensorintroatXwithYandZ {\gamma}
        {\tensorintroatXwithYandZ \beta p q} {r}}}}$
\end{proof}

Next, we can prove that two definitions of an adjunction are equivalent:
\begin{lemma} \label{lem:adjunction}
  For $R : \varr {\cat D}{\cat C}$ and $L : \varr {\cat
    C}{\cat D}$, the following are in bijection:
  \begin{enumerate}
  \item An isomorphism of profunctors $(\punitinXfromYtoZ {\cat D} {L \alpha}{\beta}) \cong (\punitinXfromYtoZ {\cat C} \alpha {R \beta})$
  \item A unit $\eta : \pendallXdotY \alpha {\punitinXfromYtoZ {\cat C} \alpha
    {R(L\alpha)}}$ and co-unit $\varepsilon: \pendallXdotY \beta
    {\punitinXfromYtoZ {\cat D} {L(R(\beta))}{\beta}}$ satisfying triangle
    identities.
  \end{enumerate}
\end{lemma}
\begin{proof}
  Given the forward homomorphism $\text{lr}$, we can construct $\eta =
  \pendlambdaXdotY \alpha \appunary {\text{lr}} \alpha {\punitrefl
    \alpha} {L \alpha}$ and given the unit we can reconstruct the
  forward homomorphism using
  $\text{comp}$ and $\text{fctor}$ as defined in
  Construction\ref{construction:synthetic-composition} as
  $\appbinary {\text{comp}} \alpha
  {\pendappXtoY \eta \alpha} {R(L\alpha)} {(\appunary
    {\text{fctor}(R)}{L \alpha} {f} {\beta})} {R \beta}$.
\end{proof}

\noindent We can define weighted limits, which include ordinary limits and
Kan extensions.
\begin{definition}
  For a functor $D : \varr {\cat J}{\cat C}$ and a profunctor $W :
  \harr{\cat K}{\cat J}$, the limit of $D$ weighted by $W$ is (if it
  exists) a functor $\weightedLimitDW D W : \varr{\cat K}{\cat C}$
  with an isomorphism $\punitinXfromYtoZ {\cat C} {\alpha} {(\weightedLimitDW D W) k} \cong \homrallXYtoZ j {W k j} {(\punitinXfromYtoZ {\cat C} \alpha {D j})}$
\end{definition}
This generalizes the usual definition that a morphism into a limit is
a cone over the diagram $(\punitinXfromYtoZ {\cat C} \alpha {D j})$ to
be parameterized by a weight $W k j$.
Then we can prove the well-known theorem that right adjoints preserve (weighted) limits:
\begin{theorem}
  If $\weightedLimitDW D W$ exists and is a limit and $R : \varr{\cat
    C}{\cat C'}$ has a left adjoint $L$, then $\lambda
  \kappa. R((\weightedLimitDW D W) \kappa)$ is the limit of $\lambda
  j. R(D j)$ weighted by $W$.
\end{theorem}
\begin{proof}
\[
    \punitinXfromYtoZ {} {\gamma} {R ((\weightedLimitDW D W) \kappa)}
    \cong \punitinXfromYtoZ {}{L \gamma} {(\weightedLimitDW D W) \kappa}
    \cong \homrallXYtoZ {j}{W k j} {\punitinXfromYtoZ {}{L \gamma}{D j}}
    \cong \homrallXYtoZ {j}{W k j} {\punitinXfromYtoZ {}{\gamma}{R(D j)}}\\
\]
This is a high level proof in terms of isomorphisms that may be written
in VETT. The first two steps are the instantiation of assumptions
(adjointness, weighted limits). The last step uses the fact that a
natural isomorphisms lift to natural isomorphism of homs of profunctors.
The construction of this isomorphism illustrates how naturality need not
be proved explicitly in \vett{}.  For any $\phi: \homunary \alpha {R'
  \alpha \beta} \beta {R \alpha \beta}$ and $\psi : \homunary \gamma {S
  \gamma \beta} \beta {S' \gamma \beta}$ we can construct a natural
transformation $\phi \triangleright \psi : \hombinary \gamma
{(\homrallXYtoZ \beta {R \alpha \beta}{S \gamma \beta})} {\alpha}
{R'\alpha\beta} \beta {S'\gamma\beta}$ as \\ $\lambdabinary {\gamma} {f}
{\alpha} r \beta {\appunary \psi \gamma {(\homrappXtoYatZ f {(\appunary
      \phi \alpha r \beta)} \beta)} \beta}$. Furthermore if $\phi$ and
$\psi$ have inverses, then $\phi^{-1} \triangleright \psi^{-1}$ is the
inverse of $\phi \triangleright \psi$.
\end{proof}

%% \subsection{Ordered Theories}

%% Just as we can define theories in first-order logic or higher-order
%% logic by assuming base sorts, function and relation symbols and
%% axioms, we can define ordered, or categorical theories in \ohol{}
%% easily by using the two-level type theory structure.
%% %
%% We can define an \emph{ordered theory} to be any context $\Gamma$ and
%% a translation of theories to be a substitution.
%% %
%% Then we can define theories for cartesian categories, monoidal
%% categories, bicartesian categories, strong monads, (strong)
%% adjunctions.
%% %
%% However the utility for applications to programming language semantics
%% is limited due to the lack of opposite categories.

%% \subsection{Duality Principle}
%% One common source of category theoretic arguments is the duality
%% principle: since the opposite of any category is also a category, any
%% statement that quantifies over all categories is equally true of their
%% opposites. Furthermore in a formal language of categories, any
%% statement can be dualized to a statement where domains and codomains
%% are swapped and composition is flipped.
%% %
%% A similar duality principle holds in SCT.
%% %
%% The basic idea is to reverse the orientation of all \emph{set}
%% expressions by swapping which variable is covariant and which is
%% contravariant.
%% %
%% This has the effect of reversing the order of the context $\Phi$.
%% %
%% We can define this as a translation $\cdot^* : SCT \to SCT$ defined on
%% syntactic forms of SCT in Figure~\ref{fig:duality}.
%% \begin{figure}
%%     \begin{align*}
%%       (\harr {\cat C} {\cat D})^* &= \harr {\cat D^*} {\cat C^*}\\
%%       (\alpha:\cat C)^* &= \alpha: \cat C^*\\
%%       (\alpha:\cat C; \beta:\cat D)^* &= \beta:\cat D^*; \alpha:\cat C^*\\
%%       (\Phi,x:R,\Psi)^* &= \Psi^*,x:R^*, \Phi^*\\
%%       (\homrallXYtoZ \alpha P Q)^* &= \homlallXYtoZ \alpha {P^*} {Q^*}\\
%%       (\homlallXYtoZ \alpha P Q)^* &= \homrallXYtoZ \alpha {P^*} {Q^*}\\
%%       (\homrlambdaXatYdotZ x \alpha s)^* &= \homllambdaXatYdotZ x \alpha s^*\\
%%       (\homrappXtoYatZ s t a)^* &= \homlappXtoYatZ {s^*} {t^*} {a^*}\\
%%       (\tensorexistsXwithYandZ \beta P Q)^* &=
%%       \tensorexistsXwithYandZ \beta {Q^*}{P^*}\\
%%       (\tensorintroatXwithYandZ b s t)^* &= \tensorintroatXwithYandZ {b^*} {t^*} {s^*}\\
%%       (\punitinXfromYtoZ {\cat C} {a_1}{a_2})^* &= \punitinXfromYtoZ {\cat C^*} {a_2^*}{a_1^*}
%%     \end{align*}
%%   \caption{Duality Involution}
%%   \label{fig:duality}
%% \end{figure}

%% MOVE TO APPENDIX examples section?

%% \subsection{Extensionality Axioms}

%% Finally, we discuss some non-theorems that would be desirable to add
%% as axioms to the theory of \ohol{}.
%% %
%% Chief among these are principles about the hom type $\punitinXfromYtoZ
%% {\cat C} \alpha \beta$ when $\cat C$ is a connective.
%% %
%% Since the hom type is defined as a kind of unit type, rather than
%% defined inductively, we are not guaranteed that the hom type for the
%% product category $\cat C \times \cat D$ or the presheaf categories are
%% what we expect.
%% %
%% For the product type, we expect there should be an isomorphism
%% $\punitinXfromYtoZ {\cat C \times \cat D} \alpha \beta \cong
%% (\punitinXfromYtoZ {\cat C} {\pi_1 \alpha} {\pi_1 \beta}) \times
%% (\punitinXfromYtoZ {\cat D} {\pi_2 \alpha} {\pi_2 \beta})$ saying an
%% arrow in a product category is a pair of arrows.
%% %
%% Similarly, the hom type in the presheaf category should be given by
%% the end formula $\punitinXfromYtoZ {\negPresheaf {\cat C}} \alpha
%% \beta \cong \homlallXYtoZ {\gamma}{\negPresheafApp \alpha
%%   \gamma}{\negPresheafApp \beta \gamma}$. This would allow us to
%% relate the Yoneda Lemma \ref{lem:yoneda} to the morphisms of
%% presheaves, and prove that the Yoneda embedding is fully faithful.
%% %
%% We call these extensionality principles because they are analogous to
%% principles such as function extensionality but for the directed hom
%% type rather than equality.

%% The presheaf extensionality principle is independent from the existing
%% axioms of \ohol{}: it is true in the ordinary category theoretic
%% model, but it is false in the set theoretic model. That is, in the set
%% theoretic model, the presheaf category is simply the powerset, the hom
%% type is \emph{equality} and the function profunctor is interpreted as
%% a universally quantified \emph{implication}, but equality in the
%% powerset should be \emph{bi-implication}, so the theorem is false. We
%% expect the product extensionality is independent as well, but a
%% counter-model would likely be quite exotic as we expect it to be
%% provable in a system with functor categories, in analogy with the
%% proof for the identity type in MLTT.
%% %
%% Note that these axioms can easily be added as assumptions in the
%% dependently typed context, though this will break the constructive
%% character of the system. We expect techniques from type theory might
%% be applied to incorporate these as computationally meaningful
%% principles rather than assumed as axioms \cite{obs-tt,xtt,cubical-type-theory}.

\section{Semantics}
\label{sec:semantics}

Next, we develop the basics of the model theory for \ohol{}.
%
First, we demonstrate that a hyperdoctrine of virtual equipments
categories with split restrictions provides a sound and complete
notion of categorical model.
%
Then we instantiate this general notion of model to show that the
\ohol{} can be interpreted in ordinary category theory as well as
enriched and internal category theory, and more trivially, in terms of
sets and relations or preordered sets and ordered relations.

%% \subsection{Notion of Model}

First, we can model the judgmental structure of the unary type theory
and predicate logic in certain\emph{virtual equipments}
\cite{leinster,crutwell-shulman}, i.e., virtual double categories with
restrictions. We briefly recount the structure present in a virtual
double category, but see \citet{crutwell-shulman} for a precise
definition of the composition rules for 2-cells and functor of virtual
double categories.
%
Our notion here differs from \citet{crutwell-shulman} in several ways
to more closely match our judgmental structure: (1) we require that
restrictions are given as coherent structure rather than mere
existence (2) we include a notion of ``small'' object and (3) we don't
yet require the existence of unit horizontal arrows, as these are
modeled by a connective rather than judgmental structure.

\begin{definition}[Virtual Equipment]
  A virtual equipment $\mathcal V$ consists of
  \begin{enumerate}
  \item A category $V_o$ of ``objects and vertical arrows''
  \item A chosen subset of the objects $V_s \subseteq V_o$ of ``small objects''
  \item A set ${\mathcal V}_h$ of ``horizontal arrows'' with source
    and target functions $s,t : {\mathcal V}_h \to {\mathcal V_o}^2$
  \item Sets of 2-cells of the following form, 
    with appropriate ``multi-categorical'' notions of identity and
    composition:
\[\begin{tikzcd}% https://q.uiver.app/?q=WzAsNixbMCwwLCJDXzAiXSxbMCwyLCJEXzAiXSxbMiwwLCJDX3tufSJdLFsxLDAsIlxcY2RvdHMiXSxbMiwyLCJEXzEiXSxbMSwxLCJcXHBoaSJdLFszLDIsIlJfbiIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9fX1dLFswLDEsIkYiLDJdLFsyLDQsIkciXSxbMSw0LCJTIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn19fV0sWzAsMywiUl8wIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn19fV1d
	{C_0} & \cdots & {C_{n}} \\
	& \phi \\
	{D_0} && {D_1}
	\arrow["{R_n}", "\shortmid"{marking}, from=1-2, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow["g", from=1-3, to=3-3]
	\arrow["S"', "\shortmid"{marking}, from=3-1, to=3-3]
	\arrow["{R_0}", "\shortmid"{marking}, from=1-1, to=1-2]
\end{tikzcd}\]
    We say that the 2-cell $\phi$ has $S$ as codomain, the sequence
    $R_0 \ldots R_n$ as domain and call $f$ and $g$ the left and right
    ``frames'', or that $\phi$ is framed by $f$ and $g$.
  \end{enumerate}
  We say a virtual double category has \emph{split restrictions} when
  for any horizontal arrow $R : C \pto D$ and vertical arrows $f : C'
  \to C$ and $g : D' \to D$ there is a chosen horizontal arrow $R(f,g)
  : C' \pto D'$ with a cartesian 2-cell to $R$ framed by $f,g$ and
  these chosen cartesian lifts are functorial in $f,g$.
  
  A functor of virtual equipments is a functor of the virtual double
  categories that additionally preserves the restrictions and
  smallness of objects.
\end{definition}

In the presence of restrictions, every 2-cell can be represented as a
``globular'' 2-cell where the left and right frame are identities. For
example the 2-cell $\phi$ above can be represented as one with the
same domain but whose codomain is $S(f,g)$. This property is crucial
for the completeness of our semantics as we only include a syntax for these globular terms 
%
Each component of this definition has a direct correspondence to a
syntactic structure in \ohol{}. The objects of $\mathcal V_o$ models
the category judgment and the morphisms model the functor
judgment. The set $\mathcal V_h$ models the profunctor judgment. A
composable string $R_0 \cdots R_n$ models the profunctor contexts. The
2-cells correspond to the natural transformation judgment where we
have taken the restriction $S(F,G)$ of the codomain.

To model the dependent type theory and fact that the categorical
judgments are all typed under a context $\Gamma$ with an action of
substitution, we use a variation on Lawvere's notion of
\emph{hyperdoctrine} for modeling predicate logic:
\begin{definition}[Hyperdoctrine of Virtual Equipments]
  A hyperdoctrine of virtual equipments is a pair of a category with
  families $\mathcal C$ and a functor $V^{(-)} : \mathcal C^o \to
  \text{vEq}$ to the category of virtual equipments and functors.
\end{definition}
Categories with families $\mathcal C$ model dependent type theory
\citep{cwf} and for each semantic context $\Gamma$, $V^\Gamma$ models
the VETT judgments in context $\Gamma$, with the functoriality
modeling the fact that all of these judgments admit a well-behaved
action of substitution.

An HVE is then precisely the structure corresponding to the
\emph{judgments} and actions of substitution in VETT.
\begin{construction}[Syntactic Model]
  \label{cons:syn-model}
  The syntax of VETT with any choice of which subset of connectives
  are included presents an HVE.
\end{construction}
\begin{proof}
  Straightforward, defining the category of families using the dependent
  type structure and the virtual equipment structure having
  ($\alpha$-equivalence classes of) syntactic categories as objects,
  functors/sets as vertical/horizontal arrows and interpreting
  compositions/restrictions as substitutions.  The biggest gap is in the
  definition of the 2-cells.  A 2-cell from\\ $(\alpha_1:\cat
  C_1\mathord{;}\alpha_2:\cat C_2\vdash R_1),(\alpha_2:\cat
  C_2;\alpha_3:\cat C_3 \vdash R_2),\ldots$ to $(\beta_1:\cat
  D_1;\beta_2\vdash S)$ with frames $\alpha_1:\cat C_1\vdash b_1 : \cat
  D_1$ and $\alpha_n:\cat C_n\vdash b_2 : \cat D_2$ given by a term
  $x_1:R_1,x_2:R_2\ldots \vdash s :
  S[b_1/\beta_1;b_2/\beta_2]$. Composition is defined by substitution.
\end{proof}

Then the \emph{connectives} of VETT each precisely correspond to a
universal construction of structures in an HVE. The
$\Pi,\Sigma,\text{Id}$ types correspond to their standard semantics in
a CwF, products of categories interpreted as products in the vertical
category, and products of sets as products in the category of
pro-arrows and 2-cells. The units, tensor and covariant and
contravariant homs are modeled by the universal properties of the same
names, as described for instance in \citet{shulmanFrBicats}. The graph
of a profunctor is modeled by \emph{tabulators}
\citet{grandis-pare}. Finally, the covariant and contravariant
presheaf categories can be described as a weakening of the definition
of a Yoneda equipment from \citet{yosegi-boxes} to virtual double
categories. More detailed descriptions of these universal properties
are included in the appendix.
%
Then we can package up the soundness and completeness of this notion
of categorical model in the following modular initiality theorem.

\begin{theorem}[Initiality]
  The syntax of VETT with almost any choice of connectives presents an
  HVE that is initial in the category of HVEs with the chosen
  instances of the universal properties and functors that preserve
  such chosen instances. The only exception is that if units are
  included, then contravariant and covariant hom sets must be included
  as well.
\end{theorem}
\begin{proof}
  It is straightforward to extend the construction
  \ref{cons:syn-model} for any connective modularly, with the
  exception that the unit relies on the presence of hom sets in order
  to satisfy the ``distributivity'' requirement that its elimination
  can occur in any context. Then we can construct the unique morphism
  to any HVE by straightforward induction on syntax.
\end{proof}

%% \subsection{Examples of Models}

Now that we have a category-theoretic notion of model, we give some
model construction theorems that can be used to justify our intuitive
notion of semantics in (enriched, internal, indexed) category theory.
%
First, we can extend any virtual equipment to an HVE as follows:
\begin{construction}
  Given a virtual equipment $\mathcal V$, we
  can construct a functor $\mathcal V^{-}: \Set \to \text{vDbl}_r$ by
  defining the objects of $\mathcal V^\Gamma$ to be functions $\Gamma
  \to \mathcal V_o$, and similarly for morphisms and 2-cells with all
  operations given pointwise. 
\end{construction}
% NOTE: this should be some kind of general theorem right?
% Sketch:
% 1. VDCrs are a finite limit theory
% 2. A hyperdoctrine L : C -> VDCr is the same as a VDCr in Pr(C)
% 3. The Yoneda embedding preserves finite limits 

%% Semantic Qs:
%
%% (1) The virtual equipment of locally small categories is a model of everything.
%% (2) Are Shulman's enriched indexed categories strict enough?

Then to define a model of VETT with a collection of connectives it is
sufficient to construct a virtual equipment with the corresponding
universal properties.
%
\begin{construction}
  Fix a cardinal $\kappa$. The virtual equipment $\Cat_{\kappa}$ is
  defined to have as objects locally $\kappa$-small categories, small
  objects as $\kappa$-small categories, vertical morphisms as functors,
  horizontal arrows as functors $\cat C^o \times \cat D \to \kappa Set$ and
  2-cells as morphisms of profunctors. Restriction of profunctors is
  given by composition, which is strictly associative and unital.
  $\Cat_{U}$ has objects satisfying the universal properties of all
  connectives in VETT.
\end{construction}

More generally, categories internal to, enriched in and/or indexed by
sufficiently nice categories define a virtual equipment that model the
connectives of VETT. We highlight one example from the literature that
is highly general: Shulman's enriched indexed categories. Shulman's
construction defines a virtual double category of large and small
$\mathcal V$-categories for any pseudofunctor $\mathcal V : S^o \to
\MonCat$ where $S$ is a category with finite products. He gives
examples that show that this subsumes ordinary internal, enriched and
indexed categories for suitable choices of $\mathcal V$, as well as
more general categories that can be thought of as both indexed and
enriched.
%
This is slightly weaker then what we require: to have
\emph{split} restrictions, we need that $\mathcal V$ be a
\emph{strict} functor, not merely a pseudo-functor.
%
This is analogous to the situation for dependent type theory where
substitution is strictly associative but in models is typically
modeled by pullback which is only associative up to unique
isomorphism.
%% In fact, one of the main examples is only a
%% pseudo-functor for precisely this reason that the action on morphisms
%% is given by pullback.
%
We leave strictification theorems to future work.  

\begin{construction}[(\citet{shulman-enriched-indexed})]
  Given any functor $\mathcal V : S^o \to \SymMonCat$ such that $S$
  and $\mathcal V$ have sufficiently well-behaved (indexed)
  $\kappa$-products, then there is a virtual equipment $\mathcal
  V-\textrm{Cat}$ whose objects are locally $\kappa$-small $\mathcal
  V$-categories, small objects are $\kappa$-small $\mathcal
  V$-categories etc. This virtual equipment has objects satisfying all
  of the universal properties needed for a model of VETT.
\end{construction}

\section{Related and Future Work}
\label{sec:discussion}

We now comapre \vett{} with other calculi for formal category theory.  

Riehl and Verity~\cite{rvXXelements} use a formal language of virtual
equipments to prove results valid for $\infty$-categories without
concrete manipulation of model categories. They formalize this language
as a theory in Makkai's framework of first-order logic with dependent
sorts (FOLDS).  While this previous work has the same models as \vett{},
we believe that the syntax we propose in this paper formalizes informal
arguments more directly, as shown in Section~\ref{sec:examples}.  This
is because FOLDS approach approach is entirely relational, whereas we
formalize concepts like restriction of a profunctor or composition of
natural transformations as functional operations (substitution).  In
particular, this means that our calculus requires only vertically
degenerate squares (elements/natural transformations) as a
``user-facing'' notion, with general squares occuring only in the
admissible substitution operations.

%% The main difference is that their theory is built on top of
%% first-order logic, whereas ours is built on a custom-made variant of
%% higher-order logic over a (unary) simple type theory. For this reason,
%% statements in their theory are quite complex as they have to be encoded
%% into first-order logic, whereas we argue our type-theoretic approach
%% %

The coend calculus~\citet{coend-calculus} is an informal syntax for
manipulating profunctors involving ends and coends; an extension of
\vett{} to treat profunctors of many variables of different variances
may provide a formal treatment of it.

\citet{djm-string-diagrams} provides a string diagram calculus for
double categories and pro-arrow equipments, generalizing string
diagrams for monoidal categories \citet{joyal?}. These are an
alternative approach to type theoretic calculi, with the string
diagrams typically making tensor products simpler to work with, while
a type theoretic calculus like SCT makes the closed structure
$\homrallXYtoZ \alpha P Q$ simpler to work with by using bound
variables.

One alternative to proarrow equipments is to axiomatize the bicategory
of categories, profunctors and natural transformations rather than the
virtual double category of categories, functors, profunctors and natural
transformations. An abstract structure along these lines is a
\emph{Cartesian
  bicategory}~\citet{carboni-walters,carboni-walters-someonelese}.  (In
a terminological collision, \citet{fioresaville} give a syntax for a a
bicategory with products/finite limits, but this is a different notion.)
\citet{jonasfreycartesianbicategories} describe some preliminary work on
a proof system for Cartesian bicateogires.  This calculus is more
general than \vett{} in that their profunctors may have 0, 1 or more
covariant or contravariant variables, but they do not have a term syntax
for the natural transformations/elements, and Cartesian bicategories do
not have functors and restriction of profunctors by
functors. Semantically, Cartesian bicategories are less general
than virtual equipments because in general the set of functors between
two categories can only be recovered from the set of profunctors if the
codomain category is Cauchy complete, in which case functors are
equivalent to adjoint pairs of profunctors.

Our work in this paper fits broadly into a line of work on
\emph{directed dependent type theories}, a type theory where the
identity type is interpreted as morphisms in a (possibly
$\infty$-)category.  In directed type theories based on a bisimplicial
model~\cite{riehlshulman17directed,buchholtzweinberger21fibered,weinberger22thesis,WeaverLicata20},
morphism types are defined using an interval object, like in cubical
type
theory~\cite{bch18,cchm18cubical,angiuli+18cartesian-csl,abcfhl17cartesian},
and universal properties like ``morphism induction'' are an internally
definable property of certain types.  Other type
theories~\cite{north18,ahrens+22semantics-2dtt} define morphism types via an induction
principle, corresponding to the lifting properties of certain kinds of
fibrations of categories.  While these previous works can express some
constructions on $\Cat$ that are not expressible in \vett{}, because
\vett{} is more restricted, \vett{} contrariwise has more models, for
instance categories enriched in non-cartesian monoidal categories, so
the theorems that are provable in \vett{} apply in more settings.

%% Directed dependent type theories
%% should generalize \ohol{} in the same way that dependent type theory
%% generalizes higher order logic: internally there should be a type that
%% models the category of sets, and terms of this type should model the
%% profunctors of \ohol{}.  As a foundation for a domain-specific proof
%% assistant for category theory, \ohol{} may provide a foundation for a
%% proof assistant in the style of Isabelle/HOL \cite{isabelle-hol},
%% whereas directed type theory would provide a foundation for a proof
%% assistant in the style of Agda or Coq \cite{agda,coq}.

Finally, some variations on double categories have been used to model
the structure of certain program logics. \citet{newlicata20} present a
logic for \emph{vertically thin} pro-arrow equipments, i.e., pro-arrow
equipments where the functor and natural transformation judgments are
posetal. This calculus is quite different from ours in that the
horizontal morphisms are terms of a programming language, and so they
are not presented as relations with co-variant and contravariant
variables, and the equipment structure is modeled by explicit coercions
rather than by syntactic substitution of vertical arrows in horizontal
arrows. Another similar calculus is System P \citep{systemP} which is an
internal language of \emph{reflexive graph categories}, which are like
double categories without horizontal composition.

%% DRL note: I would compress the rest of this to a couple of sentences
%% as the first thing to remove for space.  

In future work, \vett{} could incorporate functor categories by
generalizing the unary type theory of functors to functors of many
variables, in which case ordinary $\lambda$ calculus can be used to
define functor categories as function types. Similarly, ideas from modal
type theory/graded linear logic could be used for defining opposite
categories \cite{mike-contravariance-enrichment,semiring-stuf??}. 

%% while many constructions in category theory can be formalized in
%% virtual equipments, and therefore \vett{}, others require more
%% structure. Future extensions to

%% While we have demonstrated that some common constructions in category
%% theory can be expressed using the simple combination of homs, tensors
%% and units, there are several that are out of reach for SCT due to its
%% restrictive judgmental structure. These require extensions to the
%% judgmental structure that would move beyond virtual equipments.

%% First, while we can add products to the calculus, adding in a
%% \emph{functor category} ${\cat C}^{\cat D}$ would necessitate adding a
%% syntax for functors of multiple arguments, to allow for the lambda rule:
%% \[ \inferrule {\alpha:\cat C, \beta:\cat D \vdash e : \cat E} {\alpha:\cat C \vdash \lambda \beta:\cat D. e : \cat E} \]
%% This would then require also some extension to profunctors for
%% allowing 0 or more covariant/contravariant dependencies as well.
%% %
%% Semantically, this would correspond to generalizing from virtual
%% equipments to some kind of (possibly cartesian) \emph{monoidal closed}
%% virtual equipments.

%% In addition, we could consider extending our semantics with a notion
%% of \emph{opposite category}, with the property that a covariant
%% dependence of a profunctor on a variable in a category should be
%% equivalent to a contravariant dependence on a variable in the opposite
%% category.
%% %
%% This could possibly be done by introducing a modal distinction
%% $\alpha:^{+}\cat C$ for covariant dependence and $\alpha:^{-}\cat C$
%% for contravariant dependence, with the opposite category being a
%% modality that internalizes flipping the variance as a type
%% constructor.
%% %
%% With these two extensions, possibly, the category contexts for
%% functors and profunctors could be unified as one notion of a sequence
%% of object variables with variances.
%% %
%% With this unification, it would then be simpler to incorporate a third
%% extension: a universe object, corresponding to an object
%% $\textrm{Set}$, which would allow us to internalize the profunctor
%% judgment in the functor judgment, modeling that in classical category
%% theory, profunctors are the same as certain functors to the category
%% of Sets.
%% %
%% While all of these extensions seem plausible, they all move away to
%% the simple ordered type theory structure that allowed us to define
%% units, tensor and hom profunctors so easily. It is unclear how to
%% define these types in this extended structure. As a simple example, if
%% profunctors have many variables of mixed variance, rather than exactly
%% one of each variance, it is unclear what the appropriate
%% generalization of the transformation context $\Phi$ should be.

%% An orthogonal extension to these would be to consider adding a
%% \emph{discretization} modality $\Delta\cat C$ that gives the discrete
%% category on the underlying set of objects of $\cat C$. This would give
%% us the ability to formalize concepts like ``function on objects'' or
%% ``unnatural transformation'' without the need to define internal
%% categories. This could be modeled by adding a modal distinction
%% $\alpha:^{\#}\cat C$ for ``crisp'' dependence on an object of $\cat
%% C$, i.e., dependence merely on the object of $\cat C$ with no
%% functoriality/naturality conditions. This would then be internalized
%% by the discretization modality.

%% A third approach would be to extend the calculus to model general
%% monoidal closed structures and more generally multicategories, which
%% provides semantics of modal substructural type theories.
%% %
%% This can be modeled by extending the ``universe'' $\Set$ to be a
%% monoidal closed category, which induces a monoidal closed structure on
%% profunctors by the Day convolution product \cite{...}.
%% %
%% Similar developments along these lines have already been done for
%% coend calculus \citep{coend-calculus} and in formalization of
%% substructural type theories \citep{atkey-woods}.

%% A recent development in the formalization of substructural type
%% theories is to use monoidal connectives at the meta-level when
%% defining multiplicative connectives\cite{woodsatkeyesop2022}. This
%% suggest one approach to extending the theory to support the
%% formalization of multiplicative universal properties would be, in
%% adherence to the microcosm principle, to add linear judgments and
%% multiplicative connectives to the metalevel.

%% \paragraph{As a tool for Formal Type Theory}

%% While we can model ``unary'' type theories using profunctors, to model
%% theories like simple intuitionistic, linear or bunched type theories
%% we need a way to talk about ``profunctors of many arguments''. This
%% can be accomplished using \emph{multicategory} theory, which models
%% the structure of the context with its structural rules as a monad of
%% ``contexts and substitutions''. A suitable notion of monad on a
%% virtual double category has been developed and was in fact the
%% original motivation for the concept of a virtual double
%% category. However while an abstract monad of contexts $T$ is enough to
%% define what a $T$-multicategory internal to a virtual equipment is, it
%% does not appear possible to define the multiplicative connectives as a
%% universal property, i.e., to define when the multicategory is
%% \emph{representable}.

\textbf{Acknowledgements.}  This material is based on research sponsored
by the National Science Foundation under agreement number CCF-1909517
and the United States Air Force Research Laboratory under agreement
number FA9550-21-0009 (Tristan Nguyen, program manager).
%% The U.S. Government is authorized to reproduce and distribute
%% reprints for Governmental purposes notwithstanding any copyright
%% notation thereon.  The views and conclusions contained herein are
%% those of the authors and should not be interpreted as necessarily
%% representing the official policies or endorsements, either expressed
%% or implied, of the National Science Foundation, the United States Air
%% Force Research Laboratory, or the U.S. Government.
The authors would like to thank David Jaz Myers, Emily Riehl, Mike
Shulman, Dominic Verity for helpful feedback on this work.

%% %%
%% %% Bibliography
%% %%

%% %% Please use bibtex, 

\bibliographystyle{splncs04}
\bibliography{cats}

\appendix

\section{\vett{} Syntactic Metatheory}
\label{sec:appendix:syntax}

\subsection{Substitution}

In Figure~\ref{fig:subst} we give full definitions for well-formedness
of contexts and substitutions.

\begin{figure}
  \begin{mathpar}
    \begin{array}{rccl}
      \textrm{Term Substitution} & \gamma, \delta & ::= & \cdot \pipe \gamma, M/X\\
      \textrm{Object Substitution} & \xi, \zeta & ::= & a/\alpha \pipe a/\alpha;b/\beta\\
      \textrm{Transformation Substitution} & \phi, \psi & ::= & a/\alpha \pipe \phi,s/x, \psi      
    \end{array}

      \inferrule*[right=TyCtxForm]
        {}
        {\Gamma \isadtctx}

    \inferrule*[right=SetCtxForm]
    {\Gamma \isadtctx}
    {\Gamma \vdash \Xi \boundary}

    \inferrule*[right=TransCtxForm]
    {\Gamma \isadtctx}
     {\Gamma \vdash \Phi \isavectx}
    \inferrule
    {\Delta \isadtctx \and \Gamma \isadtctx}
    {\gamma : \Delta \to \Gamma}
    
    \inferrule*[right=Boundary Map formation]
    {\Gamma \vdash Z \boundary \and \Gamma \vdash \Xi \boundary}
    {\Gamma \vdash \xi : Z \to \Xi}

    \inferrule*[right=Cat Subst formation]
    {\Gamma \vdash \Psi \isavectx \and \Gamma \vdash \Phi \isavectx}
    {\Gamma \vdash \phi : \Psi \to \Phi}
  \end{mathpar}
  \begin{mathpar}
    \inferrule{}{\cdot \isadtctx}

    \inferrule
    {\Gamma \isadtctx \and \Gamma \vdash A \isaTy}
    {\Gamma , X : A \isadtctx}\\

    \inferrule
    {X : A \in \Gamma}
    {\Gamma \vdash X : A}

    \inferrule
    {}
    {\alpha: \cat C \vdash \alpha: \cat C}

    \inferrule
    {\Gamma \vdash \cat C : \isaCat}
    {\Gamma \vdash \alpha: \cat C \isavectx}

    \inferrule
    {\Gamma \vdash \Phi \isavectx\and
    \Gamma \pipe d^+\Phi; \beta:\cat D \vdash R \isaSet}
    {\Gamma \vdash \Phi, x:R, \beta:\cat D \isavectx}

    \inferrule
    {}
    {\Gamma \pipe \alpha:\cat C, x : R, \beta: \cat D \vdash x : R}

    % horizontal identity
    \inferrule
    {\Gamma\pipe \beta:\cat C \vdash a : \cat C}
    {\Gamma \pipe \beta:\cat C \vdash a/\alpha : (\alpha : \cat C)}

    \inferrule
    {\Psi = \Psi_1 \jnctx \Psi_2\and
      \Gamma\pipe\Psi_1 \vdash \phi : \Phi\and
      \Gamma \pipe \Psi_2 \vdash t : R[d^+\phi;b/\beta] \and
      \Gamma \vdash \phi_2 : \Psi_2 \to \Phi_2
      }
    {\Gamma\pipe\Psi \vdash \phi,t/x,b/\beta :: (\Phi,x:R,\beta:\cat D)}
  \end{mathpar}

  \caption{Substitution}
\end{figure}

\begin{figure}
  \begin{align*}
    \underline{\alpha:C} &= \alpha:C\\
    \underline{\Phi,x:R,\Psi} &= d^-\Phi; d^+{\Psi}
  \end{align*}
  \begin{align*}
    d^{\pm}(\alpha:\cat C) &= \alpha : \cat C\\
    d^{-}(\Phi,x:R,\Psi) &= d^-\Phi\\
    d^{+}(\Phi,x:R,\Psi) &= d^-\Psi
  \end{align*}
  \begin{align*}
    d^{\pm}(a/\alpha) &= a/\alpha\\
    d^{-}(\phi,t/x,\psi) &= d^-\phi\\
    d^{+}(\phi,t/x,\psi) &= d^+\psi\\
  \end{align*}
  
  \caption{Operations on Contexts}
  
\end{figure}


\begin{figure}
  \begin{mathpar}
    \inferrule
    {}
    {\cdot : \Gamma \to \cdot}

    \inferrule
    {\gamma : \Delta \to \Gamma \and \Delta \vdash M : A[\gamma]}
    {\gamma,M/X : \Delta \to \Gamma,X:A}
    
    \inferrule
    {\Gamma \vdash \Phi \isavectx \and
    \Gamma \vdash \Psi \isavectx \and
    d^+\Phi = d^- \Psi}
    {\Gamma \vdash \Phi \jnctx \Psi \isavectx}

    \inferrule
    {\Gamma \vdash \phi : \Phi' \to \Phi \and
     \Gamma \vdash \psi : \Psi' \to \Psi\and
     d^+\phi = d^- \psi}
    {\Gamma \vdash \phi \jnctx \psi : \Phi' \jnctx \Psi' \to \Phi \jnctx \Psi}

    \inferrule*[right=ObSubst]
    {\alpha : \cat C \vdash B : \cat D\and
    \beta : \cat D \vdash A : \cat E}
    {\alpha : \cat C \vdash A[B/\beta] : \cat E}\\

    \inferrule*[right=Everything Subst]{\gamma : \Delta \to \Gamma \and \Gamma J}{\Delta J}

    \inferrule{\Gamma \vdash \xi : Z \to \Xi\and \Gamma \pipe \Xi \vdash R \isaSet}{\Gamma \pipe Z \vdash R[\xi] \isaSet}

    \inferrule{\Gamma \vdash \phi : \Psi \to \Phi\and \Gamma \pipe \Phi \vdash M : R}{\Gamma \pipe \Psi \vdash M[\phi] : R[\underline \phi]}
  \end{mathpar}
  \begin{align*}
    (\Phi \jnctx \Psi) \jnctx \Sigma &= \Phi \jnctx (\Psi \jnctx \Sigma)\\
    \Phi \jnctx \alpha:C &= \Phi\\
    \alpha:C \jnctx \Psi &= \Psi\\\\
    d^\pm(A/\alpha) &= A/\alpha\\
    d^+(\phi_1,M/x,\phi_2) &= d^+ \phi_2\\
    d^-(\phi_1,M/x,\phi_2) &= d^- \phi_1\\\\
    \underline \cdot &= \cdot\\
    \underline {A/\alpha} &= A/\alpha\\
    \underline {\phi_1,M/x,\phi_2} &= d^-\phi_1;d^+\phi_2
  \end{align*}
  \caption{Admissible Rules}
\end{figure}


\cref{fig:contexts} details the typing rules for contexts and the
typing for variables and the admissible actions of substitution (the
definition of substitution is straightforward and found in the
appendix). the rules for term and object variables are as usual.
%
An object substitution into a single object context $\alpha:\cat C$
consists of an object $a : \cat C$ parameterized by an object of
another category.
%
An object substitution into a pair of co- and contra-variant variables
$\alpha:\cat C;\beta:\cat D$ is a pair of an object substituted for
$\alpha$ and one for $\beta$, each typed with respect to the
appropriate variable of an object context $\Xi$.
%
Note that this allows for $\Xi$ to consist of either two variables or
a single variable.
%
When
constructing a transformation context $\Phi, x : R, \Psi$, we need to
ensure that the contravariant dependence of $R$ matches the covariant
dependence of $\Phi$ and vice-versa for $\Psi$. We define this with
auxiliary metafunctions $d^+,d^-$ which extract the covariant and
contravariant object variable of a transformation context.
%
The rules for transformation variables and substitutions define the
use of variables to be \emph{linear} (each variables is used exactly
once) and \emph{ordered}, they occur in the term in the same order
that they appear in the context.
%
The rule for a transformation variables says a variable $x$ can only
be used when it is the sole variable in the context.
%
A transformation subsitution into an ``empty'' transformation context
$\alpha: \cat C$ is the same as an object substitution into
$\alpha:\cat C$.
%
The rule for constructing a transformation substitution into a
non-empty context $\Phi_1,x:R,\Phi_2$ says we can construct a
substitution by constructing substitutions $\phi_1,\phi_2$ for
$\Phi_1$ and $\Phi_2$ as well as a transformation $s$ into an
instantiation of $R$ where the input contexts come from splitting the
input context $\Psi$ into three components, and ensuring that the
instantiation of $R$ agrees with how $\phi_1,\phi_2$ instantiate the
variables. This uses two new metafunctions. First, $\Phi \jnctx \Psi$
is an operation for concatenating two contexts when $d^+(\Phi) =
d^-(\Psi)$. Next, we extend the boundary maps $d^\pm$ to substitutions
to extract their object substitutions.

\begin{figure}

  \caption{Basic Rules of Judgment Theory}
  \label{fig:contexts}
\end{figure}

Now that we have established a judgmental structure, in typical type
theoretic fashion, our type constructs follow naturally as
internalizing the judgments. Though the positive multiplicatives are
more familiar, we start by describing the negative multiplicatives,
since they are better behaved, and are useful to have already defined
when discussing the positives.

\subsection{Equational Theory}

Next we present the $\beta\eta$ rules that generate the equational
theory of the terms. In keeping with the extensional style of the type
theory, we do not present explicit transitivity, congruence, or
transport rules, but rather consider these as inherent to the notion
of equality. This can be formalized by modeling the terms of our type
theory as a quotient inductive inductive type
\cite{altenkirch-kaposi-popl17}.

\begin{figure}
  \begin{mathpar}
    % Type connectives: small and large cats, functors, profs, nat transformations, and if we want also Pi/Sigma/Id
    \inferrule*[right=SmallCat$\beta$]
    {~}
    {\unquoth {\quoth {\cat C}}  = \cat C}

    \inferrule*[right=SmallCat$\eta$]
    {\Gamma \vdash M : \smallCats}
    {\Gamma \vdash \quoth {\unquoth {M}}  = M : \smallCats}

    \inferrule*[right=Cat$\beta$]
    {~}
    {\unquoth {\quoth {\cat C}}  = \cat C}
    
    \inferrule*[right=Cat$\eta$]
    {\Gamma \vdash M : \Cats}
    {\Gamma \vdash \quoth {\unquoth {M}}  = M : \Cats}

    \\
    \inferrule*[right=Fctor$\beta$]
    {~}
    {(\lambda \alpha. b)\,a = b[a/\alpha]}

    \inferrule*[right=Fctor$\eta$]
    {\Gamma \vdash M : \varr {\cat C}{\cat D}}
    {\Gamma \vdash M = \lambda \alpha. M\,\alpha : \varr {\cat C}{\cat D}}

    \inferrule*[right=Prof$\beta$]
    {~}
    {(\lambda \alpha \beta. P)\,a\,b = P[a/\alpha;b/\beta]}

    \inferrule*[right=Prof$\eta$]
    {\Gamma \vdash M : \harr {\cat C}{\cat D}}
    {\Gamma \vdash M = \lambda \alpha\,\beta. M\,\alpha\,\beta : \harr {\cat C}{\cat D}}

    \inferrule*[right=NatElt$\beta$]
    {~}
    {(\pendlambdaXdotY \alpha s) a = s[a/\alpha]}

    \inferrule*[right=NatElt$\eta$]
    {\Gamma \vdash M : \pendallXdotY \alpha P}
    {\Gamma \vdash M = \pendlambdaXdotY \alpha {M\,a} : \pendallXdotY\alpha P}

    \\\\\\\\

    % Object connectives: 0,2-products, tabulators, +/- presheafs

    \inferrule*[right=NegPresheaf$\beta$]
    {~}
    {\negPresheafApp a (\lambda \alpha. R) = R[a/\alpha]}

    \inferrule*[right=NegPresheaf$\eta$]
    {\Gamma \pipe \beta:\cat D \vdash p : \negPresheaf {\cat C}}
    {p = \lambda \alpha. \negPresheafApp \alpha p}
    
    \inferrule*[right=NegPresheaf$\beta$]
    {~}
    {\posPresheafApp {(\lambda \beta. R)} b = R[b/\beta]}

    \inferrule*[right=PosPresheaf$\eta$]
    {\Gamma \pipe \alpha:\cat C \vdash p : \posPresheaf {\cat D}}
    {p = \lambda \beta. \posPresheafApp p \beta}
    
    \inferrule*[right=Graph$\beta-$]
    {~}
    {\pi_- (a_-,a_+,s) = a_-}

    \inferrule*[right=Graph$\beta+$]
    {~}
    {\pi_+ (a_-,a_+,s) = a_+}
    
    \inferrule*[right=Graph$\beta e$]
    {~}
    {\pi_e (a_-,a_+,s) = s}
    
    \inferrule*[right=Graph$\eta$]
    {\Gamma \pipe \alpha:\cat C \vdash b : \graphProf{\beta_-}{\beta_+} P}
    {\Gamma \pipe \alpha:\cat C \vdash b = (\pi_-b, \pi_+b, \pi_e b) : \graphProf{\beta_-}{\beta_+} P}
    
  \inferrule*[right=${1}\eta$]
  {\Gamma \pipe \alpha:\cat C \vdash a : 1}
  {\Gamma \pipe \alpha:\cat C \vdash a = () : 1}\\

  \inferrule*[right=${\times}\beta$]
  {~}
  {\pi_i(a_1,a_2) = a_i}

  \inferrule*[right=${\times}\eta$]
  {\Gamma \pipe \alpha:\cat C \vdash a : \cat D_1 \times \cat D_2}
  {\Gamma \pipe \alpha:\cat C \vdash a = (\pi_1a, \pi_2a) : \cat D_1 \times \cat D_2}
  \end{mathpar}
  \caption{$\beta\eta$ Equality for type and object connectives}
\end{figure}

\begin{figure}
  \begin{mathpar}
  % Set connectives: unit, tensor, +/- hom, 0,2-products
  \inferrule*[right=CovHom$\beta$]
    {~}
    {\homrappXtoYatZ {(\homrlambdaXatYdotZ x \alpha s)} t a = s[t/x,a/\alpha]}
    \inferrule*[right=CovHom$\eta$]
               {\Gamma\pipe\Phi \vdash s : \homrallXYtoZ \alpha R P}
               {\Gamma\pipe\Phi \vdash s = \homrlambdaXatYdotZ {x}{\alpha} \homrappXtoYatZ s x \alpha}

    \inferrule*[right=ConHom$\beta$]
                 {~}
                 {\homlappXtoYatZ {(\homllambdaXatYdotZ x \alpha t)} s a = t[a/\alpha,s/x]}
      \inferrule*[right=ConHom$\eta$]
      {\Gamma \pipe \Phi \vdash t : \homlallXYtoZ \alpha R P}
      {\Gamma \pipe \Phi \vdash t = \homllambdaXatYdotZ x \alpha \homlappXtoYatZ t x \alpha : \homlallXYtoZ \alpha R P}

    \inferrule*[right=Unit$\beta$]
    {~}
    {(\punitelimkontZatABC {\alpha. t} a {\punitrefl a} a) = t[a/\alpha]}
    \inferrule*[right=Unit$\eta$]
    {\Gamma\pipe\Phi \vdash s : \punitinXfromYtoZ {\cat C}{a}{b}}
    {\Gamma\pipe\Phi\vdash s = \punitelimkontZatABC {\alpha. \punitrefl \alpha} a s b: \punitinXfromYtoZ {\cat C}{a}{b}}
      
    \inferrule*[right=Tensor$\beta$]
    {~}
    {\tensorelimWkontZ {\tensorintroatXwithYandZ b s t} {x.\beta.y. r} = t[s/x;b/\beta;t/y]}
    \inferrule*[right=Tensor$\eta$]
    {\Gamma\pipe\Phi \vdash s : \tensorexistsXwithYandZ \beta P Q}
    {\Gamma\pipe\Phi\vdash s = \tensorelimWkontZ s {x.\beta.y. \tensorintroatXwithYandZ \beta x y}: \tensorexistsXwithYandZ \beta P Q}

  \inferrule*[right=$1\eta$]
  {\Phi \vdash s : 1}
  {\Phi \vdash s = () : 1}\\

  \inferrule*[right=${\times}\beta$]
  {~}
  {\pi_i(s_1,s_2) = s_i}

  \inferrule*[right=${\times}\eta$]
  {\Phi \vdash s : P \times Q}
  {\Phi \vdash s = (\pi_1 s, \pi_2 s) : P \times Q}
  \end{mathpar}
  \caption{$\beta\eta$ Equality for set connectives}
  \label{fig:betaeta-sets}
\end{figure}

\subsection{Identity Elimination}

As a final syntactic meta-theorem, we prove that the more general identity elimination principle
\[ \]
is admissible in the presence of let and right hom types.

TODO

\subsection{Negative Multiplicatives}

Since our calculus of natural transformations is ordered linear, we
have two distinct ``function sets'', internalizing concatenation on
the left or right of the context. The typing rules for these are given
in \cref{fig:cotensor}. The two types are the \emph{right hom}
$\homrallXYtoZ \alpha R P$ and the \emph{left hom} $\homlallXYtoZ
\alpha R P$. As a type, we can think of these both as a kind of
polymorphic function type in that in addition to parameterizing an
element of the set $P$ by an element of the set $R$, they also
quantify over an object $\alpha$ that is in $P$ and $R$.

These behave like function types, but their typing is somewhat
involved. First consider the right hom $\homrallXYtoZ \alpha R
P$. This acts very much like a polymorphic function type $\forall
\alpha. R \to P$, but with restrictions on the object
variables. First, the object variable $\alpha$ must occur covariantly
in $P$ and contravariantly in $R$. Next, the contravariant variable of
the type is the contravariant variable of $P$ and the covariant
variable of the type is the \emph{contravariant} variable of $R$, with
the flip in variance intuitively justified since $R$ occurs in the
negative position of the function. The placement of the $\forall
\alpha$ on the right side of the triangle is intended to be suggestive
of the fact that $\alpha$ occurs \emph{covariantly} in the input and
output sets $R,P$ and also that the corresponding $\lambda$ introduces
variables on the right.
%
As you would expect from a polymorphic function type, the introduction
form is a $\lambda$ that abstracts over both a transformation variable
and an object variable, which are concatenated on the right of the
context, aligning with the condition that the contravariant variable
of $R$ match the covariant variable of the original context.
%
The elimination rule is a combined instantiation and application form,
$\homrappXtoYatZ s t a$ which instantiates the object $\alpha$ to $a$
and passes an element $t : R[a/\alpha]$ as input, yielding an element
$P[a/\alpha]$ as output. Finally, we have the expected $\beta$ and
$\eta$ reasoning principles that we would have for a function type.

The left hom $\homlallXYtoZ \alpha R P$ dually abstracts over context
extension on the left. This time, the variable $\alpha$ occurs
\emph{contravariantly} in the input and output sets, and the covariant
dependence of the function set matches the covariant dependence of the
ouput set, while the contravariant dependence is the covariant
dependence of the input. In our notation, we place the $\forall\alpha$
on the left to be suggestive of the fact that it is contravariant in
$R$ and $P$. Next, the introduction form is again a polymorphic
$\lambda$, but this time we write the object variable $\alpha$ first,
and then the set variable $x$, to match the structure of the
context. The elimination form is similarly an application, but to
agree with the ordered use of variables, this time we place the
argument to the left and the function to the right.

\begin{figure}
  % TODO: formalize the one-place substitution
  \begin{mathpar}
      \inferrule*[right=Covariant Hom formation]
      {\Gamma \pipe d^+\Xi; \alpha : \cat C \vdash  R \and \Gamma \pipe  d^-\Xi; \alpha : \cat C \vdash P}
      {\Gamma \pipe \Xi \vdash \homrallXYtoZ \alpha R P}

      \inferrule*[right=Covariant Hom introduction]
      {\Gamma \pipe \Phi, x : R, \alpha : \cat C \vdash t : P}
      {\Gamma \pipe \Phi \vdash
        \homrlambdaXatYdotZ {x : R} {\alpha : \cat C} t : \homrallXYtoZ \alpha R P}

      %% \inferrule*[right=Covar Hom elim simple]
      %% {}
      %% {\alpha: \cat C, f:\forall \gamma. P \triangleleft R, \beta : \cat D, x : R, \gamma : \cat E \vdash f\triangleleft (x, \gamma) : P}

      \inferrule*[right=Covariant Hom elimination]
      {\Phi = \Phi_f \jnctx \Phi_a\and
       \Gamma\pipe\Phi_f \vdash s : \homrallXYtoZ {\alpha:\cat C} R P \and
       d^+\Phi_a \vdash a : \cat C\and
       \Phi_a \vdash t : R[a/\alpha]
        }
      {\Gamma\pipe \Phi \vdash \homrappXtoYatZ s t a : P[a/\alpha]}\\

      \homrappXtoYatZ {(\homrlambdaXatYdotZ x \alpha s)} t a = s[t/x,a/\alpha] (\beta)
      %% (\lambda^\triangleleft (x, \gamma). M)\triangleleft (x, \gamma) = M (\beta)

      \inferrule
      {\Gamma\pipe\Phi \vdash s : \homrallXYtoZ \alpha R P}
      {s = \homrlambdaXatYdotZ {x}{\alpha} \homrappXtoYatZ s x \alpha}
      
      %% \inferrule
      %% {\Gamma\pipe\Phi, x:R, \alpha : \cat C \vdash \homrappXtoYatZ s x \alpha = \homrappXtoYatZ t x \alpha : P}
      %% {\Gamma\pipe\Phi \vdash s = t : \homrallXYtoZ \alpha R P}

      \inferrule*[right=Contra Hom formation]
      {\Gamma \pipe \alpha:\cat C; d^-\Xi\vdash R \and \Gamma \pipe \alpha : \cat C; d^+\Xi\vdash P}
      {\Gamma \pipe \Xi \vdash \homlallXYtoZ \alpha R P}

      \inferrule*[right=Contra Hom introduction]
      {\Gamma\pipe\alpha:\cat C, x : R, \Phi \vdash t : P}
      {\Gamma\pipe\Phi \vdash \homllambdaXatYdotZ {x : R} {\alpha : \cat C} t : \homlallXYtoZ \alpha R P}

      \inferrule*[right=Contra Hom elimination]
      {\Phi = \Phi_a \jnctx \Phi_f\and
        \Gamma \pipe d^-\Phi_a \vdash a : \cat C\and
       \Gamma \pipe \Phi_a \vdash s : R[a/\alpha] \and
       \Gamma \pipe \Phi_f \vdash t : \homlallXYtoZ {\alpha:\cat C} R P}
      {\Gamma \pipe \Phi \vdash \homlappXtoYatZ t s a : P[a/\alpha]}\\

      \inferrule*[Right=$\beta$]
                 {}
                 {\homlappXtoYatZ {(\homllambdaXatYdotZ x \alpha t)} s a = t[a/\alpha,s/x]}

      \inferrule*[right=$\eta$]
      {\Gamma \pipe \Phi \vdash t : \homlallXYtoZ \alpha R P}
      {\Gamma \pipe \Phi \vdash t = \homllambdaXatYdotZ x \alpha \homlappXtoYatZ t x \alpha : \homlallXYtoZ \alpha R P}

      %% \inferrule*[right=$\eta$]
      %% {\Gamma \pipe \alpha:\cat C, x:R, \Phi \vdash \homlappXtoYatZ M x \alpha = \homlappXtoYatZ N x \alpha : P}
      %% {\Gamma \pipe \Phi \vdash M = N : \homlallXYtoZ \alpha R P}
  \end{mathpar}
  \caption{Hom of Relations/Profunctors}
  \label{fig:hom}
\end{figure}

In category theory, these profunctors can be constructed using an
\emph{end} and the hom of functor categories\cite{somecats}. Given two
profunctors $P : C^o \times E \to \Set$ and $R : D^o \times E \to
Set$, their hom is given as
\[ \int_{e \in E} R(-,e) \Rightarrow P(e,=) \]

%% The syntax is given in Figure~\ref{fig:cotensor}.
%% %
%% First, the formation rule for covariant cotensor formation requires
%% that the covariant variables for $R,P$ are the same, and the
%% contravariant variables match the boundary of the overall
%% judgment. Note that we use $d^+\Xi,d^-\Xi$ to allow for the case that
%% the boundary is a single variable $\Xi = \alpha:\cat C$.
%% %
%% Next, the substitution rule is straightforward.
%% %
%% Then we have the elimination form, first written in a simple form with
%% no substitution built in.
%% %
%% This says that given a variable of the cotensor judgment, and another
%% variable of judgment $R$, we can apply these to get a term of judgment
%% $P$. As a diagram this is written as follows:

%% \[ % https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAGEQBfU9TXfIRQBGclVqMWbACLdeIDNjwEiAJjHV6zVohABROXyWCiZYeK1TdnHkYEqU685sk793cTCgBzeEVAAZgBOEAC2SGQgOBBIohLabAA6iQEQQYwMAATJ3nShoXQAdJkACtmJOEFYdGDeDDD1ATiZAEqGIMFhsdTRSOrxViBtth0h4YgAzD0xiAAsLgm6Je2d45G9k9QMWGBuUBBMAEb1INQAFjB0UGyQu6dRdFgMNwSsI6t900jzIBdXL3ctjs9gdjqweo9nrpbm8KFwgA
%% \begin{tikzcd}
%% C \arrow[r, "\forall \gamma. P \triangleleft R"] \arrow[d, no head, Rightarrow] & D \arrow[r, "R"] & E \arrow[d, no head, Rightarrow] \\
%% C \arrow[rr, "P"]                                                               &                  & E                               
%% \end{tikzcd}\]

%% The universal property of this judgment is that this is the universal
%% 2-cell of this type, in that any 2-cell


%% \[ % https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAGEByEAX1PUy58hFACZyVWoxZsAIr34gM2PASIBmCdXrNWiEAFEFAlcKJkAjJJ0z97Y0sGqRyTVe3S9hh8qFqUFlpSumy8kjBQAObwRKAAZgBOEAC2SIEgOBBI4sG2IABKDokpSJoZWYgALB4h+gAKRUmpiGTlpdQMWGBecBCdUCDUABYwdAOIYEwMDNQ4dFgMbJDdjSWIOZlI1SAjY0sErB1dXlAQTABGDIcZ84v6y6x88U1IrZuIAKxPIMXNH7MVdKdFb6KB0OAjAbDUbjcAHMI8IA
%% \begin{tikzcd}
%% C' \arrow[d] \arrow[r] & {} \arrow[r, no head, dashed] & D \arrow[r, "R"] & E \arrow[d, no head, Rightarrow] \\
%% C \arrow[rrr, "P"]     &                               &                  & E                               
%% \end{tikzcd}\]

%% Exhibits a unique factorization:

%% \[ % https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBoBGAXVJADcBDAGwFcYkQBhEAX1PU1z5CKAEwVqdJq3YARHnxAZseAkQDM4mgxZtEIAKLz+yoUTIiJ26Xq69jg1Sg0WtU3QaOKBK4SVLFLN3YOAHJPJQdfcn9AnXZw71NRGNc4vTk7LxNHZA0A1OsPbgkYKABzeCJQADMAJwgAWyRokBwIJDFJNJAAJU86xqQNVvbEABYC9wAFfvqmxDIRoZpGLDB3KAhmACNGNhoACxh6KHZIdZAaHHosRjOCNkyB+c62pAmQI5P7i5W1ja2u32rRudz050eCmeSAArFdRgA2J5zJAI+FIADsfwueig9DgR1Oh2Op3BD1mg0QWKWiBaqxxIE2Oz2l0+JJ+wOutw5FPmcJpxGRlMWb1pk3YAB0JdUILUmIwAARSsr0BoNegAOgVUyVEpwtSw9DAZT2e2qOAVfSF82pooAHOK9FaoSjEA6aZ16QDmcCvqTwOSrqCecVuEA
%% \begin{tikzcd}
%% C' \arrow[r] \arrow[d]                                                           & {} \arrow[r, no head, dashed] & D \arrow[d, no head, Rightarrow] \arrow[r, "R"] & E \arrow[d, no head, Rightarrow] \\
%% C \arrow[d, no head, Rightarrow] \arrow[rr, "\forall \gamma. P \triangleleft R"] &                               & D \arrow[r, "R"]                                & E \arrow[d, no head, Rightarrow] \\
%% C \arrow[rrr, "P"]                                                               &                               &                                                 & E                               
%% \end{tikzcd}\]

%% We give elimination rules and introduction rules in a style similar to
%% $\lambda$-calculus, with corresponding $\beta\eta$ rules.

These hom types are useful both for category-theoretic applications
(Kan extensions, the Yoneda lemma), but also for purely syntactic
reasons.  The universal property of these function types allows us, by
iterated hom to express any sequent $\Phi \vdash R$ as an equivalent
one with an ``empty'' context, i.e., a single object variable $d^\pm
\Phi$. Then using the end type defined in the previous section, we can
internalize that judgment as a type in our ambient dependent type
theory.

As an example, any sequent $\Gamma \pipe \alpha, x: R, \beta, y : S, \gamma \vdash
P$ is equivalent to either of
\[ \Gamma \vdash \pendallXdotY\alpha \homrallXYtoZ \beta R \homrallXYtoZ \gamma S P 
\qquad\qquad\qquad \Gamma \vdash \pendallXdotY \gamma \homlallXYtoZ \beta S {\homlallXYtoZ \alpha R P}\]
This property is useful in giving a simple syntax to positive types.

\subsection{Unit and Tensor of Profunctors}

While the hom sets of the previous section work quite smoothly since
they are negative connectives in a natural deduction system, the positive
connectives, the unit and tensor, are trickier to define.

First, the multiplicative unit is the set $\punitinXfromYtoZ {\cat C}
{a_1} {a_2}$, semantically, the hom set of the category $\cat C$. The
rules for this type act like an identity type in a directed type
theory. The introduction rule defines an identity morphism of an
object in any category. The elimination rule is then the appropriate
analogue of the $J$ rule of the identity type. Given any profunctor
$Q$ from $\cat C$ to itself, we can construct an element $\harrapp Q
{\alpha_1}{\alpha_2}$ for any objects in $\cat C$ if we specify a
natural element $\harrapp Q \alpha \alpha$ for any $\alpha$ in $\cat
C$. The reason this is sufficient, semantically, is that all
profunctors must be functorial in their two indices. In fact, as we
will see in the section on synthetic category theory, this induction
principle is how we can show internally that profunctors are
functorial in their indices. We choose to express this elimination
form using the right hom type as its syntax more closely matches the
usual syntax of function types, but this choice is arbitrary, and we
would get an equivalent calculus had we used the left hom, or added
both.

Next, we continue with the tensor product $\tensorexistsXwithYandZ
\beta P Q$. Adjoint to the right/left hom sets, this provides a form
of \emph{existentially quantified pair}. The formation rule states the
set is well-formed when $\beta$ is the covariant variable of $P$ and
the contravariant variable of $Q$, and, its contravariant dependence
is the same as $P$, while its covariant dependence is the same as $Q$.
%
The introduction rule is then a tuple $\tensorintroatXwithYandZ b s t$
with an instantiation $b$ of the quantified variable $\beta$. Note
that the use of $d^+\Psi_s$ in the rule could be replaced by
$d^-\Psi_t$ since they must be equal by the side condition $\Phi =
\jnctx \Psi_s \Psi_t$.
%
The elimination rule says to construct a transformation taking a pair
as input it is sufficient to construct one that takes in a $P$ and $Q$
for any $\beta$, directly corresponding to the adjoint relationship
between the tensor and the right hom.
%
Finally, we have the expected $\beta\eta$ equations.

\begin{figure}
  \begin{mathpar}
    \inferrule*[right=Unit-Formation]
    {\Gamma \vdash \cat C \isaCat\and
     \Gamma \pipe d^-\Xi \vdash a_1 : \cat C\and \Gamma \pipe d^+ \Xi \vdash a_2 : \cat C}
    {\Gamma \pipe \Xi \vdash \punitinXfromYtoZ {\cat C} {a_1} {a_2}}

    %% (A \to A')[\xi] = A[d^-\xi] \to A'[d^+\xi]

    \inferrule*[right=Unit-Introduction]
    {\Gamma\pipe\beta: \cat D \vdash a : \cat C}
    {\Gamma \pipe\cdot \vdash \punitrefl a : \punitinXfromYtoZ {\cat C} a a}

    \inferrule*[right=Unit Elim]{
      \Gamma\vdash Q : \harr {\cat C} {\cat C}\and
      \Gamma\vdash t : \pendallXdotY {\alpha:\cat C} {\harrapp Q \alpha \alpha}}
    {\Gamma \vdash \punitelimtoYwithkontZ Q N :
      \pendallXdotY {\alpha_1} {\homrallXYtoZ {\alpha_2} {\punitinXfromYtoZ {\cat C} {\alpha_1}{\alpha_2}} {\harrapp Q {\alpha_1}{\alpha_2}}}
      }

    %% J_\to(\alpha_1.\alpha_2. Q, \alpha. N, A_1, M, A_2)[\phi] = J_\to(\alpha_1.\alpha_2. Q, \alpha. N, A_1[d^-\phi], M[\phi], A_2[d^+\phi])

    %% \inferrule*[right=Unit$\beta$]{\beta:\cat D \vdash A : \cat C\and
    %%   \alpha:\cat C \vdash N : Q[\alpha/\alpha_1,\alpha/\alpha_2]
    %% }{\beta : \cat D \vdash J_\to(\alpha_1.\alpha_2. Q, \alpha. N, A, \id(A), A) = N[A/\alpha] : Q[A/\alpha_1,A/\alpha_2]}
    %%

    \appunary {\punitelimtoYwithkontZ Q N} a {\punitrefl a} a = \pendappXtoY N a

    \inferrule*[right=Unit$\eta$]
    {\Gamma \vdash M : \pendallXdotY {\alpha_1} \homrallXYtoZ {\alpha_2} {\punitinXfromYtoZ {\cat C} {\alpha_1} {\alpha_2}} {\harrapp Q {\alpha_1} {\alpha_2}}}
    {M = {\punitelimtoYwithkontZ Q {\appunary M \alpha {\punitrefl \alpha} \alpha}}}
    %% {}
    %% {\alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2:\cat C \vdash M : \harrapp Q {\alpha_1} {\alpha_2}}
    %% {\alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2:\cat C \vdash M =
    %%   \homrappXtoYatZ {\pendappXtoY {\punitelimtoYwithkontZ Q {\pendlambdaXdotY \alpha M[\alpha/\alpha_1,\pendappXtoY {\punitrefl C} \alpha/f,\alpha/\alpha_2]}} {\alpha_1}} f {\alpha_2}
    %% : \harrapp Q {\alpha_1}{\alpha_2}}

    \inferrule*[right=Tensor formation]
    {\Gamma \pipe d^-\Xi; \beta:D\vdash P \isaSet\and
     \Gamma \pipe \beta:D;d^+\Xi \vdash Q \isaSet}
    {\Gamma \pipe \Xi \vdash \tensorexistsXwithYandZ {\beta:D} P Q}

  %% \inferrule*[right=Tensor intro function]
  %% {}
  %% {\alpha : \cat C, q : Q, \beta : \cat D, r : R, \gamma : \cat E \vdash (q, \beta,r) : \exists \beta : \cat D. Q \odot R}

  %% \inferrule*[right=Tensor introduction]
  %% {\Gamma \vdash P : \harr C D \and
  %%   \Gamma \vdash Q : \harr D E}
  %% {\Gamma\pipe\cdot\vdash \tensorintroofXandY P Q : \pendallXdotY {\alpha} \homrallXYtoZ \beta {\harrapp P \alpha \beta} {\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta}{\harrapp Q \beta \gamma})}}}

  \inferrule*[right=Tensor introduction]
  {\Phi = \Psi_s \jnctx \Psi_t \and
   \Gamma \pipe d^+\Psi_s \vdash b : \cat D\and
   \Gamma \pipe \Psi_s \vdash s : P[b/\beta] \and
   \Gamma \pipe \Psi_t \vdash t : Q[b/\beta]}
  {\Gamma\pipe\Phi\vdash \tensorintroatXwithYandZ b s t : \tensorexistsXwithYandZ {\beta : \cat D} P Q}

  %% \tensorintroatXwithYandZ B M N [\phi,B'/\beta',\psi] = \tensorintroatXwithYandZ {B[B'\beta]} {M[\phi]} {N[\psi]}

  %% \inferrule*[right=Tensor simpl]
  %% {\Gamma\pipe\cdot \vdash R : \harr {C} {E}\and
  %%  \Gamma\pipe\cdot \vdash N : \pendallXdotY {\alpha:C} {\homrallXYtoZ {\beta:D} P {\homrallXYtoZ {\gamma:E} Q {\harrapp R \alpha\gamma}}}}
  %% {\Gamma\pipe\alpha:C,p:\tensorexistsXwithYandZ {\beta:D} P Q,\gamma:E \vdash\tensorelimVatWtoXtoYwithkontZ p \alpha \gamma R N : \harrapp R A G}

  \inferrule*[right=Tensor-elim]
  {\Gamma \pipe \vdash P : \harr {\cat C} {\cat D}\and\Gamma \vdash Q : \harr {\cat D}{\cat E}\and
   \Gamma \vdash R : \harr {\cat C}{\cat E}\and
   \Gamma \vdash N : \hombinary \alpha {\harrapp P \alpha \beta} \beta {\harrapp Q \beta \gamma} \gamma {\harrapp R \alpha \gamma}}
  {\Gamma \vdash \tensorelimfromWXtoYwithkontZ P Q R N : \homunary \alpha {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\gamma} {\harrapp R \alpha \gamma}}
  
  %% \inferrule*[right=Tensor elim]
  %% {\Gamma\pipe\cdot \vdash R : \harr {C} {E}\and
  %%  \Gamma\pipe\Phi \vdash M : \tensorexistsXwithYandZ {\beta:D} {P[A/\alpha;]} {Q[;G/\gamma]}\and
  %%  \Gamma\pipe\cdot \vdash N : \pendallXdotY {\alpha:C} {\homrallXYtoZ {\beta:D} P {\homrallXYtoZ {\gamma:E} Q {\harrapp R \alpha\gamma}}}}
  %% {\Gamma\pipe\Phi \vdash\tensorelimVatWtoXtoYwithkontZ M A G R N : \harrapp R A G}

  %% J_\odot(\alpha. \gamma. S, \alpha.q.\beta.r.\gamma.N, A, M, G)[\phi] =
  %% J_\odot(\alpha. \gamma. S, \alpha.q.\beta.r.\gamma.N, A[d^-\phi], M[\phi], G[d^+\phi])

  %% \inferrule*[right=Tensor elim Sequent]
  %% {\Phi,\alpha : \cat C, q : Q, \beta : \cat D, r: R, \gamma : \cat E,\Psi \vdash N : S}
  %% {\Phi, \alpha : \cat C, x : \exists \beta. Q \odot R, \gamma : \cat E,\Psi \vdash J_\odot(x;q.\beta.r. N) : S}

  %% \inferrule*[right=Tensor elim Subst]
  %% {\Phi,\alpha : \cat C, q : Q, \beta : \cat D, r: R, \gamma : \cat E,\Phi' \vdash N : S
  %% \and
  %% \phi : \Psi \to \Phi,\alpha : \cat C, q : Q, \beta : \cat D, r: R, \gamma : \cat E,\Phi'}
  %% {\Psi  \vdash J_\odot(x;q.\beta.r. N)[\phi] : S}


  
  \inferrule*[right=Tensor $\beta$]
  {}
  {\appunary {\tensorelimfromWXtoYwithkontZ P Q R N} a {\tensorintroatXwithYandZ b s t} c = \appbinary N a s b t c}
  %% {\homrappXtoYatZ {\pendappXtoY{\tensorelimfromWXtoYwithkontZ P Q R N} A} {(\homrappXtoYatZ{\homrappXtoYatZ{\pendappXtoY {\tensorintroofXandY P Q} A} f B} g G)} G =
  %%   \homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY N A} f B} g G}
  
  %% \inferrule*[right=Tensor $\beta$]
  %% {}{J_\odot(\alpha.\gamma.S, \alpha.q.\beta.r.\gamma.N,A,(M,B,N),G) = N[A/\alpha,M/q,B/\beta,N/r,G/\gamma]}

  \inferrule*[right=Tensor$\eta$]
  {\Gamma \vdash N : \homunary \alpha {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta}{\harrapp Q \beta \gamma})} \gamma {\harrapp R \alpha \gamma}}
  {N = \tensorelimfromWXtoYwithkontZ P Q R {\lambdabinary \alpha x \beta y \gamma \appunary N \alpha {\tensorintroatXwithYandZ \beta x y} \gamma}}

  %% \inferrule*[right=Tensor$\eta$]
  %% {\alpha : \cat C, x : \tensorexistsXwithYandZ \beta P Q, \gamma : \cat E \vdash M : R}
  %% {\alpha : \cat C, x : \exists \beta. Q \odot R, \gamma : \cat E \vdash M =
  %%   \homrappXtoYatZ {\pendappXtoY{\tensorelimfromWXtoYwithkontZ P Q R
  %%       {\pendlambdaXdotY \alpha {\homrlambdaXatYdotZ p \beta {\homrlambdaXatYdotZ q \gamma {M[\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {\tensorintroofXandY P Q} \alpha} p \beta} q \gamma/x]}}}}
  %%     } \alpha} x \gamma : S}
  \end{mathpar}  
  \caption{Unit, Tensor of Profunctors}
\end{figure}

%% Next, we can internalize the $,\alpha,$ as a positive connective as a
%% kind of ``existentially quantified tensor product'', abstracting the
%% composition of profunctors.

%% The ordinary formula for this is that for profunctors $R : C^o \times
%% D \to \Set$ and $S : D^o \times E \to \Set$, the composite is given by
%% a coend:

%% \[ \int^{d \in D} R(-,d) \otimes S(d,=) \]

%% We will instead use slightly more logical notation, writing the coend as
%% an existential quantifier, justified by the analogy between the two
%% and the structure of the introduction/elimination forms in our syntax
%% in particular.
%% \begin{figure}
%% \begin{mathpar}
%% \end{mathpar}
%% \caption{Tensor Primitive Rules}
%% \label{fig:tensor}
%% \end{figure}

Semantically, the tensor product is the composition of profunctors,
which is typically written as a coend
\[ \int_{\beta} P(-,\beta) \times Q(\beta,=) \]

\subsection{Graph of a profunctor}

One final multiplicative we can define is the \emph{graph} of a
profunctor. Given a profunctor $\alpha:\cat C;\beta:\cat D \vdash R$,
the ``graph'' of $R$ is a category $\Sigma_{\alpha:\cat C;\beta:\cat
  D}. R$. In detail, its objects are triples $(a:\cat C, r : R, b :
\cat D)$ and morphism from $(a,r,b)$ to $(a', r', b')$ consists of a
pair of morphisms $g : b \to b'$ and a backwards $f : a' \to a$ such
that $r' = g\circ r \circ f$.
%
Intuitively this generalizes the ``graph'' of a relation $R : A\times
B \to \Omega$, where we think of the graph as the corresponding subset
$gr(R) \subseteq A\times B$
%
By picking $R = \punitinXfromYtoZ {\cat C} {\alpha}{\alpha'}$ we
recover the \emph{arrow} category $\exists
(\alpha;\alpha'). \punitinXfromYtoZ {\cat C}{\alpha}{\alpha'}$, by
composing these with functors, we recover the notion of \emph{comma}
category $\Sigma \alpha;\beta. \punitinXfromYtoZ {\cat
  E}{(F\alpha)}{(G\beta)}$ and by picking either $F$ or $G$ to have
domain the terminal category $1$, we recover the notion of a
\emph{slice} category.

This is unique among the multiplicatives in that it defines a
\emph{category} rather than a profunctor. The graph of a profunctor is
a \emph{negative} multiplicative, a kind of $\Sigma$-type for
profunctors. The universal property says that a functor from $\cat E$
into the graph $\Sigma (\alpha; \beta). R$ is equivalent to a
transformation from $\cat E$ into the functor $R$, including functors
from $\cat E$ to $\cat C$ and $\cat D$.
%
The graph of a profunctor is a joint generalization of several common
constructions in category theory: the arrow category, slice
categories, comma categories and the covariant and the covariant and
contravariant category of elements.

\begin{figure}
  \begin{mathpar}
    \inferrule*[right=Graph-Formation]
    {\Gamma \vdash \alpha:\cat C; \beta:\cat D \vdash R \isaSet}
    {\Gamma \vdash \exists (\alpha;\beta). R \isaCat}

    \inferrule*[right=Graph-E+]
    {\Gamma \vdash \gamma:\cat E \vdash \phi : \exists(\alpha:\cat C;\beta: \cat D).R}
    {\Gamma \vdash \pi_+\phi : \cat C}

    \inferrule*[right=Graph-E-]
    {\Gamma \vdash \gamma:\cat E \vdash \phi : \exists(\alpha:\cat C;\beta: \cat D).R}
    {\Gamma \vdash \pi_-\phi : \cat D}

    \inferrule*[right=Graph-Ep]
    {\Gamma \vdash \gamma:\cat E \vdash \phi : \exists(\alpha:\cat C;\beta: \cat D).R}
    {\Gamma \vdash \gamma:\cat E \vdash \pi_p\phi : R[\pi_+\phi/\alpha,\pi_-\phi/\beta]}

    \inferrule*[right=Graph-Intro]
    {\Gamma\vdash \gamma:\cat E \vdash a : \cat C \and
      \Gamma\vdash \gamma:\cat E \vdash b : \cat D \and
      \Gamma\vdash \gamma:\cat E \vdash t : R[a/\alpha;b/\beta]}
    {\Gamma\vdash \gamma:\cat E \vdash (a,b,t) : \exists (\alpha;\beta). R}
    
    \inferrule*[right=Unit-Formation]
    {\Gamma \vdash \cat C \isaCat\and
     \Gamma \pipe d^-\Xi \vdash a_1 : \cat C\and \Gamma \pipe d^+ \Xi \vdash a_2 : \cat C}
    {\Gamma \pipe \Xi \vdash \punitinXfromYtoZ {\cat C} {a_1} {a_2}}

    \pi_+(a,b,t) = a \\
    \pi_-(a,b,t) = b \\
    \pi_p(a,b,t) = t\\

    \inferrule
    {\Gamma \vdash \gamma:\cat E \vdash \phi : \exists(\alpha:\cat C;\beta:\cat D). R}
    {\phi = (\pi_+\phi, \pi_-\phi, \pi_p\phi)}
  \end{mathpar}  
  \caption{Graph of a Profunctor}
\end{figure}

\subsection{Positive and Negative Presheaf Categories}

Though defining arbitrary functor categories type-theoretically would
require a ``multi-argument functor'' judgment, we can define
\emph{presheaf} categories by the universal property that a functor
$\cat C \to \mathcal P {\cat D}$ is the same as a profunctor from
$\cat D$ to $\cat C$. To distinguish the covariant from contravariant
presheaves, we define them dually as $\negPresheaf {\cat C}$ and
$\posPresheaf {\cat D}$

\begin{figure}
  \begin{mathpar}
    \inferrule*[right=NegPresheaf-Formation]
    {\Gamma \vdash \cat C \isaCat}
    {\Gamma \vdash \negPresheaf {\cat C} \isaCat}

    \inferrule*[right=NegPresheaf-E]
    {\Gamma \pipe d^-\Xi \vdash a : \cat C \and
     \Gamma \pipe d^+\Xi \vdash p : \negPresheaf {\cat C}
    }
    {\Gamma \pipe \Xi \vdash \negPresheafApp a p \isaSet}

    \inferrule*[right=NegPresheaf-I]
    {\Gamma \pipe \alpha:\cat C;\beta:\cat D \vdash R : \isaSet}
    {\Gamma \pipe \beta:\cat D \vdash \lambda \alpha:\cat C. R : \negPresheaf {\cat C}}

    \negPresheafApp a (\lambda \alpha. R) = R[a/\alpha]\\

    \inferrule*[right=NegPresheaf-$\eta$]
    {\Gamma \pipe \beta:\cat D \vdash p : \negPresheaf {\cat C}}
    {p = \lambda \alpha. \negPresheafApp \alpha p}

    \inferrule*[right=PosPresheaf-Formation]
    {\Gamma \vdash \cat D \isaCat}
    {\Gamma \vdash \posPresheaf {\cat D} \isaCat}

    \inferrule*[right=PosPresheaf-E]
    {\Gamma \pipe d^-\Xi \vdash p : \posPresheaf {\cat D}\and
     \Gamma \pipe d^+\Xi \vdash a : \cat D
    }
    {\Gamma \pipe \Xi \vdash \posPresheafApp p a \isaSet}

    \inferrule*[right=PosPresheaf-I]
    {\Gamma \pipe \alpha:\cat C;\beta:\cat D \vdash R : \isaSet}
    {\Gamma \pipe \alpha:\cat C \vdash \lambda \beta:\cat D. R : \posPresheaf {\cat D}}

    \posPresheafApp {(\lambda \beta. R)} b = R[b/\beta]\\

    \inferrule*[right=PosPresheaf-$\eta$]
    {\Gamma \pipe \alpha:\cat C \vdash p : \posPresheaf {\cat D}}
    {p = \lambda \beta. \posPresheafApp p \beta}
  \end{mathpar}
  \caption{Presheaf Categories}
\end{figure}

\subsection{Dependent Types}

Next, we cover the basic dependent type theory structure: $\Pi,\Sigma$
and identity types.

\begin{figure}
  \begin{mathpar}
  \inferrule
  {\Gamma \pipe\cdot \vdash S \isaSet\and \Gamma \pipe\cdot \vdash T \isaSet}
  {\Gamma\pipe\cdot \vdash \prod_{x:S} T \isaSet}

  \inferrule
  {\Gamma \pipe \cdot \vdash M : \prod_{x:S} T\and
    \Gamma \pipe \cdot \vdash N : S}
  {\Gamma \pipe \cdot \vdash M N : T[N/x]}

  \inferrule
  {\Gamma,x:S \pipe \cdot \vdash M : T}
  {\Gamma \pipe \cdot \vdash \lambda x:S. M : \prod_{x:S} T}

  \inferrule
  {\Gamma \pipe\cdot \vdash S \isaSet\and \Gamma \pipe\cdot \vdash T \isaSet}
  {\Gamma\pipe\cdot \vdash \sum_{x:S} T \isaSet}
  
  \inferrule
  {~}
  {\Gamma\pipe\cdot \vdash \top \isaSet}

  \inferrule
  {\Gamma \pipe \cdot \vdash M : S\and \Gamma \pipe \cdot \vdash N : S}
  {\Gamma \pipe \cdot \vdash \textrm{Id}_S M N \isaSet}

  \inferrule
  {\Gamma \pipe \cdot \vdash M : S}
  {\Gamma \pipe \cdot \vdash \textrm{refl}(M) : \textrm{Id}_S M M}

  \inferrule
  {\Gamma,x:S,y:S,p:\textrm{Id}_S x y \pipe \cdot \vdash C \isaSet\and
   \Gamma \pipe \cdot \vdash M_k : \prod_{x:S} C[x/y,\textrm{refl}(x)/p]}
  {\Gamma \pipe \cdot \vdash \textrm{J}(x,y,p.C,M) : \prod_{x:S,y:S,p:\textrm{Id}_S x y} C}
  \end{mathpar}
  \caption{Ordinary Dependent Type Structure}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \inferrule
    {}
    {\Gamma\vdash \smallCats}

    \inferrule
    {}
    {\Gamma\vdash \Cats}
    
    \inferrule
    {\Gamma \vdash \cat C : \Sort \and\Gamma \vdash \cat D : \Sort}
    {\Gamma\pipe\cdot \vdash \varr{\cat C}{\cat D} \isaSet}

    \inferrule
    {\Gamma \vdash \cat C : \Sort \and\Gamma \vdash \cat D : \Sort}
    {\Gamma\pipe\cdot \vdash \harr{\cat C}{\cat D} \isaSet}

    \inferrule
    {\Gamma \pipe \alpha:\cat C \vdash A : \cat D}
    {\Gamma \vdash \lambda \alpha:\cat C. A : \varr{\cat C}{\cat D}}

    \inferrule
    {\Gamma \pipe \alpha:\cat C \vdash A : \cat D\and
      \Gamma\pipe\cdot \vdash M : \varr{\cat D}{\cat E}}
    {\Gamma\pipe \alpha:\cat C \vdash M A : \cat E}

    \inferrule
    {\Gamma \pipe \alpha:\cat C;\beta:\cat D \vdash R \,\isaSet}
    {\Gamma \vdash \lambda \alpha:\cat C;\beta:\cat D. R : \harr{\cat C}{\cat D}}

    \inferrule
    {\Gamma \vdash M : \harr{\cat C}{\cat D}\and
     \Gamma \pipe d^- \Xi \vdash A : \cat C\and
     \Gamma \pipe d^+ \Xi \vdash B : \cat C}
    {\Gamma \pipe \Xi \vdash M A; B \isaSet}

    \inferrule
    {\Gamma \pipe \alpha:\cat C\vdash P \isaSet}
    {\Gamma \vdash \pendallXdotY {\alpha:{\cat C}} P \isaTy}

    \inferrule
    {\Gamma \pipe \alpha:\cat C\vdash t : P}
    {\Gamma \vdash \pendlambdaXdotY \alpha t : \pendallXdotY \alpha P}

    \inferrule
    {\Gamma \vdash M : \pendallXdotY \alpha P\and
     \Gamma \pipe \beta:\cat D \vdash a : \cat C}
    {\Gamma \pipe \beta:\cat D \vdash \pendappXtoY M a : P[a/\alpha]}
  \end{mathpar}
  \caption{Type Connectives}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule
    {\Gamma \pipe \alpha:\cat C\vdash P \isaSet}
    {\Gamma \vdash \pendallXdotY {\alpha:{\cat C}} P \isaTy}

    \inferrule
    {\Gamma \pipe \alpha:\cat C\vdash t : P}
    {\Gamma \vdash \pendlambdaXdotY \alpha t : \pendallXdotY \alpha P}

    \inferrule
    {\Gamma \vdash M : \pendallXdotY \alpha P\and
     \Gamma \pipe \beta:\cat D \vdash a : \cat C}
    {\Gamma \pipe \beta:\cat D \vdash \pendappXtoY M a : P[a/\alpha]}

    \pendappXtoY {(\pendlambdaXdotY \alpha t)} a = t[a/\alpha]

    \inferrule*[right=2Cell$\eta$]
    {\Gamma \vdash M : \pendallXdotY \alpha P }
    {\Gamma \vdash M = \pendlambdaXdotY \alpha {\pendappXtoY M \alpha} : \pendallXdotY \alpha P}
  \end{mathpar}
  \caption{End}
  \label{fig:end}
\end{figure}

\section{Extended Formal Category Theory Examples}
\label{sec:appendix:examples}

Next, we provide some futher detailed examples of the formal category
theory constructions and theorems from Section~\ref{sec:examples}.

\section{Semantics}
\label{sec:appendix:semantics}

In this section, we provide the full definitions of the universal
properties in a virtual equipment corresponding to each connective in
\vett{}, and the most critical details of the soundness and
completeness proof.

TODO

Next, we develop the basics of the model theory for SCT. Because SCT
includes not just a syntax for category theory, but is also indexed by
an ordinary context of dependent type theory $\Gamma$, a model of SCT
is not given by a \emph{single} virtual double category, but instead
by an \emph{indexed family} of VDCs, parameterized by an object of a
category that interprets dependent type theory. We call such a
structure a \emph{VDC-hyperdoctrine}. We then show how to construct a
from any VDC, a VDC-hyperdoctrine indexed by the category of sets,
which has the intuitive reading that any of the VDC judgments $\Gamma
\vdash J$ is interpreted as a family of $J$-data parameterized
by elements of the set $\Gamma$.

%% The first component of this is \emph{soundness}: every category,
%% object, set and transformation denote an object, vertical arrow,
%% horizontal arrow and 2-cell, respectively in any representable virtual
%% equipment, such that all equations in the theory are satisfied.
%% %
%% We combine this with a set theoretic semantics for types $A$ and
%% contexts $\Gamma$ to get a simple semantics of our logic over a
%% virtual equipment.
%% %
%% The second component of this is the \emph{completeness} theorem:
%% informally, the theory contains every category, object, set and
%% transformation that \emph{must} exist in any virtual equipment, and
%% further equations between syntactic forms hold if and only if they
%% hold in every model.
%% %
%% While sounding more ambitious, the completeness theorem is
%% typically simpler as it just amounts to showing that the syntax itself
%% forms a virtual equipment.

\subsection{Notion of Model}

%% 1. A strict double category is a monoid in Span(Cat)
%% 2. A strict double category internal to a topos T is a monoid in Span(T-Cat)
%% 3. A double category with display pro-arrows is a strict double category with a span of profunctors that is representable
%%    C0 <- C1 -> C0
%% 4. UMPs are given on top of that structure

We build up the notion of a model in several stages.

\begin{definition}
  A strict double category is a monoid in the bicategory $Span(Cat)$.
\end{definition}

This data consists of a span $C_0 \leftarrow C_1 \rightarrow C_0$
where $C_0$ is the vertical category and $C_1$ is the category whose
objects are horizontal morphisms and morphisms are squares, with the
two projections giving the left and right ``frame'' for the horizontal
morphisms/squares. The unit gives the horizontal identity morphisms
and the monoid multiplication is the horizontal composition.

\begin{definition}
  A double category with displays (DCD) consists of
  \begin{enumerate}
  \item A strict double category $C$
  \item A category $C_d$ of (horizontal) ``display morphisms'' and ``display squares''.
  \item A span of profunctors:
    % https://q.uiver.app/?q=WzAsOCxbMiwyLCJDXzEiXSxbMCwyLCJDXzAiXSxbNCwyLCJDXzAiXSxbMiwwLCJDX2QiXSxbMCwwLCJDXzAiXSxbNCwwLCJDXzAiXSxbMSwxLCJcXExlZnRhcnJvdyJdLFszLDEsIlxcUmlnaHRhcnJvdyJdLFszLDAsIkNfXFx2ZGFzaCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9fX1dLFs1LDIsIlxcdGV4dHJte0hvbX0iLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifX19XSxbNCwxLCJcXHRleHRybXtIb219IiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn19fV0sWzMsNCwicyIsMl0sWzMsNSwidCJdLFswLDIsInQiLDJdLFswLDEsInMiXV0=
\[\begin{tikzcd}
	{C_0} && {C_d} && {C_0} \\
	& \Leftarrow && \Rightarrow \\
	{C_0} && {C_1} && {C_0}
	\arrow["{C_\vdash}"', "\shortmid"{marking}, from=1-3, to=3-3]
	\arrow["{\textrm{Hom}}", "\shortmid"{marking}, from=1-5, to=3-5]
	\arrow["{\textrm{Hom}}"', "\shortmid"{marking}, from=1-1, to=3-1]
	\arrow["s"', from=1-3, to=1-1]
	\arrow["t", from=1-3, to=1-5]
	\arrow["t"', from=3-3, to=3-5]
	\arrow["s", from=3-3, to=3-1]
\end{tikzcd}\]
\item A fully faithful functor $i : C_d \to C_1$ that respects source and target in that the following commute:
% https://q.uiver.app/?q=WzAsNixbMiwyLCJDXzEiXSxbMCwyLCJDXzAiXSxbNCwyLCJDXzAiXSxbMiwwLCJDX2QiXSxbMCwwLCJDXzAiXSxbNCwwLCJDXzAiXSxbMywwLCJpIiwyXSxbNSwyLCJcXGlkIl0sWzQsMSwiXFxpZCIsMl0sWzMsNCwicyIsMl0sWzMsNSwidCJdLFswLDIsInQiLDJdLFswLDEsInMiXV0=
\[\begin{tikzcd}
	{C_0} && {C_d} && {C_0} \\
	\\
	{C_0} && {C_1} && {C_0}
	\arrow["i"', from=1-3, to=3-3]
	\arrow["\id", from=1-5, to=3-5]
	\arrow["\id"', from=1-1, to=3-1]
	\arrow["s"', from=1-3, to=1-1]
	\arrow["t", from=1-3, to=1-5]
	\arrow["t"', from=3-3, to=3-5]
	\arrow["s", from=3-3, to=3-1]
\end{tikzcd}\]
and $i$ represents $C_\vdash$ in that there is a natural isomorphism:
    \[ e : C_\vdash(\Phi, R) \cong C_1(\Phi, i(R)) \]
    that commutes with the natural transformations $s,t$.
  \end{enumerate}
\end{definition}

In terms of the syntax of SCT, the category $C_0$ models the category
and functor judgments, the category $C_1$ models the profunctor
\emph{contexts} and substitutions and the category $C_d$ models the
profunctor judgment. The profunctor $C_\vdash$ models the
transformation judgment and the functor $i$ models the construction of
a ``singleton'' context $\alpha:\cat C,x:R,\beta:\cat D$. The fact
that $i$ is fully faithful corresponds to the fact that we don't
provide in the syntax a notion of morphism of profunctors separate
from the notion of substitution of singleton contexts.

A DCD is a more general notion that a VDC, but they are closely
related, in that VDCs form a coreflective subcategory of DCDs. This is
analogous to the situation in models of dependent type theory, where
DCDs are analogous to Categories with Families \cite{cwfs,natmodels}
and VDCs are analogous to the more ``syntactic'' notion of a
Contextual Category/C-system \cite{ctxcat,csystem}. First, any DCD
induces a VDC by taking the display proarrows as the proarrows and
interpreting 2-cells using $i$ and $C_\vdash$.  Second, any VDC
presents a DCD whose double category has the original VDC pro-arrows
as the display morphisms and \emph{composable strings} of proarrows as
horizontal morphisms, which gives a strict double category.
%
Taking as morphisms the strict morphisms of DCDs/VDCs, these
constructions form a coreflective embedding of VDCs into DCDs.

The principle advantage of DCDs over VDCs is that the presentation of
their algebraic structure is considerably simplified and is
straightforward to describe as a Generalized Algebraic Theory in the
sense of \citet{CartmellGAT}. This is because we don't \emph{require}
that our profunctor contexts are lists, but instead merely the fact
that their concatenation forms a strict category. Then the
associativity/identity equations for a DCD are precisely those of a
double category.

The final notion of composition that we require for our structure is
that display morphisms have \emph{restrictions} along vertical arrows.

\begin{definition}
  A DCD is an Equipment with displays when
  \begin{enumerate}
  \item The functor $(s,t) : C_d \to C_0 \times C_0$ is a split
    fibration, with restriction operation written as $(f,g)^*R$.
  \item The profunctor $C_\vdash$ respects restrictions in that
    \[ C_\vdash^{f',g'}(\Phi, (f,g)^*R) \cong C_\vdash^{f\circ f',g\circ g'}(\Phi, R) \]
  \end{enumerate}
\end{definition}
Specializing this property give us that $C_\vdash^{f,g}(\Phi,R) \cong
C_\vdash^{\id,\id}(\Phi,(f,g)^*R)$, which justifies that we only need
to give syntax for terms $\Phi \vdash t : R$ where $\Phi$ and $R$ have
the same covariant/contravariant dependencies.

We can then define the remaining connectives by UMPs in an equipment
with displays, adding in the extra strictness criterion that these
connectives appropriately commute with restriction.

\begin{figure}
  \begin{mathpar}
    C_\vdash^{f,g}(\Phi \circ_{C} \Psi, R) \cong C_\vdash^{f,g}(\Phi \circ_C i(U_C) \circ_c \Psi, R) \\
    C_\vdash^{f,g}(\Phi \circ_{C} iP \circ_D iQ \circ_E \Psi, R) \cong C_\vdash^{f,g}(\Phi \circ_C i(P \odot Q) \circ_E \Psi, R) \and (f,g)^*(P \odot Q) = (f,\id)^*P \odot (\id,g)^*Q\\
    C_\vdash^{\id_C,g}(P \circ_c \Phi, R) \cong C_\vdash^{\id_D,g}(\Phi, P \triangleright Q) \and (f,g)^*(P \triangleright Q) = (\id,f)^*P \triangleright (\id,g)^*Q\\
    C_\vdash^{f, \id_C}(\Phi \circ_c R, P) \cong C_\vdash^{f, \id_D}(\Phi, P \triangleleft Q)\and (f,g)^*(P \triangleleft Q) = (f,\id)^*P \triangleleft (g,\id)^*Q\\
    C_\vdash^{f,g}(\Phi,1) \cong 1 \and (f,g)^*1 = 1\\
    C_\vdash^{f,g}(\Phi,P \times Q) \cong C_\vdash^{f,g}(\Phi,P) \times C_\vdash^{f,g}(\Phi, Q)\and (f,g)^*(P \times Q) = (f,g)^*P \times (f,g)^*Q\\
    C_0(C,\smallint R) \cong C_\vdash(\id_C, R)\\
  \end{mathpar}
  \caption{UMPs in an Equipment with Displays}
\end{figure}

Next, each of the connectives of SCT are modeled by different
universal properties that are profunctor isomorphisms involving
principally $C_\vdash$. We define these in Figure\ref{fig:eq-umps}

\begin{definition}
  An \emph{equipment with displays} (ED) is a DCD with all of the
  universal properties in Figure\ref{eq-umps}.
\end{definition}

Finally, to model the logic over SCT provided by the dependently typed
context $\Gamma$, we use a category with families $Ctx$, and interpret
all of the prior constructions in this section to be internal to
presheaves on $Ctx$. This models the syntactic aspect that all double
category structure is parameterized by a context $\Gamma$ and stable
under substitution. Since the category of presheaves is a topos, all
definitions given in set-theoretic language can be interpreted
internally.

\begin{definition}
  A Category with Families consists of
  \begin{enumerate}
  \item A category $\textrm{Ctx}$
  \item with a terminal object $1 : \textrm{Ctx}$
  \item A presheaf $\textrm{Ty} : \widehat {\textrm{Ctx}}$ of types in context.
  \item A presheaf $\textrm{Tm} : \widehat{\int\textrm{Ty}}$ of terms of
    a given type.
  \item With a context extension functor $\textrm{ext} : \int
    \textrm{Ty} \to \textrm{Ctx}$ with universal property:
    \[ \textrm{Ctx}(\Delta,\textrm{ext}(A)) \cong (\gamma : \textrm{Ctx}(\Delta,\textrm{ctx}(A))) \times \textrm{Tm}(A[\gamma])  \]
  \end{enumerate}
\end{definition}

This can be extended in a standard way to model $\Pi,\Sigma, \Id$
types \citet{cwf-stuff}.
%
The final connectives we need are the ``universes'' that internalize
the double category structure as types in the CwF.

\begin{definition}
  Let $(\textrm{Ctx},\textrm{Ty},\textrm{Tm},\textrm{ext})$ be a
  category with families and let $\mathcal V = (C,C_d)$ be a DCD internal to
  $\Set^\textrm{Ctx}$. Then
  \begin{enumerate}
  \item $\mathcal V$ objects are representable as types if there is a
    type given by a section $\textrm{Ob} \in \textrm{Ty}(1)$ with a
    natural isomorphism
    \[ \textrm{Tm}(!_\Gamma^*\textrm{Ob}) \cong C_{0}(\Gamma) \]
  \item $\mathcal V$ vertical arrows are representable as types if
    there is a type
    \[ \textrm{Tm}(Functor)(\Gamma)(a,b) \cong C_0(\Gamma)(a,b)
    \]
    and similarly horizontal displays are representable as types if
    \[ \textrm{Tm}(Prof)(\Gamma)(a,b) \cong \{ R \in C_d(\Gamma) \,|\, s(R) = a \wedge t(R) = b \}
    \]
  \item Closed $\mathcal V$ transformations are representable as types if
    \[ \textrm{Tm}(\textrm{End})(\Gamma)(a,R) \cong C_\vdash^{\id,\id}(r(a),R) \]
  \end{enumerate}
\end{definition}

We then arrive at our final notion of model by collecting all of this
algebraic structure into one definition.
\begin{definition}
  A hyperdoctrine of equipments with displays (HED) is a pair of a
  category with families $Ctx$ modeling $\Sigma,\Pi,\Id$ and a DCD
  internal to $\Set^{Ctx^o}$ with categories, functors, displays and
  unary cells representable as types.
\end{definition}

This notion of HED is straightforwardly, if laboriously, interpretable
as a GAT.

%% \begin{definition}
%%   Given a well-formed signature $\Gamma$ and a virtual equipment
%%   $\mathcal V$, we mutually define the following notions:

%%   \begin{itemize}
%%   \item The set $\sem{\Gamma}_{\mathcal V}$
%%   \item For any $\Gamma \vdash A$ and $\gamma \in \sem{\Gamma}_{\mathcal V}$, a set $\sem{A}_{\mathcal V} \gamma$
%%   \item For any $\Gamma \vdash M : A$ and $\gamma \in \sem{\Gamma}_{\mathcal V}$, an element $\sem{M}_{\mathcal V} \in \sem{A}_{\mathcal V} \gamma$
%%   \item For any $\Gamma \vdash \cat C \isaCat$ and $\gamma \in \sem{\Gamma}_{\mathcal V}$, an object $\sem{\cat C}_{\mathcal V}\gamma$
%%   \item For any $\Gamma\pipe\alpha:\cat C \vdash a :\cat D$ and $\gamma \in \sem{\Gamma}_{\mathcal V}$, a vertical morphism $\sem{\alpha.a}_{\mathcal V}\gamma \in \mathcal V_v(\sem{\cat C}_{\mathcal V}\gamma, \sem{\cat D}_{\mathcal V}\gamma,)$
%%   \item For any $\Gamma\pipe\Xi \vdash R \isaSet$ and $\gamma \in
%%     \sem{\Gamma}_{\mathcal V}$, a horizontal arrow $\sem{R}_{\mathcal
%%       V}\gamma \in \mathcal V_h$ such that $d^\pm\sem{R}_{\mathcal
%%       V}\gamma = \sem{d^\pm\Xi}_{\mathcal V}\gamma$. We also extend
%%     this in the obvious way to transformation contexts
%%     $\sem{\Phi}_{\mathcal V}\gamma$
%%   \item For any $\Gamma\pipe\Phi \vdash t : R$ and $\gamma \in
%%     \sem{\Gamma}_{\mathcal V}$, a 2-cell $\sem{t}_{\mathcal V}\gamma
%%     \in V_h(\sem{\Phi}_{\mathcal V}\gamma;\sem{R}_{\mathcal V}\gamma)$
%%     with $d^\pm\sem{t}_{\mathcal V}\gamma = \id$.
%%   \end{itemize}
  
%%   %% \begin{align*}
%%   %%   \sem{\cdot}_{\mathcal V} &= 1\\
%%   %%   \sem{\Gamma, x:A}_{\mathcal V} &= \sum_{\gamma \in \sem{\Gamma}_{\mathcal V}} \sem{A}_{\mathcal V}\gamma\\
%%   %% \end{align*}
  
%%   %% with an 
%%   %% \begin{align*}
%%   %%   \sem{\Gamma, x:A}_{\mathcal V} &= \sem{\Gamma}_{\mathcal V} \times \sem{A}_{\mathcal V}\\
%%   %%   \sem{\Gamma}_{\mathcal V} &= 1\\\\
%%   %%   \sem{\Sort}_{\mathcal V} &= \mathcal V_0\\
%%   %%   \sem{\varr{\cat C}{\cat D}}_{\mathcal V} &= \mathcal V_v(\sem{\cat C})
%%   %% \end{align*}
%% \end{definition}

\subsection{Initiality}

In this section we give a sketch of an initiality proof of the syntax
of SCT in HEDs. Note that we consider all the following sets up to
$\alpha$-equivalence of names.

\begin{construction}{Completeness}
  SCT presents a HED with
  \begin{enumerate}
  \item Category with Families provided by the contexts,
    substitutions, types and terms.
  \item Objects of $C_0^\Gamma$ provided by the terms $\Gamma \vdash \cat C \isaCat$
  \item Morphisms of $C_0^\Gamma$ provided by terms $\Gamma
    \alpha:\cat C \vdash b \cat D$ with source $\cat C$ and target
    $\cat D$. With identity given by a variable and composition by identity.
  \item Objects of $C_1^\Gamma$ are provided by the profunctor
    contexts $\Gamma \vdash \Phi \isavectx$ with morphisms given by
    transformation substitutions $\Gamma \pipe \Phi \vdash \psi :
    \Psi$.
  \item Horizontal composition of contexts is defined by gluing along
    a variable $\Phi\jnctx \Psi$ and the horizontal identity is given
    by the single category variable $\alpha:\cat C$.
  \item Objects of $C_\vdash^\Gamma$ are provided by the profunctors
    $\Gamma\alpha:\cat C;\beta:\cat D \vdash R$, and a morphism from
    $\alpha:\cat C;\beta:\cat D \vdash R$ to $\alpha':\cat
    C';\beta':\cat D' \vdash R'$ is a triple $(a,t,b)$ of functor
    terms $\alpha:\cat C \vdash a : \cat C'$ and $\beta:\cat D\vdash b
    : \cat D'$ and a term $\alpha:\cat C,x:R,\beta:\cat D \vdash t :
    R'[a/\alpha';b/\beta']$

    Composition $(a,t,b) \circ (a',t',b') = (a[a'],t[t'],b[b'])$ is
    given by component-wise single-place substitution with the triple
    of all variables the identity.
  \item The inclusion functor $i^\Gamma : C_d \to C_1$ is defined on
    types as the singleton context $i(R) = \alpha:\cat
    C,x:R,\beta:\cat D$ and on morphisms as the singleton
    substitution.
  \item The restriction operation $R \circ (a,b)$ is defined as the
    substitution $R[a;b]$.
  \item The remaining universal properties are satisfied using the
    analogous type theoretic construction.
  \end{enumerate}
\end{construction}\section{Completeness}

%% \begin{figure}
%%   \begin{mathpar}
%%       (\homrallXYtoZ \alpha R P)[\xi] = \homrallXYtoZ \alpha {R[d^+\xi;\alpha/\alpha]} {P[\alpha/\alpha;d^-\xi]}

%%      (\homrlambdaXatYdotZ {x} {\alpha} M)[\phi]
%%       = \homrlambdaXatYdotZ {x} {\alpha} M[\phi,x/x,\gamma/\gamma]

%%      (\homllambdaXatYdotZ {x} {\alpha} M)[\phi]
%%       = \homllambdaXatYdotZ {x} {\alpha} M[\phi,x/x,\gamma/\gamma]


%%   \end{mathpar}
%%   \caption{Substitution}
%% \end{figure
%% }

In this section we establish the most significant portion of the
completeness proof:
\begin{construction}[Double category completeness]
  For any $\Gamma$, define a strict double category as follows
  \begin{enumerate}
  \item Objects are categories $\Gamma \vdash \cat C \isaCat$
  \item Vertical morphisms from $\cat C$ to $\cat D$ are functor/open
    object terms $\Gamma \pipe\alpha:\cat C \vdash B : \cat D$ modulo
    $\alpha$-equivalence.
  \item Horizontal morphisms from $\cat C$ to $\cat D$ are profunctor
    contexts $\Gamma\vdash \Phi \isavectx$ with $d^-\Phi = \cat C$ and
    $d^+\Phi = \cat D$ modulo $\alpha$-equivalence.
  \item Squares from $\Psi$ to $\Phi$ along $A$ and $B$ are
    substitutions $\Gamma \vdash \phi : \Psi \to \Phi$ with $d^-\phi =
    A$ and $d^+\phi = B$ modulo $\alpha$-equivalence.
  \end{enumerate}
\end{construction}
\begin{proof}
  The details are in the linked lemmas. Here we give an overview of
  the relevant structure and properties.
  \begin{enumerate}
  \item Vertical composition is given by substitution of object terms
    and is associative and unital with the variable as the identity
    (Lemma \ref{lem:vertical-cat}).
  \item Horizontal composition is given by the gluing of contexts
    $\Phi\jnctx \Psi$ and is associative and unital with the single
    category variable as the identity (Lemma
    \ref{lem:horizontal-cat}).
  \item Vertical composition of substitutions is given by substitution
    $\phi[\psi]$ and is associative and unital with the identity
    substitution given by a substitution of variables for themselves
    (Lemma \ref{lem:vertical-sq-cat}).
  \item Horizontal composition of substitutions is given by gluing of
    substitutions $\phi \jnctx \psi$ and is associative and unital
    with the identity substitution given by a single functor/open
    object substitution (Lemma \ref{lem:horizontal-sq-cat}).
  \item The process of constructing horizontal identity substitutions
    is functorial in that the horizontal identity of a vertical
    identity arrow is the vertical identity
    (Lemma~\ref{lem:hor-vert-id-id}) and the vertical composition of
    horizontal identities is a horizontal identity
    (Lemma~\ref{lemma:lem-hor-sq-id}).
  \item The process of horizontal composition of substitutions is
    functorial in that the horizontal composition of vertical identity
    squares is the identity (Lemma~\ref{lem:lem-vert-sq-id}) and the
    interchange law holds (Lemma~\ref{lem:interchange}).
  \end{enumerate}
\end{proof}

\begin{lemma}[Vertical category]
  \label{lem:vertical-cat}
  Substitution of object terms $A[B/\beta]$ is associative with
  identity given by the variable $\alpha:\cat C \vdash \alpha:\cat C$.
\end{lemma}

\begin{definition}
  \label{lem:horizontal-cat}
  We define composition of transformation contexts $\Phi \jnctx \Psi$ by induction on $\Psi$
  \begin{align*}
    \Phi \jnctx \beta:\cat D &= \Phi    \\
    \Phi \jnctx \Psi,x:R,\beta:\cat D &= (\Phi\jnctx\Psi),x:R,\beta:\cat D
  \end{align*}
  By induction, this is seen to be associative
  \[ (\Phi \jnctx \Psi) \jnctx \Sigma = \Phi \jnctx (\Psi \jnctx \Sigma) \]
  and unital with identity for $\cat C$ given by the single category
  variable context $\alpha:\cat C$
  \[ \alpha:\cat C \jnctx \Phi = \Phi = \Phi \jnctx \beta:\cat D\]
  when $d^-\Phi = \alpha:\cat C$ and $d^+\Phi = \beta:\cat D$.
\end{definition}

\begin{definition}
  \label{lem:horizontal-sq-cat}
  We define the horizontal composition of transformation substitutions
  $\phi \jnctx \psi$ whenever $d^+\phi = d^-\psi$ by induction on
  $\psi$:
  \begin{align*}
    \phi \jnctx a/\alpha &= \phi\\
    \phi \jnctx (\psi,t/x,a/\alpha) &= (\phi \jnctx \psi),t/x,a/\alpha
  \end{align*}
  By induction, this is seen to be associative
  \[ \phi \jnctx (\psi \jnctx \sigma) = (\phi \jnctx \psi) \jnctx \sigma \]
  and unital with identity given by a single object substitution
  $a/\alpha : \alpha:\cat C \to \beta:\cat D$
  \[ a/\alpha \jnctx \phi = \phi = \phi \jnctx b/\beta \]
  when $d^-\phi = a/\alpha$ and $d^+\phi = b/\beta$.
\end{definition}

To define vertical composition of squares, we need the following lemma.
\begin{lemma}[Inversion]
  \begin{enumerate}
  \item If $\Phi \vdash \psi :: (\alpha:\cat C)$ then $\Phi =
    \beta:\cat D$ for some $\cat D$ and $\psi = a/\alpha$ where
    $\beta:\cat D \vdash a : \cat C$.
  \item If $\Phi \vdash \psi :: \Psi_1 \jnctx \Psi_2$, then there
    exists unique $\Phi_1,\Phi_2,\psi_1,\psi_2$ such that $\Phi =
    \Phi_1\jnctx\Phi_2$ and $\Phi_1\vdash\psi_1 :: \Psi_1$ and
    $\Phi_2\vdash \psi_2 : \Psi_2$ and $\psi = \psi_1\jnctx\psi_2$.
  \end{enumerate}
\end{lemma}

\begin{definition}
  \label{lem:vertical-sq-cat}
  We define the vertical composition of transformation substitutions
  $\phi[\psi]$ inductively on $\phi$.
  \begin{align*}
    (a/\alpha)[b/\beta] &= a[b/\beta]/\alpha\\
    (\phi_1,t/x,a/\alpha)[\psi_1\jnctx\psi_2] &= \phi_1[\psi_1], t[\psi_2],a[d^+\psi_2]
  \end{align*}
  This covers all cases by \cref{inversion}.

  We define the vertical identity $\id_\Phi$ by induction on $\Phi$
  \begin{align*}
    \id_{\alpha:\cat C} &= \alpha/\alpha\\
    \id_{\Phi,x:R,\alpha:\cat C} &= \id_{\Phi},x/x,\alpha/\alpha
  \end{align*}

  By induction this is seen to be associative:
  \[ \phi[\psi][\sigma] = \phi[\psi[\sigma]] \]
  and unital
  \[ \id_{\Phi}[\phi] = \phi = \phi[\id_{\Psi}] \]
\end{definition}

\begin{lemma}
  \label{lem:sq-vid-hid}
  For any $\cat C$, $\alpha/\alpha : \alpha:\cat C \to \alpha:\cat C$
  is both a horizontal and vertical identity.
\end{lemma}

\begin{lemma}
  \label{lem:sq-vcomp-hid}
  For any $\beta:\cat D \vdash a : \cat C$ and $\alpha:\cat C \vdash a': \cat C'$
  the substitution
  \[ (a'/\alpha')[a/\alpha] : \beta:\cat D \to \alpha':\cat C' \]
  satisfies
  \[ (a'/\alpha')[a/\alpha] = a'[a/\alpha]/\alpha' \]
\end{lemma}

\begin{lemma}
  \label{lem:sq-vid-hcomp}
  For any $\Phi$ and $\Psi$ with $\Phi\jnctx \Psi$ well-defined,
  \[ \id_\Phi \jnctx \id_\Psi = \id_{\Phi\jnctx\Psi} \]
  follows by induction.
\end{lemma}

\begin{lemma}{Interchange}
  \label{lem:sq-vcomp-hcomp}
  We prove the interchange law
  $$(\phi\jnctx\psi)[\phi'\jnctx\psi'] = \phi[\phi'] \jnctx \psi[\psi']$$
  by induction on $\psi$.

  \begin{enumerate}
  \item When $\psi=a/\alpha$
      \begin{align*}
    (\phi\jnctx a/\alpha)[\phi'\jnctx b/\beta]
        &= \phi[\phi']\\
        &= \phi[\phi'] \jnctx (a[b/\beta]/\alpha)\\
        &= \phi[\phi'] \jnctx (a/\alpha)[b/\beta]
  \end{align*}
    \item When $\psi=\psi,t/x,a/\alpha$
      \begin{align*}
        (\phi\jnctx (\psi,t/x,a/\alpha))[\phi' \jnctx (\psi'_1\jnctx\psi'_2)]
        &= ((\phi\jnctx \psi),t/x,a/\alpha)[(\phi' \jnctx \psi'_1)\jnctx\psi'_2]\\
        &= (\phi\jnctx \psi)[\phi' \jnctx \psi'_1],t[\psi'_2]/x,a[d^+\psi'_2]/\alpha\\
        &= (\phi[\psi'] \jnctx \psi[\psi'_1]),t[\psi'_2]/x,a[d^+\psi'_2]/\alpha\\
        &= \phi[\psi'] \jnctx (\psi[\psi'_1],t[\psi'_2]/x,a[d^+\psi'_2]/\alpha)\\
        &= \phi[\psi'] \jnctx (\psi,t/x,a/\alpha)[\psi'_1\jnctx \psi'_2]
      \end{align*}
  \end{enumerate}
  Again, this covers all cases by \cref{inversion}.
\end{lemma}

\begin{figure}
  \begin{mathpar}
    % vertical arrows
    \inferrule*[Right=VComp*]
    {\alpha:\cat C \vdash b : \cat D \and
     \beta:\cat D \vdash c : \cat E}
    {\alpha:\cat C \vdash c[b/\beta] : \cat E}\\

    \beta[b/\beta] = b\and
    c[\beta/\beta] = c\and
    c[b/\beta][a/\alpha] = c[b[a/\alpha]/\beta]\\

    % horizontal arrows
    \inferrule*[Right=HComp*]
    {\Gamma \vdash \Phi \isavectx\\\\
      \Gamma\vdash\Psi\isavectx\\\\
      d^+\Phi = d^-\Psi}
    {\Gamma \vdash \Phi \jnctx \Psi \isavectx}

    d^+(\Phi \jnctx \Psi) = d^+\Psi\and
    d^-(\Phi \jnctx \Psi) = d^-\Phi\\

    \Phi \jnctx (d^+\Phi) = \Phi \and
    (d^-\Phi) \jnctx \Phi = \Phi \and
    (\Phi \jnctx \Psi) \jnctx \Sigma = \Phi \jnctx (\Psi \jnctx \Sigma)\\

    % 2-cells
    %% vertical composition
    \inferrule*[Right=V2Comp*]
    {\Sigma \vdash \psi :: \Psi \and
     \Psi \vdash \phi :: \Phi}
    {\Sigma \vdash \phi[\psi] :: \Phi}

    \inferrule*[Right=V2Id*]
    {}
    {\Phi \vdash \id_\Phi :: \Phi}\\

    \id_\Phi[\phi] = \phi\and
    \phi[\id_\Psi] = \phi\and
    \phi[\psi][\sigma] = \phi[\psi[\sigma]]\\

    %% Horizontal composition
    \inferrule*[Right=H2Comp*]
    {\Phi' \vdash \phi :: \Phi \\\\
     \Psi' \vdash \psi :: \Psi \\\\
     d^+\phi = d^-\psi 
    }
    {\Phi' \jnctx \Psi' \vdash \phi \jnctx \psi :: \Phi \jnctx \Psi}

    d^-(\phi\jnctx\psi) = d^-\phi\and
    d^+(\phi\jnctx\psi) = d^+\phi\and
    
    \phi\jnctx d^+\phi = \phi\and
    d^-\phi \jnctx \phi = \phi\and
    \phi\jnctx(\psi\jnctx\sigma) = (\phi\jnctx\psi)\jnctx\sigma

    %% Interchange
    \inferrule*[Right=Interchange]
    {\Phi'' \vdash \phi' :: \Phi' \and
     \Psi'' \vdash \psi' :: \Psi' \and
     d^+\phi' = d^-\psi'\\\\
     \Phi' \vdash \phi :: \Phi \and
     \Psi' \vdash \psi :: \Psi \and
     d^+\phi = d^-\psi
    }
    {(\phi\jnctx\psi)[\phi'\jnctx\psi'] = \phi[\phi'] \jnctx \psi[\psi']}\\
    
    % Interaction with displays
    \inferrule
    {\Psi \vdash \phi :: \Phi\and
     \Phi \vdash t : R[a/\alpha;b/\beta]}
    {\Psi\vdash t[\phi] : R[a[d^-\phi]/\alpha;b[d^+\phi]/\beta]}

    t[\id_\Phi] = t\and
    t[\phi][\psi] = t[\phi[\psi]]
  \end{mathpar}
  \caption{Syntactic Double Category with Displays Structure}
\end{figure}

\section{Soundness}

We next show how to uniquely interpret the profunctor contexts and
substitutions in an arbitrary HED.

\begin{proof}
  We sketch only the interpretation of profunctor contexts in $C_1$,
  as the rest is a straightforward translation from type theoretic to
  categorical syntax.  We define the translation of a context
  $\sem{\Phi}$ by induction on $\Phi$:

  \begin{align*}
    \sem{\alpha:\cat C} &= \sem{\id^h(\cat C)}\\
    &= \id^h(\sem{\cat C})\\\\
    \sem{\Phi , x:R, \beta:\cat C}\\
    &= \sem{\Phi \circ_h i(R)}\\
    &= \sem{\Phi} \sem{\Phi} \circ_h i(\sem{R})
  \end{align*}
  As these derivations show every step was uniquely determined by the
  homomorphism property. Preservation of identity follows by
  definition. Preservation of composition $\sem{\Phi \jnctx \Psi} =
  \sem{\Phi} \circ_h \sem{\Psi}$ follows by induction on $\Psi$:
  \begin{align*}
    \sem{\Phi \jnctx (\alpha:\cat C)} &= \sem{\Phi} = \sem{\Phi} \circ_h \sem{\id(C)}\\
    \sem{\Phi \jnctx (\Psi,x:R,\alpha:\cat C)}
    &= \sem{(\Phi \jnctx \Psi),x:R,\alpha:\cat C} \\
    &= \sem{(\Phi \jnctx \Psi)} \circ_h i(\sem{R})\\
    &= (\sem{\Phi} \circ_h \sem{\Psi}) \circ_h i(\sem{R})\\
    &= \sem{\Phi} \circ_h (\sem{\Psi} \circ_h i(\sem{R}))\\
    &= \sem{\Phi} \circ_h \sem{\Psi, x:R, \alpha:\cat C}
  \end{align*}
  The interpretation of transformation substitutions is analogous.
\end{proof}

\section{Extended Synthetic Category Theory}

Next, we look at synthetic category theory constructions in SCT.

\subsection{Profunctor Isomorphisms}

We start our study of synthetic category theory constructions with
some isomorphisms that show the interaction between the 5
multiplicative connectives: right/left hom, end, unit and tensor.

First, we fix some terminology
\begin{lemma}
  Let $P, Q : \harr {\cat C} {\cat D}$.
  A homomorphism from $P$ to $Q$ is a term of type
  \[ \homunary {\alpha} {\harrapp P \alpha \beta} {\beta} {\harrapp Q \alpha \beta} \]
  Given homomorphisms $M : P \multimap Q$, $N : Q \multimap R$ we can define their composite as
  \[ (N \circ M) = \lambdaunary {\alpha} {x:\harrapp P \alpha \beta} \beta {\appunary \alpha N \beta {\appunary \alpha M \beta x}} \]
  This notion of composition is associative and unital using the
  $\beta\eta$ equations for the end/right hom connectives, with unit
  $\lambdaunary {\alpha} x \beta x$.

  An isomorphism between $P, Q : \harr {\cat C}{\cat D}$ is then a
  homomorphism $P \multimap Q$ with an inverse $Q \multimap P$.
\end{lemma}

Our first synthetic theorem is that we have that the unit, i.e., the
hom set, is the unit for tensor and hom.
%
The theorem for hom is the synthetic \emph{Yoneda lemma} and the
theorem for tensor is the synthetic \emph{Co-Yoneda lemma}.
\begin{lemma}[{Yoneda and Co-Yoneda}]
  \label{lem:yo-and-co-yo}
  Let $P : \harr {\cat C} {\cat D}$.

  For any $\gamma : \cat E \vdash b : \cat D$, the following are naturally isomorphic to $\harrapp P \alpha b$:
  \begin{enumerate}
  \item $\homrallXYtoZ {\beta} {(\punitinXfromYtoZ {D} {\beta} {b})} {\harrapp P {\alpha} {\beta}}$
  \item $\tensorexistsXwithYandZ {\beta} {\harrapp P \alpha {\beta}} {(\punitinXfromYtoZ {\cat D} {\beta} {b})}$
  \end{enumerate}

  For any $\gamma : \cat E \vdash a : \cat C$, the following are naturally isomorphic to $\harrapp P a \beta$:
  \begin{enumerate}
  \item $\homlallXYtoZ {{\alpha}} {(\punitinXfromYtoZ {C} {\alpha} {a})} {\harrapp P {{\alpha}} {\beta}}$
  \item $\tensorexistsXwithYandZ {\alpha} {(\punitinXfromYtoZ {C} {a} {\alpha})} {\harrapp P {\alpha}{\beta}}$
  \end{enumerate}
\end{lemma}
\begin{proof}
  TODO: what's better, build the substitution in or prove the
  substitution can be built in afterwards? The one building in the
  substitution obscures the connection to the normal tensor/hom/unit
  relationship, but the one with the built in subst is obviously more
  general.
\end{proof}

Next, we have various associativities between the homs, tensor and end
constructions. Semantically, these are related to so-called
\emph{Fubini} theorems about interchange of (co)-ends.
\begin{lemma}[{Fubini}]
  \label{lem:fubini}
  The following isomorphisms hold for any $P : \harr {\cat C}{\cat D},
  P' : \harr {\cat C}{\cat D} Q :\harr {\cat D}{\cat E}, R : \harr
  {\cat E} {\cat F}, S : \harr {\cat C} {\cat E}$. where $\alpha:\cat
  C, \beta:\cat D, \gamma : \cat E, \delta: \cat F$
  \begin{enumerate}
  \item $\tensorexistsXwithYandZ {\beta} {\harrapp P \alpha \beta} {(\tensorexistsXwithYandZ \gamma {\harrapp Q \beta \gamma} {\harrapp R \gamma \delta})} \cong \tensorexistsXwithYandZ {\gamma} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp R \gamma \delta}$
  \item $\homrallXYtoZ {\gamma} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp S \alpha \gamma} \cong \homrallXYtoZ \beta {\harrapp P \alpha \beta} {\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {\harrapp S \alpha \gamma}}$
  \item $\homlallXYtoZ {\alpha} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp S \alpha \gamma} \cong \homlallXYtoZ \beta {\harrapp Q \beta \gamma} {\homlallXYtoZ \alpha {\harrapp P \alpha \beta} {\harrapp S \alpha \gamma}}$
  \item $\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {(\homlallXYtoZ \alpha {\harrapp P \alpha \beta} {\harrapp S \alpha \gamma})} \cong \homlallXYtoZ \alpha {\harrapp P \alpha \beta} {(\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {\harrapp S \alpha \gamma})}$
  \item $\pendallXdotY \alpha \homrallXYtoZ \beta P {P'} \cong \pendallXdotY \beta \homlallXYtoZ \alpha P {P'}$
  \end{enumerate}  
\end{lemma}
\begin{proof}
  TODO
\end{proof}
\subsection{Composition, Functoriality, Profunctoriality, Naturality}

Hom sets don't provide primitive syntax for composition of morphisms
in a category. As our first synthetic construction, we can
\emph{define} composition using the elimination form for the unit.
%
\begin{definition}[Composition of Morphisms]
  We define composition of morphisms as the following term of type $\Pi_{\cat C:\Cat}\hombinary {\alpha_1} {\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_2}} {\alpha_2} {\punitinXfromYtoZ {\cat C}{\alpha_2} {\alpha_3}} {\alpha_3} {\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_3}}$:
  \[
  \lambda \cat C. \punitelimtoYwithkontZ {\hlambda {\alpha_1}{\alpha_2} \homrallXYtoZ {\alpha_3} {\punitinXfromYtoZ {\cat C} {\alpha_2} {\alpha_3}} {\punitinXfromYtoZ {\cat C} {\alpha_1} {\alpha_3}}} {\lambdaunary {\alpha} {f : \punitinXfromYtoZ {\cat C}{\alpha} {\alpha_3}} {\alpha_3} f}
  \]
  We call this term $\textrm{comp}$
\end{definition}
This has the same flavor as a directed type theory: to construct the
composite it is sufficient to define the action on the identity
morphism, which is of course the identity for composition.
%
Note that we gave a slight bias to the definition to follow by
induction on the \emph{first} function, whereas we could make the
following alternative definition, naturally of type
$\pendallXdotY {\alpha_2} \homrallXYtoZ {\alpha_3} {\punitinXfromYtoZ {\cat C}{\alpha_2} {\alpha_3}}
{(\homlallXYtoZ {{\alpha_1}} {\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_2}}{\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_3}})}$:
\[
  \punitelimtoYwithkontZ {\hlambda {\alpha_2}{\alpha_3} \homlallXYtoZ {{\alpha_1}} {\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_2}}{\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_3}} } {\lambdaunary {\alpha} {g : \punitinXfromYtoZ {\cat C}{\alpha_1}{\alpha}} {\alpha} g}
\]

\begin{lemma}[Equivalence of Composition Definitions]
  TODO
\end{lemma}

It should follow by $\beta\eta$ that this is associative and unital.

Next, let's prove synthetically that every functor $F : \varr{\cat
  C}{\cat D}$ is functorial in this notion of composition.
\begin{definition}
  For any $F : \varr {\cat C} {\cat D}$, we can define a morphism $F_1
  : \homunary {\alpha_1} {\punitinXfromYtoZ {\cat C} {\alpha_1}
    {\alpha_2}} {\alpha_2} {\punitinXfromYtoZ {\cat D} {F \alpha_1}
    {F \alpha_2}}$ as
  \[ F_1 = \punitelimtoYwithkontZ {\hlambda {\alpha_1}{\alpha_2} \punitinXfromYtoZ {\cat D} {F \alpha_1}{F \alpha_2}}
  {\pendlambdaXdotY \alpha \punitrefl {\cat D} {F \alpha}}
  \]
  Note that
  \[ A[\id_\alpha/\alpha] = \id_{A} \]
  \[ A[f;g] = A[f];A[g] \]
\end{definition}
Note the similarity to the proof that all functions are congruences in
MLTT/HoTT.

And similarly, every profunctor $R : \harr {\cat C}{\cat D}$ is
\emph{pro-functorial}.
\begin{definition}
  For any $R : \varr {\cat C} {\cat D}$, we can define left and right
  actions of composition:
  \[ \homunary {\alpha_1} {\tensorexistsXwithYandZ {\alpha_2} {(\punitinXfromYtoZ {\cat C} {\alpha_1}{\alpha_2})} {\tensorexistsXwithYandZ {\alpha_3} {(\harrapp R {\alpha_2} {\alpha_3})}}{(\punitinXfromYtoZ {\cat C} {\alpha_3}{\alpha_4})}} {\alpha_4} {\harrapp R {\alpha_1}{\alpha_4}}
  \]
  Furthermore we can show that they are functorial in that the induced functions
  TODO
  are equal
\end{definition}

Next we can define natural transformations as specific kinds of terms
whose type is $\pendallXdotY {\alpha} \punitinXfromYtoZ {\cat D} {F
  \alpha}{G \alpha}$. In fact we can generalize this to any
endo-profunctor $P$:
\begin{definition}[Natural element]
  A natural element of an endo-profunctor $P : \harr {\cat C}{\cat C}$
  is a term of type $\pendallXdotY {\alpha} \harrapp P \alpha \alpha$.

  A natural transformation is the special case where $P =
  \punitinXfromYtoZ {\cat D} {F \alpha}{G \alpha}$ for functors $F, G
  : \varr {\cat C}{\cat D}$.

  This is natural in the sense that the incuded terms
  \[ \homunary {\alpha_1}{\punitinXfromYtoZ {} {\alpha_1}{\alpha_2}} {\alpha_2} {\harrapp P {\alpha_1}{\alpha_2}}  \]
  and
  \[ \pendallXdotY {\alpha_2} \homlallXYtoZ {\alpha_1} {\punitinXfromYtoZ {} {\alpha_1}{\alpha_2}} {\harrapp P {\alpha_1}{\alpha_2}}\]

  are equal under the associativity equivalence between these two
  types.
\end{definition}

\subsection{Yoneda Lemma and Representable Presheaves}

Given any category $\cat C$, we can define the positive and negative
Yoneda embeddings $Y^\pm : \cat C \to \pmPresheaf {\cat C}$ using the
hom profunctor. Note that both of these functors are covariant in
$\cat C$, so semantically, $\posPresheaf {\cat C}$ should be
interpreted as $(\Set^{\cat C})^o$.

\begin{definition}
  Define the negative Yoneda embedding $Y^-[\alpha]$
  \[ \alpha:\cat C \vdash Y^-[\alpha] = \lambda \alpha':\cat C. \punitinXfromYtoZ {\cat C}{\alpha'}{\alpha} : \negPresheaf {\cat C} \]

  The positive Yoneda embedding is defined similarly $Y^+[\alpha]$.
\end{definition}

The Yoneda lemma says that the set of natural transformations from
$Y^-[\alpha]$ to a presheaf $p$ is naturally isomorphic to the
elements of the presheaf itself: $\negPresheafApp \alpha p$. In
encoding this statement in our type theory, we find that we can use
two different interpretations of ``natural transformations''.

On the one hand, a natural transformation should be a morphism in the
presheaf category. This interpretation of the Yoneda lemma would mean
that we have a natural isomorphism of profunctors:
\[ \alpha:\cat C; \pi:\negPresheaf {\cat C} \vdash \punitinXfromYtoZ{\negPresheaf {\cat C}} {Y^-[\alpha]} {\pi} \cong \negPresheafApp \alpha \pi \]
Attempting to prove this we become stuck very quickly because we know
nothing about the structure of morphisms in the presheaf category.

On the other hand, a natural transformation of presheaves $\pi$ and
$\rho$ can be defined as a family of functions from $\negPresheafApp
\alpha \pi$ to $\negPresheafApp \alpha \rho$, or in other words as an
\emph{end}. Specializing to the Yoneda lemma, we interpret ``a natural
transformation from $Y^-[\alpha]$ to $\pi$'' as the following, which simplifies using $\beta$ reduction:
\[ \alpha:\cat C; \pi:\negPresheaf {\cat C} \vdash \homrallXYtoZ {\alpha':\cat C} {\negPresheafApp {\alpha'} {Y^-[\alpha]}}{\negPresheafApp {\alpha'} \pi} = \homrallXYtoZ {\alpha':\cat C} {(\punitinXfromYtoZ {\cat C}{\alpha'}{\alpha})}{(\negPresheafApp {\alpha'} \pi)} \]
And then the Yoneda lemma becomes:
\[ \alpha:\cat C; \pi:\negPresheaf {\cat C} \vdash \homrallXYtoZ {\alpha':\cat C} {(\punitinXfromYtoZ {\cat C}{\alpha'}{\alpha})}{(\negPresheafApp {\alpha'} \pi)} \cong \negPresheafApp \alpha \pi\]
Which is an instance of our earlier Lemma\,\ref{lem:yo-and-co-yo}
which follows quite easily.

Then we are left with the question of whether these two forms of the
Yoneda lemma are equivalent, or slightly more generally are these two definitions of natural transformation of presheaves equivalent:
\[ \rho:\negPresheaf{\cat C}; \pi:\negPresheaf {\cat C} \vdash \punitinXfromYtoZ{\negPresheaf {\cat C}} {\rho} {\pi} \]
and
\[ \rho:\negPresheaf{\cat C}; \pi:\negPresheaf {\cat C} \vdash \homrallXYtoZ {\alpha:\cat C} {\negPresheafApp \alpha \rho}{\negPresheafApp \alpha \pi} \]
While we can show that there is a morphism from the hom set to the
end, the inverse does not seem provable, and seems analogous to the
\emph{univalence} axiom in homotopy type theory, as it tells us that
the morphisms of the universe are given by a particular kind of
function in our logic.

\subsection{Adjoint Functors and Representable Profunctors}

Next, we demonstrate that the two common definitions of adjoint
functors are equivalent: isomorphism of hom-sets and units and
co-units.
%
The proof goes through most easily, and utilizes duality most
effectively, if we factorize the construction through an intermediate
notion of when a functor \emph{represents} a profunctor.

\begin{definition}[Functor Represents a Profunctor]
  A functor $G : \varr{\cat D}{\cat C}$ right-represents a profunctor $R :
  \harr {\cat C}{\cat D}$ when there is an isomorphism of profunctors:
  \[ \punitinXfromYtoZ {\cat C} {\alpha} {G \beta} \cong \harrapp R {\alpha}{\beta}\]

  We say a functor $F : \varr{\cat C}{\cat D}$ \emph{left-represents} a profunctor $R : \harr {\cat C}{\cat D}$ when there is an isomorphism of profunctors
  \[ \punitinXfromYtoZ {\cat D} {F \alpha} {\beta} \cong \harrapp R {\alpha}{\beta}\]
\end{definition}

This is a parameterized generalization of the notion of an object
representing a functor $R : C^{op} \to Set$.
These notions are precisely dual. $F$ left-represents a profunctor $R$
precisely if it right-represents it in the opposite SCT.

Note that trivially any functor $G$ right-represents
$\hlambda\alpha\beta \punitinXfromYtoZ {\cat D}{\alpha} {G \beta}$ and
dually, any functor $F$ left-represents
$\hlambda\alpha\beta\punitinXfromYtoZ {\cat C}{F\alpha}{\beta}$.

Then we can show that any right-representation isomorphism is
determined by a co-unit:
\begin{lemma}[(Co)-unit of a Representation]
  If $G: \varr {\cat D}{\cat C}$ right-represents $R : \harr {\cat
    C}{\cat D}$, then there is a natural element, the co-unit:
  \[ \pendallXdotY \beta \harrapp R {G\beta} \beta \]
  Such that the half of the isomorphism 
  \[ \punitinXfromYtoZ {\cat C} {\alpha} {G \beta} \multimap \harrapp R {\alpha}{\beta} \]
  is defined by composition with the natural element.

  Dually, any $F$ left-representing isomorphism with $R$ is determined
  by a ``unit'' of type $\pendallXdotY \alpha \harrapp R {\alpha}
  {F\alpha}$.
\end{lemma}
\begin{proof}
  A homomorphism $\punitinXfromYtoZ {\cat C} {\alpha} {G \beta} \multimap \harrapp R {\alpha}{\beta}$ is by definition a term of type
  \[ \pendallXdotY \alpha \homrallXYtoZ {\beta} {(\punitinXfromYtoZ {\cat C} \alpha {G \beta})} {\harrapp R \alpha \beta} \]
  By \cref{lem:fubini}, this type is isomorphic to 
  \[ \pendallXdotY \beta \homlallXYtoZ {\alpha} {(\punitinXfromYtoZ {\cat C} \alpha {G \beta})} {\harrapp R \alpha \beta} \]
  By \cref{lem:yo-and-co-yo}, this type is isomorphic to
  \[ \pendallXdotY \beta {{\harrapp R {(G \beta)} \beta}} \]

  Therefore this half of the isomorphism is determined by a natural
  element. The construction in the proof of \cref{lem:yo-and-co-yo} is
  indeed by composition (i.e., unit elimination).

  The $F$ case is precisely dual.
\end{proof}

Combining these two, we get the unit-counit definition for adjoint
functors

\begin{definition}[Adjunction by unit/co-unit]
  We say $G : \varr {\cat D}{\cat C}$ is right adjoint to $F : \varr
  {\cat C}{\cat D}$ if there is a unit
  \[ \eta : \pendallXdotY \alpha \punitinXfromYtoZ \alpha {G(F(\alpha))}\]
  and a co-unit
  \[ \epsilon : \pendallXdotY \beta \punitinXfromYtoZ {F(G(\beta))} \beta \]

  satisfying the triangle identities...
  \[ \id_{R[\beta]} = R[\epsilon_{\beta}] \circ \eta_{R[\beta]} \]
  \[ \id_{L[\alpha]} = \epsilon_{L[\alpha]} \circ L[\eta_{\alpha}] \]
\end{definition}

\begin{theorem}[Adjunctions]
  $G$ is right adjoint to $F$ if and only if there is a natural isomorphism
  $\punitinXfromYtoZ {\cat D} {(F \alpha)} \beta \cong \punitinXfromYtoZ {\cat D} \alpha {G \beta}$
\end{theorem}
\begin{proof}
  First, by \cref{lem:co-unit}, the forward direction of the
  isomorphism is equivalent to providing a term
  \[ \eta : \pendallXdotY \alpha \punitinXfromYtoZ \alpha {G(F(\alpha)) } \]

  Second, the backward direction of the isomorphism is equivalent to
  providing a term
  \[ \epsilon : \pendallXdotY \beta \punitinXfromYtoZ {F(G(\beta))} \beta \]

  And the triangle laws state exactly that the induced functions are
  isomorphisms.
\end{proof}

\subsection{Kan Extensions/Lifts}

As a further example of the synthetic approach to universal
properties, we consider right and left \emph{Kan extensions}, which
are generalizations of limits and colimits, respectively.

The right Kan extension of $F$ along $J$ is the ``best'' (maximal) way to
fill in the following square:
\[% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAGEQBfU9TXfIRQBGclVqMWbACLdeIDNjwEiZYePrNWiDgHJu4mFADm8IqABmAJwgBbJGRA4ISAEzVNUnQCk5lm-aIjs5IohJabABiBlxAA
\begin{tikzcd}
\cat C \arrow[d, "J"] \arrow[r, "F"] & \cat D \\
\cat C'                              &  
\end{tikzcd}\]
I.e. a functor $\textrm{Ran}_J F : \cat C' \to \cat D$ with a
universal natural transformation $\textrm{Ran}_J F \circ J \Rightarrow
F$. A left kan extension $\textrm{Lan}_J F$ is the same but with a
natural transformation $F \Rightarrow \textrm{Lan}_J F \circ J $.

We can express the concept in SCT as representing a certain profunctor
constructed using the profunctor hom:
\begin{definition}[Kan Extensions]
  Given functors $F : \varr {\cat C}{\cat D}$ and $J : \varr {\cat
    C}{\cat C'}$, a right Kan extension is a functor $\textrm{Ran}_J F
  : \varr {\cat C'}{\cat D} $that right-represents the profunctor
  \[ \hlambda {\beta:\cat D}{\alpha': \cat C} \homrallXYtoZ {\alpha}{(\punitinXfromYtoZ {\cat C'}{\alpha'}{J\alpha})} {\punitinXfromYtoZ {\cat D}{\beta}{F \alpha}} \]

  A left Kan extensions is a functor $\textrm{Lan}_J F : \varr {\cat
    C'}{\cat D}$ is a functor satisfying the dual property: it
  \emph{left}-represents the profunctor
  \[\hlambda {\alpha':\cat C}{\beta:\cat D} \homlallXYtoZ {\alpha}{(\punitinXfromYtoZ {\cat C'}{J\alpha}{\alpha'})} {\punitinXfromYtoZ {\cat D}{F \alpha}{\beta}}
  \]
\end{definition}

The limit of a functor $F : \varr{\cat C}{\cat D}$ is a special case
of a Kan extension where $J : \varr{\cat C}{1}$ is the unique functor
to the terminal category. Similarly, the colimit of $F$ is the left
Kan extension with respect to the same $J$.
%
Specializing to this case, the representability for limits means:
\[ \punitinXfromYtoZ {\cat D}{\beta}{\textrm{lim} F} \cong \homrallXYtoZ {\alpha}{(\punitinXfromYtoZ {\cat 1}{\alpha'}{()})}{\punitinXfromYtoZ {\cat D}{\beta}{F \alpha}} \]
And if we view a morphism in $\cat 1$ as being trivial, then this
essentially states that mapping $\beta$ to $\textrm{lim} F$ is the
same thing as constructing a cone: for all $\alpha :\cat C$, a
morphism from $\beta$ to $F \alpha$, naturally in $\alpha$.

The usual formulation of Kan extensions is in terms of a universal
morphism.
%
We can reproduce this formulation using our established theory of
equivalences for homs of profunctors.
\begin{lemma}
  One half of the representability isomorphism for a right Kan
  extension $\textrm{Ran}_J F$ is determined by a natural
  transformation
  \[ \pendallXdotY \alpha \punitinXfromYtoZ {\cat D}{(\textrm{Ran}_JF)(J\alpha)}{F\alpha} \]

  Dually, one half of the representability isomorphism for a left Kan
  extension $\textrm{Lan}_J F$ is determined by a natural
  transformation
  \[ \pendallXdotY \alpha \punitinXfromYtoZ {\cat D}{F\alpha}{(\textrm{Lan}_JF)(J\alpha)} \]
\end{lemma}
\begin{proof}
  By \cref{lem:unit-repr}, one half of representability is determined by a natural element
  \[ \pendallXdotY {\alpha'} \homrallXYtoZ {\alpha}{(\punitinXfromYtoZ {\cat C'}{\alpha'}{J\alpha})} {\punitinXfromYtoZ {\cat D}{(\textrm{Ran}_J F)\alpha'}{F \alpha}} \]
  which, by \cref{lem:fubini} is isomorphic to
  \[
  \pendallXdotY {\alpha} \homlallXYtoZ {\alpha'}{(\punitinXfromYtoZ {\cat C'}{\alpha'}{J\alpha})}{\punitinXfromYtoZ {\cat D}{(\textrm{Ran}_J F)\alpha'}{F \alpha}}
  \]
  which, by \cref{lem:yo-and-co-yo}, is isomorphic to 
  \[ \pendallXdotY \alpha \punitinXfromYtoZ {\cat D}{(\textrm{Ran}_JF)(J\alpha)}{F\alpha} \]
  by taking $P = \hlambda {\alpha'}{\alpha} {\punitinXfromYtoZ {\cat D}{(\textrm{Ran}_J F)\alpha'}{F \alpha}}$.

  The proof for left Kan extensions follows by \cref{lem:duality}.
\end{proof}

With the definition based on representability, we can easily prove the
generalization of the famous theorem, that right adjoints preserve not
just limits but all right Kan extensions

\begin{theorem}[Right/Left Adjoints preserve Right/Left Kan Extensions]
  Let $K : \varr{\cat C}{\cat D}$ and $J : \varr{\cat C}{\cat C'}$.

  If the right Kan extension $\textrm{Ran}_J K$ exists, and if $G :
  \varr {\cat D}{\cat D'}$ has a left adjoint $F : \varr{\cat D'}{\cat
    D}$, then the right Kan extension $\textrm{Ran}_J G\circ K$ exists
  and is given by $G \circ \textrm{Ran}_J K$.

  Similarly, if the left Kan extension $\textrm{Lan}_J K$ exists and
  if $F : \varr{\cat D}{\cat D'}$ has a right adjoint $G : \varr{\cat
    D'}{\cat D}$, then the left Kan extension $\textrm{Lan}_J F\circ
  K$ exists and is given by $F \circ \textrm{Ran}_J K$.
\end{theorem}
\begin{proof}
  By the composition of the following natural isomorphisms:
  \begin{align*}
    \punitinXfromYtoZ {\cat D'} {\beta'} {G ((\textrm{Ran}_J K) \alpha')} &\cong \punitinXfromYtoZ {\cat D}{F \beta'} {(\textrm{Ran}_J K) \alpha'} \tag{Adjunction}\\
    &\cong \homrallXYtoZ {\alpha}{(\punitinXfromYtoZ {\cat C'}{\alpha'}{J\alpha})} {\punitinXfromYtoZ {\cat D}{F \beta'}{K \alpha}} \tag{Ran assumption, \cref{lem:natural-restriction}}\\
    &\cong \homrallXYtoZ {\alpha}{(\punitinXfromYtoZ {\cat C'}{\alpha'}{J\alpha})} {\punitinXfromYtoZ {\cat D}{\beta'}{G(K \alpha)}} \tag{Adjunction}\\
  \end{align*}
\end{proof}

\subsection{(op)-Fibrations}

A (Street) fibration can be defined in any 2-category. A functor $p :
\varr {\cat E}{\cat B}$ is a fibration when the morphism $p \to \cat
B/p$ in the slice 2-category over $\cat B$ has a right adjoint.

Since we can define all of the components of this slice 2-category we
can internalize this definition in SCT.

\begin{enumerate}
\item A functor $\textrm{wp} : \exists (\alpha:\cat B; \beta:\cat E). \punitinXfromYtoZ {\cat B} \alpha {p\beta}$
\item In the slice category: $p(\textrm{wp}(k)) = \pi_-k$
\item With a universal morphism $\epsilon : \pendallXdotY {k} \punitinXfromYtoZ {} {(\pi_-k,k,\punitrefl{}{\pi_-k})} {k}$
\item In the slice category: $\pi_k \epsilon = \id$ (how to express this nicely in SCT?)
\end{enumerate}

We can also weaken this to a Street fibration if we require the more sensible $p(\textrm{wp}(k)) \cong \pi_-k$ only.

\begin{lemma}{Fibrations compose}
  If $F : \varr{\cat C}{\cat D}$ and $G : \varr{\cat D}{\cat E}$ are
  (op)-fibrations then so is $G \circ F$.
\end{lemma}
\begin{proof}
  By composition of adjoints.
\end{proof}

\begin{lemma}{Fibrations are Stable under Pullback}
  
\end{lemma}

\subsection{Duality Principle}



TODO: example of applying the principle in our calculus.

\subsection{Formal Type Theory}

Since many type theories are given semantics by free structured
categories, we can use SCT as a logical framework in which to do
``formal type theory'' by axiomatizing the structure of the categories
involved. The theories we can define are limited because we do not
have access to opposite categories, but we can define some modal and
monoidal structures.

\begin{definition}
  An \emph{SCT-signature} is a well-formed context $\Gamma \isadtctx$.
\end{definition}

\begin{lemma}
  Any \emph{unary mode theory} can be defined as an SCT-signature as follows.
  \begin{enumerate}
  \item For each mode $m$ add an assumption $m : \Cat$
  \item For each 1-morphism $f : m \to n$ add an assumption $R_f :
    \harr m n$ and assumptions $F_f : \varr m n$ with and $G_f : \varr
    n m$ with assumptions that they represent $R_f$.
  \item For each 2-morphism $\alpha : f \Rightarrow g$ add an assumption $\alpha : R_f \multimap R_g$
  \item Add each equality as an assumption using the identity type Id.
  \end{enumerate}
\end{lemma}

This translation illustrates some ways the notion of SCT-signature is
more flexible than a mode theory. For instance, in an SCT-signature we
can add a profunctor assumption $R_f : \harr m n$ without saying
whether it is representable as $F_f$ or $G_f$, and we can add more
complex 2-morphisms.

\begin{definition}
  The \emph{theory of a strict monoidal category} consists of
  \begin{enumerate}
  \item A category $C : \Cat$
  \item A unit $I : \varr 1 C$
  \item A tensor product $\otimes : \varr {(C \times C)} C$
  \item Such that $\alpha:(C \times C) \times C \vdash (\pi_2\pi_1\alpha \otimes \pi_2\pi_1 \alpha) \otimes \pi_2 \alpha = \pi_2\pi_1\alpha \otimes (\pi_2\pi_1 \alpha \otimes \pi_2 \alpha)$
    and $\alpha \otimes I() = \alpha = I() \otimes \alpha$
  \end{enumerate}
\end{definition}

\begin{definition}
  The theory of a cartesian strict monoidal category is an extension
  of the theory of a strict monoidal category with representability
  data
  \[ \punitinXfromYtoZ {C} {\Gamma}{\Delta \otimes \Sigma} \cong (\punitinXfromYtoZ C \Gamma \Delta)\times (\punitinXfromYtoZ C \Gamma \Sigma) \]
  and
  \[ \punitinXfromYtoZ {C} {\Gamma} I \cong 1 \]
\end{definition}

\begin{definition}
  The theory of a simple type theory is an extension of the theory of
  a strict cartesian monoidal category with a
  \begin{enumerate}
  \item A category $\text{Ty}$ of types
  \item A profunctor $\vdash : \harr C {\textrm{Ty}}$
  \item A functor $\text{var} : \varr{\textrm{Ty}} C$ representing $\vdash$ :
    \[ \Gamma \vdash A \cong \punitinXfromYtoZ {} \Gamma {\text{var} A} \]
  \item As assumption that $\text{var}$ is fully faithful:
     \[ \punitinXfromYtoZ {} {\text{var} A} {\text{var} B} \cong \punitinXfromYtoZ {} A B \]
  \end{enumerate}
\end{definition}

\begin{definition}
  The theory of CBPV is an extension of the theory of a simple type
  theory $(\text{VCtx},\times,1,\text{VTy},\vdash_V,\text{var}_V)$ with
  \begin{enumerate}
  \item A category $\text{CCtx}$
  \item An object $I : \varr 1 {\text{CCtx}}$
  \item An action of $\text{VCtx}$ on $\text{CCtx}$, i.e.,
    \begin{enumerate}
    \item A functor $\oslash : \text{VCtx}\times \text{CCtx} \to \text{CCtx}$
    \item Such that $1 \oslash \underline\Delta = \underline\Delta$
    \item And $(\Gamma \times \Delta) \oslash \underline\Sigma = \Gamma \oslash \Delta \oslash \underline\Sigma$
    \end{enumerate}
  \item A category $\text{CTy}$ with a profunctor $\vdash_C : \harr
    {\text{CCtx}}{\text{CTy}}$ and a fully faithful functor $\text{var}_C$ that represents it
    \[ \underline\Delta \vdash_C \underline B \cong \punitinXfromYtoZ {} {\underline\Delta}{\text{var}_C\underline B}\]
  \end{enumerate}
  Furthermore we can add in the universal properties of any
  non-contravariant CBPV connectives. For instance:
  \begin{enumerate}
  \item $F : \varr {VTy} {CTy}$ satisfying
    \[ \Gamma \oslash \text{var}_C F A \vdash_C \underline B \cong \Gamma \times \text{var}_V A \oslash I \vdash_C \underline B  \]
    \[ \Gamma \vdash_V U \underline B \cong \Gamma \oslash I \vdash_C \underline B  \]
  \end{enumerate}
\end{definition}

\begin{definition}[Theory of unary Computational lambda calculus with booleans]
  \begin{enumerate}
  \item A category $C$
  \item A terminal object $1$ of $C$
  \item A monad $T$ on $C$
  \item A type $\textrm{Bit} : \varr 1 C$
  \item Morphisms $\textrm{y},\textrm{n} : \pendallXdotY * \punitinXfromYtoZ {1(*)} {\textrm{Bit}(*)}$
  \item A natural transformation $\textrm{if} : \pendallXdotY * \homrallXYtoZ \alpha {(\punitinXfromYtoZ C {1(*)} \alpha) \times (\punitinXfromYtoZ C {1(*)} \alpha)} {\punitinXfromYtoZ C {\textrm{Bit}(*)} \alpha}$
  \item Satisfying $\textrm{if} y = \pi_1$ and $\textrm{if} n = \pi_2$
  \item A morphism $\textrm{print} : \pendallXdotY * \punitinXfromYtoZ {\textrm{Bit}(*)}{T (1(*))}$
  \end{enumerate}
\end{definition}

Then we can ``program'' in this computational lambda calculus within
our logical framework by constructing terms of type $\punitinXfromYtoZ
C {A} {B}$ for any functors $A,B$ into $C$.

Using a terminal category and the category of elements, we can define
a formal category with families, an algebraic formulation of the
judgmental structure of dependent type theory:
\begin{definition}[Category with Families]
  A category with families consists of
  \begin{enumerate}
  \item A category $\textrm{Ctx}\isaCat$
  \item A presheaf $\textrm{Ty} : \harr {\textrm{Ctx}}{1}$
  \item A presheaf $\textrm{Tm} : \harr {\Sigma_{\Gamma:\textrm{Ctx};*:1}\harrapp{\textrm{Ty}} \Gamma *} 1$
  \item A terminal object in $\textrm{Ctx}$
  \item An \emph{extension operation}
    $\textrm{ext} : \Sigma_{\Gamma:\textrm{Ctx};*:1}\harrapp{\textrm{Ty}}\Gamma * \to \textrm{Ctx}$
    right representing the profunctor
    \[ \Delta:\textrm{Ctx};A:\Sigma_{\Gamma:\textrm{Ctx};*:1}\harrapp{\textrm{Ty}}{\Gamma}{*} \vdash \tensorexistsXwithYandZ {a}{(\punitinXfromYtoZ {} \Delta {\pi^-\pi^-a})}
       {(\punitinXfromYtoZ {}{\pi^-a}{A})}\]
       % {\Sigma_{\Gamma:\textrm{Ctx};*:1}\harrapp{\textrm{Ty}}{\Gamma}{*}}
    % 
  \end{enumerate}
\end{definition}

%% Can we do pras?
%%
%% A PRA mode theory is given by a free 2-category
%% 1. Each mode m is a CwF whose context cat is [m]
%% 2. Each 1-cell  : m -> n is a functor [] : [n] -> [m] that has a DRA and is a PRA
%% 3. Each 2-cell  :  =>  is a 2-cell

%% Let C, D be CwFs.
%% A DRA is a pair of
%% 1. A functor  L : C -> D
%% 2. A morphism R : L^*(D_Ty) -> C_ty in C, i.e., a morphism taking L |- A to  |- RA
%% 3. An iso     I : L^*(D_tm)?? =~ R^*(C_tm) in (L^*(DTy)) a morphism taking L |- M : A to  |- I(M) : RA

%% Let C, D such that C has a terminal object.
%% G : C -> D is a PRA if
%% G / 1 : C -> D / G1 is a right adjoint

%% What about fixed points?
%% Say C has a terminal object
%% fix : Hom(a,a) -> Hom(1, a)
%% satisfying 
%% fix[f] = f o fix[f]?
%% We can write down fix, but not the equation I think



%% \section{Additional Rules}

%% The key property that the hom allows is that given
%% any variable in context of a term $\Phi,\alpha,x,\beta,\Psi \vdash M :
%% Q$ we can represent this term as a ``single-variable term'' by moving
%% $\Phi$ and $\Psi$ to the right of the turnstile:

%% \[ \alpha, x, \beta \vdash \lambda \Phi. \lambda \Psi M. : \Phi \triangleright Q \triangleleft \Psi \]

%% This allows us to describe restricted positive eliminations that only
%% work on single variable contexts. We give an admissible ``syntax
%% sugar'' in Figure~\ref{fig:multi-hom}.


%% Any $\Phi_l,\beta:C,\Phi_r \vdash M : R$ can be represented as a term
%% $\beta:C \vdash M' : \Phi_r \triangleright_{\beta:C} R \triangleleft_{\beta:C} $


%% Say we have a term in context
%% \[ \alpha,x:P,\beta,y:Q,\gamma \vdash M : R \]
%% Using $\triangleright\triangleleft$, we can produce an equivalent term
%% of a different output type whose context is one of the single
%% variables $\alpha,\beta$ or $\gamma$ in the context.

%% We can make it $\alpha$ by using $\triangleleft$ twice:
%% \[ \alpha \vdash \lambda^\triangleleft (x:P,\beta). \lambda^\triangleleft (y:Q, \gamma). M : \forall \beta. (\forall \gamma. R \triangleleft Q) \triangleleft P \]

%% Or $\gamma$ by using $\triangleright$ twice:
%% \[ \gamma \vdash\lambda^\triangleright (\beta, y:Q).  \lambda^\triangleright (\alpha, x:P). M : \forall \gamma. Q \triangleright \forall \alpha. P \triangleright R \]

%% And we have two different ways to make the context $\beta$, either we use $\triangleright$ and then $\triangleleft$:
%% \[ \beta \vdash\lambda^\triangleright (\alpha, x:P).  \lambda^\triangleleft (y:Q, \gamma). M : \forall \alpha. P \triangleright (\forall \gamma. R \triangleleft Q) \]
%% or we do the opposite order:
%% \[ \beta \vdash \lambda^\triangleleft (y:Q, \gamma). \lambda^\triangleright (\alpha, x:P). M : \forall \gamma. (\forall \alpha. P \triangleright R) \triangleleft Q \]

%% In general we can iterate this process. That is given any $\Phi,\Psi$
%% with $d^+\Phi = d^-\Psi = \beta:D$, we can take a term $\Phi \jnctx
%% \Psi \vdash M : R$ and produce an equivalent term $\beta:D \vdash M :
%% \Phi \triangleright R \triangleleft \Psi$. To formalize this, we show
%% how we can create ``multi-hom'' jumbo connectives $\Phi \triangleright
%% R$ and $R \triangleleft \Psi$, where the boundary conditions on
%% $\Phi,\Psi$ are analogous to the ordinary case. These are given in
%% Figure\ref{multi-hom}.

%% \begin{figure}
%%   \begin{align*}
%%     P \triangleleft \gamma:E &= P\\
%%     P \triangleleft (\Psi,x:R,\gamma:E) &= (\forall \gamma: E. P \triangleleft R) \triangleleft \Psi\\
%%     %% \cdot \triangleright_{\alpha : C} P &= P\\
%%     %% (x:R,\beta:D,\Phi_r)\triangleright_{\alpha:C} P  &= \Phi_R \triangleright_{\beta:D} \forall \beta. R \triangleright P
%%   \end{align*}
%%   \begin{mathpar}
%%     \inferrule
%%     {\Gamma \pipe d^+\Xi; \gamma: E \vdash P \isaSet\and
%%      \Gamma \pipe d^-\Xi; \gamma:E \vdash \Psi \isavectx}
%%     {\Gamma \pipe \Xi \vdash P \triangleleft \Psi}

%%     \inferrule*[right=Covariant Multi-Hom introduction]
%%     {\Gamma\pipe\Phi\jnctx \Psi \vdash M : P}
%%     {\Gamma\pipe\Phi \vdash \lambda^\triangleleft \Psi. M : P \triangleleft \Psi}\and

%%     \inferrule*[right=Covar Multi-Hom elim]
%%     {~}
%%     {\Gamma \pipe f:P\triangleleft \Psi,\Psi \vdash \textrm{app}\triangleleft_\Psi : P}

%%     %%   (\lambda^\triangleleft \Psi. M)[\phi] = \lambda^\triangleleft \Psi. M[\phi,\Psi]\\
%%     %%   \lambda^\triangleleft \gamma. M = M\\
%%     %%   \lambda^\triangleleft (\Psi,x:R,\gamma:\cat E). M = \lambda^\triangleleft \Psi. \lambda^\triangleleft (x:R,\gamma:\cat E). M\\

%%     %%   (\lambda^\triangleleft \gamma. M)[\phi] = M[\phi] = \lambda^\triangleleft \gamma. M[\phi]\\
%%     %%   (\lambda^\triangleleft (\Psi,x:r,\gamma:\cat E). M)[\phi] =
%%     %%   (\lambda^\triangleleft \Psi. \lambda^\triangleleft (x:R,\gamma:\cat E). M)[\phi]
%%     %%   = \lambda^\triangleleft \Psi. (\lambda^\triangleleft (x:R,\gamma:\cat E). M)[\phi, \Psi]
%%     %%   = \lambda^\triangleleft \Psi. \lambda^\triangleleft (x:R,\gamma:\cat E). M[\phi,\Psi,x:R,\gamma]      

%%     %%   \inferrule*[right=Covariant Multi-Hom elimination]
%%     %%   {\Phi_1 \vdash M : P\triangleleft \Phi_2 \and \phi_2 : \Psi \vdash \Phi_2 \subst(\xi)}
%%     %%   {\Phi_1,\Psi \vdash M\triangleleft \phi_2 : P[d^+\xi]}\\

%%     %%   M \triangleleft (A/\gamma) = M[A/\gamma]\\
%%     %%   M \triangleleft (\phi, N/x,A/\gamma) =  M \triangleleft (N, A) \triangleleft \phi

%%     %%   (M \triangleleft \phi_2)[\phi_1,\psi] = M[\phi_1] \triangleleft [\phi_2[\psi]]\\
%%     %%   TODO: prove

%%     %%   TODO: (\lambda^\triangleleft \Phi. M) \triangleleft \phi = M[\phi]
%%     %%   TODO: M = \lambda^\triangleleft \Phi. M\triangleleft \Phi

%%     %%   TODO: contravariant by duality
%%     %%   %% \inferrule*[right=Contra Multi-Hom formation]
%%     %%   %% {\Phi \isavectx(\alpha:\cat C; d^-\Xi) \and P \prof(\alpha : \cat C; d^+\Xi)}
%%     %%   %% {\Phi \triangleright P \prof(\xi)}

%%     %%   %% \alpha \triangleright P = P\\
%%     %%   %% \alpha:\cat C, x:R, \Phi \triangleright P = \forall \alpha. R \triangleright \Phi \triangleright P\\
%%   \end{mathpar}
%%   \begin{align*}
%%     \lambda^\triangleleft \gamma:E. M &= M\\
%%     \lambda^\triangleleft (\Psi,x:R,\gamma:E). M &= \lambda^\triangleleft \Psi. \lambda^\triangleleft (x:R,\gamma:E). M\\\\
%%     \textrm{app}\triangleleft_{\gamma:E} &= f\\
%%     \textrm{app}\triangleleft_{\Psi,x:R\gamma:E} &= \textrm{app}\triangleleft_\Psi \triangleleft (x,\gamma) \\
%%   \end{align*}
%%   \caption{Multi-Hom}
%%   \label{multi-hom}
%% \end{figure}

%% \section{Unit and Tensor}
%% we can define the
%% \emph{unit} , which in set-theoretic settings we
%% might call the \emph{identity/equality judgment} $A \equiv_{\cat C}
%% A'$.
%% %
%% First the formation rule says given two objects $A,A'$ in the same
%% category $\cat C$, we can form the hom-set from $A$ to $A'$ $A
%% \to_{\cat C} A'$.
%% %
%% The introduction rule says that given any object $A$, we can define
%% the identity arrow from $A$ to itself $\id(A) : A \to_{\cat C} A$.
%% %
%% Without knowing more about the category in question, these are the
%% only arrows we know exist.
%% %

%% The elimination form is trickiest to define in a natural deduction style.
%% %
%% First, let's consider the universal property of the Hom. From
%% Crutwell-Shulman, we want a 2-cell

%% \[% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZARgBoAGAXVJADcBDAGwFcYkQBBEAX1PU1z5CKcqQBM1Ok1bsuvftjwEiY8ZIYs2iTjz4gMioUTLF10rSABOMAGaMekmFADm8IqBuWIAWyRkQOBBIqlKa7AASProeXr6IogFBiP6MWGAWUBDMAEaMbDQAFjD0UOyQ6SA0OPRY9trlbPIgnlHxVUkhqRXamTl5lSBFJWUE+QE1deCjDtxAA
%% \begin{tikzcd}
%%                     & A \arrow[ldd, no head, Rightarrow] \arrow[rdd, no head, Rightarrow] &   \\
%%                     & refl                                                                &   \\
%% A \arrow[rr, "Hom"] &                                                                     & A
%% \end{tikzcd}\]

%% That is universal/opcartesian in that for any 2-cell $t$:

%% \[ % https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRACEQBfU9TXfIRQBGclVqMWbbrxAZseAkQBMY6vWatEIAIIy+CwUQAsaiZrZ6eBgUpQA2Mxqnb2Acn1z+ioclXLxZy0QAGFPeVtfUwD1SWCAEXDvIxQAZlJhQLi2HA8ucRgoAHN4IlAAMwAnCABbJDIQHAgkYWsQKtqW6iakVRAGLDBgqDo4AAtCkGoJuig2SCHPDrrEPp7EdP7B4LgIAbnpmFmkMCYGBmoGOgAjGAYABWS7fphynCnzFxAACU625aQm3Wpi2i20I3Gk0Ox20C1Y-2qKwa6wArAjOogQet7OiVijus1EI5PsEAErcChcIA
%% \begin{tikzcd}
%% B \arrow[r] \arrow[rrdd] & {} \arrow[r, no head, dashed] & A \arrow[rr, "Hom"] &    & A \arrow[rr, no head, dashed] &  & B' \arrow[lldd] \\
%%                          &                               &                     & t' &                               &  &                 \\
%%                          &                               & C \arrow[rr, "R"]   &    & D                             &  &                
%% \end{tikzcd}\]

%% there exists a $t'$ which extends $t$ in that the following is equal
%% to $t$:
%% \[% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBoAmAXVJADcBDAGwFcYkQAhEAX1PU1z5CKAIwVqdJq3Y8+IDNjwEi5cTQYs2iEAEFZ-RUKIAWNZM3s9vA4OUoAbGY3TtHAOT75ApcOSrjEs5aIADCngq2vqYB6lLBACLh3kYoAMykqYFx7Dge1l6GdsjpxFkW2lZyET5EZKWx5SBJhb5i9eYuTfnVKciO7UEy3clF6SJlnQBOMABmjDwSMFAA5vBEoDOTEAC2SGQgOBBIIvmbO8c0h0iqIIxYYMFQ9HAAFksgNG-0UOyQD55nXaIG5XRDpW73YJwCB3H6fGDfJBgZiMRg0Rj0ABGMEYAAURsJbrMcB8OsEABLnU5bIHg0GmCH-bRPV7veGI7R-NjU86IfaggCsPKBDNB9mFSAFlyOiEcZPYACUATSkAAOaXXdGQ9hQCDMTGMNjsn6cghGg70LDzU3-CWIdUHGXgu5MkC6-WG0lfE3gM2knCW62+21yQFIACcGr5dsjjuO+xdUJhWDhIG9SJRaItVt+frtIn5MrEjKTsK9CJNyNRl0DuZDGxViALUYdiZ1zzeqfTNu5ocbDtBImLbeZHbZaYrdd7Dd5Q6jDJHbr1BvN3eD5oDOZ7C24QA
%% \begin{tikzcd}
%% {} \arrow[dd] \arrow[r]  & {} \arrow[dd] \arrow[rr, no head, dashed] &                     & A \arrow[ldd, no head, Rightarrow] \arrow[rdd, no head, Rightarrow] \arrow[rrr, no head, dashed] &                               &  & {} \arrow[dd, no head, Rightarrow] \\
%%                          &                                           &                     & refl                                                                                             &                               &  &                                    \\
%% B \arrow[r] \arrow[rrdd] & {} \arrow[r, no head, dashed]             & A \arrow[rr, "Hom"] &                                                                                                  & A \arrow[rr, no head, dashed] &  & B' \arrow[lldd]                    \\
%%                          &                                           &                     & t'                                                                                               &                               &  &                                    \\
%%                          &                                           & C \arrow[rr, "R"]   &                                                                                                  & D                             &  &                                   
%% \end{tikzcd}\]

%% Clearly, our introduction rule models this first 2-cell. Furthermore,
%% the construction in the second condition is modeled faithfully by the
%% following sequent rule in the figure. This is a J-like induction rule:
%% to construct a term using an input of the Hom type, it is sufficient
%% to consider the case in which the input is the identity morphism.
%% %
%% However, building in a substitution the usual way we would (pushing
%% the substitution into the continuation $N$) doesn't work properly
%% because we can't necessarily extract a substitution for the
%% continuation from the substitution for the the whole term. A
%% substitution for the whole term would be of the form
%% \[\phi,D_1/\delta_1,M/f,D_2/\delta_2,\psi\]
%% The the candidate for the continuation's substitution would be
%% $\phi,?,\psi$ but there is not necessarily something to go in the
%% middle here since $D_1,D_2$ do not necessarily have the same
%% \emph{input variable}. However, if we assume the existence already of
%% the cotensor products the problem can be simplified. Instead of
%% allowing for a general elimination of a hom term anywhere in the
%% context, we can instead make a remarkably restricted rule: we can only
%% eliminate a Hom term when it is the \emph{sole} input in the context:

%% \[ \inferrule*[right=Hom Elim Very Simple]{\alpha:\cat C \vdash N : Q[\alpha/\alpha_1,\alpha/\alpha_2]}{\alpha_1:\cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2:\cat C \vdash J(\alpha_1.\alpha_2. Q, \alpha. N, \alpha_1, f, \alpha_2) : Q}\]

%% While this rule looks very impoverished at first sight, it has the
%% virtue of easily supporting a built-in cut:

%% \[ \inferrule*[right=Hom Elim VSimple Subst]{
%%   Q \prof(\alpha_1:\cat C; \alpha_2:\cat C)\and
%%   \Phi \vdash M : A_1 \to_{\cat C} A_2\and
%%   \alpha:\cat C \vdash N : Q[\alpha/\alpha_1,\alpha/\alpha_2]}{\Phi \vdash J(\alpha_1.\alpha_2. Q, \alpha. N, A_1, M, A_2) : Q[A_1/\alpha_1, A_2/\alpha_2]}\]

%% However, this rule on its own clearly is not enough to support our
%% desired universal property shown above diagrammatically. To prove our
%% completeness theorem, we will need to show that this rule is enough to
%% give us the desired universal property \emph{assuming the presence of
%%   left and right cotensors}.

%% So first, we must show that the ``proper'' sequent rule

%% \[ \inferrule*[right=Hom-Left (Sequent Style)]
%%     {\Phi_1[\alpha/\alpha_1], \alpha:\cat C, \Phi_2[\alpha/\alpha_2]\vdash Q[\alpha/\alpha_1,\alpha/\alpha_2]}
%%     {\Phi_1, \alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C, \Phi_2\vdash : Q}
%% \]

%% is admissible.

%% Which we can sketch as follows:

%% \[
%% \inferrule*
%%     {\inferrule*{\inferrule*{\Phi_1[\alpha/\alpha_1],\alpha:\cat C, \Phi_2[\alpha/\alpha_1] \vdash Q[\alpha/\alpha_1;\alpha/\alpha_2]}{\alpha:\cat C \vdash \Phi_1[\alpha/\alpha_1] \triangleright Q[\alpha/\alpha_1;\alpha/\alpha_2] \triangleleft \Phi_2[\alpha/\alpha_2]}}{\alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C\vdash \Phi_1 \triangleright Q \triangleleft \Phi_2}}
%%     {\Phi_1, \alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C, \Phi_2\vdash Q}
%% \]

%% Which using our syntax sugar is given by the term:
%% \begin{mathpar}
%%   \inferrule*
%%     {\inferrule*
%%       {\inferrule*
%%         {\Phi_1[\alpha/\alpha_1],\alpha:\cat C, \Phi_2[\alpha/\alpha_1] \vdash N : Q[\alpha/\alpha_1;\alpha/\alpha_2]}
%%         {\alpha:\cat C \vdash \lambda^\triangleright \Phi_1[\alpha/\alpha_1]. \lambda^\triangleleft \Phi_2[\alpha/\alpha_2]. N : \Phi_1[\alpha/\alpha_1] \triangleright Q[\alpha/\alpha_1;\alpha/\alpha_2] \triangleleft \Phi_2[\alpha/\alpha_2]}}
%%       {\alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C\vdash J(\alpha_1.\alpha_2.\Phi_1 \triangleright Q \triangleleft \Phi_2, \alpha. \lambda^\triangleright \Phi_1[\alpha/\alpha_1]. \lambda^\triangleleft \Phi_2[\alpha/\alpha_2]. N, \alpha_1,f,\alpha_2) : \Phi_1 \triangleright Q \triangleleft \Phi_2}}
%%     {\Phi_1, \alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C, \Phi_2\vdash
%%       \Phi_1 \triangleright (J(\alpha_1.\alpha_2.\Phi_1 \triangleright Q \triangleleft \Phi_2, \alpha. \lambda^\triangleright \Phi_1[\alpha/\alpha_1]. \lambda^\triangleleft \Phi_2[\alpha/\alpha_2]. N, \alpha_1,f,\alpha_2)) \triangleleft \Phi_2 : Q}
%% \end{mathpar}

%% We need to show $\beta$ and $\eta$ hold.

%% First, $\beta$.

%% \begin{align*}
%%   &(\Phi_1 \triangleright (J_\to(\alpha_1.\alpha_2.\Phi_1 \triangleright Q \triangleleft \Phi_2, \alpha. \lambda^\triangleright \Phi_1[\alpha/\alpha_1]. \lambda^\triangleleft \Phi_2[\alpha/\alpha_2]. N, \alpha_1,f,\alpha_2)) \triangleleft \Phi_2) [\Phi_1[A/\alpha_1],A/\alpha_1,\id(A),A/\alpha_2,\Phi_2[A/\alpha_2]] \\
%%   &=
%%   \Phi_1[A/\alpha_1] \triangleright (J_\to(\alpha_1.\alpha_2.\Phi_1 \triangleright Q \triangleleft \Phi_2, \alpha. \lambda^\triangleright \Phi_1[\alpha/\alpha_1]. \lambda^\triangleleft \Phi_2[\alpha/\alpha_2]. N, A,\id(A), A)) \triangleleft \Phi_2[A/\alpha_2]\\
%%   &=
%%   \Phi_1[A/\alpha_1] \triangleright (\lambda^\triangleright \Phi_1[A/\alpha_1]. \lambda^\triangleleft \Phi_2[A/\alpha_2]. N[A/\alpha]) \triangleleft \Phi_2[A/\alpha_2]\\
%%   &=  (\lambda^\triangleleft \Phi_2[A/\alpha_2]. N[A/\alpha]) \triangleleft \Phi_2[A/\alpha_2]\\
%%   &=  N[A/\alpha]
%% \end{align*}

%% \begin{figure}
%%   \begin{mathpar}
%%     \inferrule*[right=Full Unit Elim*]
%%     {\Phi_1[\alpha/\alpha_1], \alpha:\cat C, \Phi_2[\alpha/\alpha_2]\vdash N : Q[\alpha/\alpha_1,\alpha/\alpha_2]}
%%     {\Phi_1, \alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C, \Phi_2\vdash J_\to'(\Phi_1, \alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C, \Phi_2, Q, \alpha. N) : Q}

%%     J_\to'(\Phi_1, \alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C, \Phi_2, Q, \alpha. N) =
%%     \Phi_1 \triangleright (J(\alpha_1.\alpha_2.\Phi_1 \triangleright Q \triangleleft \Phi_2, \alpha. \lambda^\triangleright \Phi_1[\alpha/\alpha_1]. \lambda^\triangleleft \Phi_2[\alpha/\alpha_2]. N, \alpha_1,f,\alpha_2)) \triangleleft \Phi_2

%%     \inferrule*[right=Full Unit $\beta$*]
%%     {}
%%     {J_\to'(\Phi_1, \alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C, \Phi_2, Q, \alpha. N)[\Phi_1[\alpha/\alpha_1],\alpha/\alpha_1, \id(\alpha)/f, \alpha/\alpha_2, \Phi_2[\alpha/\alpha_2]]
%%     = N}

%%     (\Phi_1 \triangleright J(\alpha_1.\alpha_2.\Phi_1 \triangleright Q \triangleleft \Phi_2, \alpha. \lambda^\triangleright \Phi_1[\alpha/\alpha_1]. \lambda^\triangleleft \Phi_2[\alpha/\alpha_2]. N, \alpha_1,f,\alpha_2) \triangleleft \Phi_2)[\Phi_1[\alpha/\alpha_1],\alpha/\alpha_1, \id(\alpha)/f, \alpha/\alpha_2, \Phi_2[\alpha/\alpha_2]]\\
%%     = \Phi_1[\alpha/\alpha_1] \triangleright J(\alpha_1.\alpha_2.\Phi_1 \triangleright Q \triangleleft \Phi_2, \alpha. \lambda^\triangleright \Phi_1[\alpha/\alpha_1]. \lambda^\triangleleft \Phi_2[\alpha/\alpha_2]. N, \alpha,\id(\alpha),\alpha) \triangleleft \Phi_2[\alpha/\alpha_2]\\
%%     = \Phi_1[\alpha/\alpha_1] \triangleright
%%     (\lambda^\triangleright \Phi_1[\alpha/\alpha_1]. \lambda^\triangleleft \Phi_2[\alpha/\alpha_2]. N)
%%     \triangleleft \Phi_2[\alpha/\alpha_2]\\
%%     = N

%%     \inferrule*[right=Unit$\eta$]
%%     {\Phi_1, \alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C, \Phi_2 \vdash M : Q}
%%     {M =
%%       J_\to'(\Phi_1, \alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C, \Phi_2, Q, \alpha. M[\Phi_1[\alpha/\alpha_1],\alpha/\alpha_1,\id(\alpha), \alpha/\alpha_2,\Phi_2[\alpha/\alpha_2]])}

%%     M
%%     =(\triangleleft\beta\triangleright\beta)
%%     \Phi_1 \triangleright
%%     (\lambda^\triangleright \Phi_1. \lambda^\triangleleft \Phi_2. M)
%%     \triangleleft \Phi_2
%%     = \Phi_1 \triangleright
%%     J_\to(\alpha_1.\alpha_2.Q, \alpha. \lambda^\triangleright \Phi_1[\alpha/\alpha_1]. \lambda^\triangleleft \Phi_2[\alpha/\alpha_2]. M[\alpha/\alpha_1, \id(\alpha)/f,\alpha/\alpha_2], \alpha_1, f, \alpha_2)
%%     \triangleleft \Phi_2
%%     =
%%     J_\to'(\Phi_1, \alpha_1 : \cat C, f : \alpha_1 \to_{\cat C} \alpha_2, \alpha_2 : \cat C, \Phi_2, Q, \alpha. N)
%%   \end{mathpar}  
%%   \caption{Admissible Unit Universal Property Rules}
%% \end{figure}


%% First, the syntax for tensor is based on the coend formula that gives
%% the definition in $Cat$, but using logical syntax $\exists$ rather
%% than integrals because I don't like integral syntax and the syntax
%% matches existential quantification in type theory.
%% %
%% Note that $\exists \beta. ~Q \odot R$ is the application of a single
%% connective to $Q$ and $R$, and not separable into a quantifier
%% $\exists$ connective and a product connective $\odot$.
%% %
%% Introduction, elimination and $\beta\eta$ are similar to a combination
%% of existential quantification and the tensor product in linear logic.
%% %
%% The introduction rule is justified by the fact that semantically what
%% we have is a transformation
%% \[ \textrm{pair} : (\alpha : \cat C,Q,\beta:\cat D,R,\gamma:\cat E) \Rightarrow \exists \beta. R \odot Q \]
%% And the introduction rule is just building in a substitution to this
%% transformation.
%% %

%% For the elim rule we can pull a similar trick as with the Hom
%% type. First, the rule where there's only one variable.
%% \[ \inferrule*[right=Tensor elim Simple]
%%   {\alpha : \cat C, q : Q, \beta : \cat D, r: R, \gamma : \cat E \vdash N : S}
%%   {\alpha : \cat C, x : \exists \beta. Q \odot R, \gamma : \cat E \vdash J_\odot(x, q.\beta.r. N) : S}
%% \]

%% \begin{figure}
%% \begin{mathpar}
%%     \inferrule*[right=Full Tensor Elim*]
%%     {\Phi_1, \alpha:\cat C, q:Q, \beta:\cat D, r:R, \gamma:\cat E \Phi_2\vdash N : S}
%%     {\Phi_1, \alpha : \cat C, x : \exists \beta:\cat D. Q \odot R, \gamma : \cat E, \Phi_2
%%       \vdash J_\odot'(\Phi_1, \alpha : \cat C, x : \exists \beta:\cat D. Q \odot R, \gamma : \cat E, \Phi_2; S;q.\beta.r.N) : S}

%%     J_\odot'(\Phi_1, \alpha : \cat C, x : \exists \beta:\cat D. Q \odot R, \gamma : \cat E, \Phi_2;S; q.\beta.r.N)
%%     = \Phi_1 \triangleright J_\odot(\alpha.\gamma.\Phi_1 \triangleright S \triangleleft \Phi_2, \alpha.q.\beta.r.\gamma. \lambda^\triangleleft \Phi_1. \lambda^\triangleright\Phi_2. N, \alpha, x, \gamma) \triangleleft \Phi_2

%%     J_\odot'(\Phi_1, \alpha : \cat C, x : \exists \beta:\cat D. Q \odot R, \gamma : \cat E, \Phi_2; q.\beta.r.N)[\Phi_1,\alpha/\alpha,(q,\beta,r)/x,\gamma/\gamma,\Phi_2] = N
    

%%   \inferrule*[right=Full Tensor elim*]{ S \prof(\alpha:\cat C; \gamma : \cat E)\and
%%     \Phi \vdash M : \exists \beta. Q[A/\alpha] \odot R[G/\gamma]\and
%%     \alpha : \cat C, q : Q, \beta : \cat D, r: R, \gamma : \cat E \vdash N : S}
%%   {\Phi \vdash J_\odot(\alpha. \gamma. S, \alpha.q.\beta.r.\gamma.N, A, M, G) : S[A/\alpha, G/\gamma]}

%%   J_\odot(\alpha. \gamma. S, \alpha.q.\beta.r.\gamma.N, A, M, G)[\phi] =
%%   J_\odot(\alpha. \gamma. S, \alpha.q.\beta.r.\gamma.N, A[d^-\phi], M[\phi], G[d^+\phi])

%%   %% \inferrule*[right=Tensor elim Sequent]
%%   %% {\Phi,\alpha : \cat C, q : Q, \beta : \cat D, r: R, \gamma : \cat E,\Psi \vdash N : S}
%%   %% {\Phi, \alpha : \cat C, x : \exists \beta. Q \odot R, \gamma : \cat E,\Psi \vdash J_\odot(x;q.\beta.r. N) : S}

%%   %% \inferrule*[right=Tensor elim Subst]
%%   %% {\Phi,\alpha : \cat C, q : Q, \beta : \cat D, r: R, \gamma : \cat E,\Phi' \vdash N : S
%%   %% \and
%%   %% \phi : \Psi \to \Phi,\alpha : \cat C, q : Q, \beta : \cat D, r: R, \gamma : \cat E,\Phi'}
%%   %% {\Psi  \vdash J_\odot(x;q.\beta.r. N)[\phi] : S}

%%   \inferrule*[right=Tensor $\beta$]
%%   {}{J_\odot(\alpha.\gamma.S, \alpha.q.\beta.r.\gamma.N,A,(M,B,N),G) = N[A/\alpha,M/q,B/\beta,N/r,G/\gamma]}

%%   \inferrule*[right=Tensor$\eta$]
%%   {\alpha : \cat C, x : \exists \beta. Q \odot R, \gamma : \cat E \vdash M : S}
%%   {\alpha : \cat C, x : \exists \beta. Q \odot R, \gamma : \cat E \vdash M =
%%     J(\alpha.\gamma.S, \alpha.q.\beta.r.\gamma. M[\alpha/\alpha,(q,\beta,r)/x,\gamma/\gamma])
%%     : S}
%% \end{mathpar}
%% \caption{Tensor Admissible Universal Property Rules}
%% \label{fig:tensor}
%% \end{figure}

%% \section{Internal Category Theory}

%% A downside of working synthetically is that since everything we define
%% must be functorial/natural, we cannot prove any theorems about
%% functions that are not assumed to be functorial or transformations
%% that are not assumed ot be natural.
%% %
%% These kinds of constructions are surprisingly common in basic category theory.
%% %
%% For instance, when defining a left adjoint $F$ to a given right
%% adjoint functor $U$, the functoriality of $F$ is often not assumed,
%% rather we are given that each $F a$ has a certain universal mapping
%% property and this can then be used to show the action of $F$ on
%% objects extends to an action on morphisms.
%% %
%% This definition is quite important for applications of category theory
%% to type theory: in type theory when a type constructor is defined it
%% is given introduction, elimination and $\beta\eta$ rules, but no
%% primitive syntax is given for a functorial action.
%% %
%% The fact that functoriality is determined from the universal mapping
%% property of the type is then a key step in proving the type theory is
%% sound and complete with respect to models which are expected to have
%% certain functors on them.

%% As another example, a common lemma states that an \emph{possibly
%% unnatural} transformation is in fact natural if it is the inverse of a
%% natural transformation.
%% %
%% Neither of these examples can be stated as synthetic theorems, as it
%% is impossible to quantify over ``possibly unnatural transformations''
%% or ``functions on objects''.
%% %
%% Inside the calculus, we cannot ``see'' that categories have an
%% underlying set of objects.
%% %
%% Fortunately there is a way to use our calculus in a different manner
%% to study these constructions: by defining categories \emph{internal
%% to} SCT.
%% %
%% This reproduces classical constructions, since there is a model where
%% a category $\cat C$ is interpreted simply as a set, functors as
%% functions and profunctors $\harr {\cat C}{\cat D}$ as \emph{spans},
%% i.e. sets $R$ with (source and target) projections $\cat C \leftarrow
%% R \rightarrow \cat D$.
%% %
%% The proofs read like the classical proofs (with some care additional
%% attention on the ordering of variable usage), but by virtue of being
%% syntactic automatically apply to any notion of category internal to a
%% virtual equipment, which includes classical internal categories,
%% enriched categories and a broad range of generalized multicategory.

%% We note that a synthetic approach to model this situation may be
%% possible were we to extend our calculus with a \emph{modality} $|\cat
%% C|$ that takes a category to the discrete category on the set of
%% objects. We discuss this in \cref{sec:discussion}.



%% Next, we introduce the notion of category internal to our syntactic
%% virtual equipment and the \emph{monoids and modules} translation that
%% shows that, with the inclusion of hom sets, our syntax is already
%% suitable for doing syntactic category theory.

%% The benefits of our syntax become clear when we define internal
%% categories, functors, profunctors and transformations: the definitions
%% read exactly as the classical definitions.
%% \begin{definition}[Internal Category]
%%   An \emph{(internal) category} consists of\footnote{the following is
%%     easily interpreted as a $\Sigma$ type}:
%%   \begin{enumerate}
%%   \item A sort $C_0 \isaCat$
%%   \item A span $C_1 : \harr{C_0}{ C_0}$
%%   \item Identity arrows
%%     $C_r : \pendallXdotY {\alpha :  C_0} {\harrapp{C_1} \alpha \alpha}$
%%   \item Composition of arrows
%%     \[ C_t : \pendallXdotY \alpha {\homrallXYtoZ \beta {\harrapp{C_1} \alpha \beta} {\homrallXYtoZ \gamma {\harrapp{C_1} \beta \gamma} {\harrapp{C_1} \alpha \gamma}}}\]
    
%%     %% \[ C_t^\triangleright : \forall \alpha :  C_0. \forall \beta. ({C_1} \beta \alpha) \triangleright \forall \gamma. ({C_1} \gamma \beta) \triangleright {C_1} \gamma \alpha \]

%%     %% or

%%     %% \[ C_t^\triangleleft : \forall \alpha. \forall \beta. (\forall \gamma. {C_1} \alpha \gamma \triangleleft {C_1} \beta \gamma) \triangleleft {C_1} \alpha \beta
%%     %% \]

%%     %% or using tensors and covariant homs

%%     %% \[ C_t^\odot : \forall \alpha. \forall \gamma. (\exists \beta. {C_1}\alpha\beta\odot {C_1}\beta\gamma)\triangleright {C_1}\alpha \gamma \]

%%     %% or using tensors and contravariant homs

%%     %% \[ C_t^\odot : \forall \gamma. \forall \alpha. {C_1}\alpha\gamma \triangleleft (\exists \beta. {C_1}\alpha\beta\odot {C_1}\beta\gamma)\]
%%   \item Satisfying right unitality, i.e., for any $\Phi \vdash f :
%%     \harrapp {C_1} A B$, we'd like $f; r(B) = f$. We can formalize this
%%     using an equality of two transformations of type $\pendallXdotY
%%     \alpha {\homrallXYtoZ \beta {\harrapp{C_1} \alpha \beta} {\harrapp{C_1} \alpha \beta}}$

%%     \[ \pendlambdaXdotY \alpha {\homrlambdaXatYdotZ f \beta {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t} \alpha} {f} \beta} {\pendappXtoY {C_r} \beta} \beta}}
%%     = \pendlambdaXdotY \alpha {\homrlambdaXatYdotZ f \beta f} \]

%%     These kinds of equalities between 2-cells are very common in
%%     internal category theory, so to save space we will suppress the
%%     sequence of $\lambda$s that start such equalities. So the above can simply be written as

%%     \[ { {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t} \alpha} {f} \beta} {\pendappXtoY {C_r} \beta} \beta}} = { f}\]

%%   \item and left unitality (an equality of the same type as right unitality):


%%     \[ { {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t} \alpha} {\pendappXtoY {C_r} \alpha} \alpha} f \beta}} = { f}\]
%%   \item and associativity, which is an equality at type
%%     \[ \pendallXdotY \alpha {\homrallXYtoZ \beta {\harrapp{C_1} \alpha \beta} {\homrallXYtoZ \gamma {\harrapp{C_1} \beta \gamma} {\homrallXYtoZ \delta {\harrapp{C_1} \gamma \delta} {\harrapp{C_1} \alpha \delta}}}}\]

%%     \[ \homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t}\alpha} f \beta} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t}\beta} g \gamma} h \delta)} \delta
%%     =
%%     \homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t}\alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t}\alpha} f \beta} g \gamma)} \gamma} h \delta \]
%%   \end{enumerate}
%% \end{definition}

%% We can define an internal functor to be a pair of an object function
%% and a function on arrows that preserves identity and 
%% \begin{definition}[Internal Functor]
%%   A functor $F$ between internal categories $C$ and $D$ consists of
%%   \begin{enumerate}
%%   \item a map of objects $F_0 : \varr {C_0} {D_0}$
%%   \item a map of arrows
%%     $F_1 : \pendallXdotY {\alpha}
%%     {\homrallXYtoZ \beta {\harrapp{C_1} \alpha \beta} {\harrapp{D_1} {F_0 \alpha}{F_0 \beta}}}$
%%   \item That preserves identity. This is given by equality between the
%%     following terms of type $\forall \alpha:{{C_0}}. D_1 {(F_0 \alpha)}{(F_0\alpha)}$:
%%     \[ \homrappXtoYatZ {\pendappXtoY {F_1}\alpha} {\pendappXtoY {C_r} \alpha} \alpha = \pendappXtoY {D_r}{F_0\alpha} \]
%%   \item And preserves composition.
%%     This is given by an equality between the following terms of type

%%     \[ \pendallXdotY \alpha
%%     \homrallXYtoZ {\beta} {\harrapp{C_1} \alpha \beta} {\homrallXYtoZ \gamma {\harrapp{C_1} \beta \gamma} {\harrapp{D_1} {F_0 \alpha} {F_0 \gamma}}}\]

%%     First, we can compose in $C$, and then map using $F$:
%%     \[ \homrappXtoYatZ {\pendappXtoY{F_1} \alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t} \alpha} f \beta} g \gamma)}\gamma\]

    
%%     or we can map the morphisms with $F$, and then compose them in $D$:
%%     \[ \homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {D_t} {(F_0 \alpha)}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} f \beta)} {(F_0 \beta)}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \beta} g \gamma)} {{F_0} \gamma}\]
%%   \end{enumerate}
%% \end{definition}

%% We can immediately define identity and composition of functors.

%% \begin{definition}
%%   For any $C : \algCat$, we can define an identity functor
%%   $\textrm{Id}_C : \algVarr C C$ by
%%   \begin{enumerate}
%%   \item $\textrm{Id}_0 = \lambda \alpha:C_0. \alpha$
%%   \item $\textrm{Id}_1 = \pendlambdaXdotY \alpha
%%     {\homrlambdaXatYdotZ f {\alpha'} f}$
%%   \item Preservation of identity requires proving
%%     \[
%%     \lambda \alpha. \pendappXtoY {C_r}{\textrm{Id}_0\alpha} \]
%%     is equal to
%%     \[ \lambda \alpha.
%%     \homrappXtoYatZ {\pendappXtoY {\textrm{Id}_1} \alpha} {(\pendappXtoY {C_r}\alpha)} \alpha\]
%%     Both sides simply $\beta$ reduce to $ \lambda \alpha. \pendappXtoY {C_r} \alpha$
%%     and the result follows by reflexivity.
%%   \item Preservation of composition requires proving (under a $\lambda \alpha. \homrlambdaXatYdotZ f \beta \homrlambdaXatYdotZ g \gamma$)
%%     \[
%%     \homrappXtoYatZ {\pendappXtoY {{\textrm{Id}}_1} \alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t} \alpha} f \beta} g \gamma)}\gamma
%%     = \homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t} {{\textrm{Id}}_0 \alpha}} {(\homrappXtoYatZ {\pendappXtoY {{\textrm{Id}}_1} \alpha} f \beta)} {{\textrm{Id}}_0 \beta}} {(\homrappXtoYatZ {\pendappXtoY{{\textrm{Id}}_1} \beta} g \gamma)} {{\textrm{Id}}_0 \gamma}\]
%%     Both sides $\beta$ reduce to

%%     \[ \homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t} \alpha} f \beta} g \gamma\]
%%     so the result holds by reflexivity.
%%   \end{enumerate}
%% \end{definition}

%% \begin{definition}
%%   Given categories $C,D,E$ and functors $F : \algVarr C D$ and
%%   $G : \algVarr D E$, we define the composition $G \circ F :
%%   \algVarr C E$ as
%%   \begin{enumerate}
%%   \item $(G \circ F)_0 = \lambda \alpha. {G_0 ({F_0} \alpha)}$
%%   \item $(G \circ F)_1 =
%%     \pendlambdaXdotY \alpha {
%%     \homrlambdaXatYdotZ f \beta
%%     {\homrappXtoYatZ {\pendappXtoY {G_1} {F_0 \alpha}} {\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} f \beta} {F_0 \beta}}}$
%%   \item Preservation of identity requires proving
%%     \[ \lambda \alpha. \pendappXtoY {E_r} {(G \circ F)_0\alpha} \]
%%     is equal to
%%     \[ \lambda \alpha.
%%     \homrappXtoYatZ {\pendappXtoY {(G \circ F)_1} \alpha} {\pendappXtoY {C_r}\alpha} \alpha \]

%%     Expanding definitions and $\beta$ reducing we need to show

%%     \[ \pendlambdaXdotY\alpha {\pendappXtoY {E_r}{G_0 (F_0 \alpha)}} \]
%%     is equal to
%%     \[ \pendlambdaXdotY \alpha {\homrappXtoYatZ {\pendappXtoY {G_1} {F_0 \alpha}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} {\pendappXtoY {C_r} \alpha} \alpha)} {F_0 \alpha}}\]

%%     Proceeding from right to left applying transitivity:
%%     \begin{align*}
%%       &\pendlambdaXdotY \alpha {\homrappXtoYatZ {\pendappXtoY {G_1} {F_0 \alpha}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} {\pendappXtoY {C_r} \alpha} \alpha)} {F_0 \alpha}}\\
%%       &=\pendlambdaXdotY \alpha {\homrappXtoYatZ {\pendappXtoY {G_1} {F_0 \alpha}} {(\pendappXtoY{(\pendlambdaXdotY \alpha {\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} {\pendappXtoY {C_r} \alpha} \alpha})}\alpha)}} {F_0 \alpha}\\
%%       &=\pendlambdaXdotY \alpha {\homrappXtoYatZ {\pendappXtoY {G_1} {F_0 \alpha}} {(\pendappXtoY{(\pendlambdaXdotY \alpha {{\pendappXtoY {D_r} {F_0 \alpha}}})}\alpha)}} {F_0 \alpha}\tag{*}\\
%%       &=\pendlambdaXdotY \alpha {\homrappXtoYatZ {\pendappXtoY {G_1} {F_0 \alpha}} {\pendappXtoY {D_r} {F_0 \alpha}}} {F_0 \alpha}\\
%%       &= \pendlambdaXdotY \alpha
%%       \pendappXtoY {(\pendlambdaXdotY \beta {{\homrappXtoYatZ {\pendappXtoY {G_1} \beta} {\pendappXtoY {D_r} \beta} \beta}})} {F_0 \alpha}\\
%%       &= \pendlambdaXdotY \alpha
%%       \pendappXtoY {(\pendlambdaXdotY \beta \pendappXtoY {E_r} {G_0 \beta})} {F_0 \alpha}\tag{*}\\
%%       &= \pendlambdaXdotY \alpha \pendappXtoY {E_r} {G_0 (F_0 \beta)}\\
%%     \end{align*}

%%     Where the two marked lines follow from congruence using the
%%     assumptions about $F,G$.

%%   \item Preservation of Composition.
    
%%     \[ \homrappXtoYatZ {\pendappXtoY{(G \circ F)_1} \alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t} \alpha} f \beta} g \gamma)}\gamma\]
%%     equals

%%     \[ \homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {E_t} {(G \circ F)_0 \alpha}} {(\homrappXtoYatZ {\pendappXtoY {(G\circ F)_1} \alpha} f \beta)} {(G\circ F)_0 \beta}} {(\homrappXtoYatZ {\pendappXtoY {(G\circ F)_1} \beta} g \gamma)} {{F_0} \gamma}\]

%%     Reducing, we need to show
%%     \[ \homrappXtoYatZ {\pendappXtoY{G_1} {F_0 \alpha}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t}\alpha} f {\beta}} g {\gamma})} \gamma)} {F_0 \gamma} \]

%%     is equal to
%%     \[ \homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {E_t} {G_0(F_0\alpha)}}
%%       {({\homrappXtoYatZ {\pendappXtoY {G_1} {F_0 \alpha}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} f \beta)} {F_0 \beta}})}
%%       {G_0(F_0\beta)}}
%%        {({\homrappXtoYatZ {\pendappXtoY {G_1} {F_0 \beta}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \beta} g \gamma)} {F_0 \gamma}})}
%%        {{F_0} \gamma}\]

%%     Going from left to right:
%%     \begin{align*}
%%       &\homrappXtoYatZ {\pendappXtoY{G_1} {F_0 \alpha}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t}\alpha} f {\beta}} g {\gamma})} \gamma)} {F_0 \gamma}\\
%%       &=
%%       \homrappXtoYatZ
%%       {\pendappXtoY{G_1} {F_0 \alpha}}
%%       {(({\homrappXtoYatZ {\homrappXtoYatZ{\pendappXtoY{(\pendlambdaXdotY \alpha {\homrlambdaXatYdotZ f \beta {\homrlambdaXatYdotZ g \gamma {\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t}\alpha} f {\beta}} g {\gamma})} \gamma}}})}\alpha} f \beta} g \gamma}))}
%%       {F_0 \gamma}\\
%%       &=
%%       \homrappXtoYatZ
%%       {\pendappXtoY{G_1} {F_0 \alpha}}
%%       {(({\homrappXtoYatZ {\homrappXtoYatZ{\pendappXtoY{(\pendlambdaXdotY \alpha {\homrlambdaXatYdotZ f \beta {\homrlambdaXatYdotZ g \gamma {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {D_t} {(F_0 \alpha)}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} f \beta)} {(F_0 \beta)}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \beta} g \gamma)} {{F_0} \gamma}}}})}\alpha} f \beta} g \gamma}))}
%%       {F_0 \gamma}\tag{*}\\
%%       &=
%%       \homrappXtoYatZ
%%       {\pendappXtoY{G_1} {F_0 \alpha}}
%%       {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {D_t} {(F_0 \alpha)}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} f \beta)} {(F_0 \beta)}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \beta} g \gamma)} {{F_0} \gamma}}      
%%       {F_0 \gamma}\\
%%       &=
%%       {(({\homrappXtoYatZ {\homrappXtoYatZ{\pendappXtoY{(\pendlambdaXdotY {\alpha'} {\homrlambdaXatYdotZ {f'} {\beta'} {\homrlambdaXatYdotZ {g'} {\gamma'} {{\homrappXtoYatZ {\pendappXtoY {G_1} {\alpha'}} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {D_t}{\alpha'}} {f'} {\beta'}} {g'} {\gamma'})} {\gamma'}}}}})}{F_0\alpha}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} f \beta)} {F_0\beta}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \beta} g \gamma)} {F_0\gamma}}))}\\
%%       &=
%%       {(({\homrappXtoYatZ {\homrappXtoYatZ{\pendappXtoY{(\pendlambdaXdotY {\alpha'} {\homrlambdaXatYdotZ {f'} {\beta'} {\homrlambdaXatYdotZ {g'} {\gamma'} {{\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {E_t} {(G_0 {\alpha'})}} {(\homrappXtoYatZ {\pendappXtoY {G_1} {\alpha'}} {f'} {\beta'})} {(G_0 \beta')}} {(\homrappXtoYatZ {\pendappXtoY {G_1} {\beta'}} {g'} {\gamma'})} {{G_0} \gamma'}}}}})}{F_0\alpha}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} f \beta)} {F_0\beta}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \beta} g \gamma)} {F_0\gamma}}))}\\
%%       &= \homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {E_t} {G_0(F_0\alpha)}}
%%       {({\homrappXtoYatZ {\pendappXtoY {G_1} {F_0 \alpha}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \alpha} f \beta)} {F_0 \beta}})}
%%       {G_0(F_0\beta)}}
%%        {({\homrappXtoYatZ {\pendappXtoY {G_1} {F_0 \beta}} {(\homrappXtoYatZ {\pendappXtoY {F_1} \beta} g \gamma)} {F_0 \gamma}})}
%%        {{F_0} \gamma}
%%     \end{align*}
%%   \end{enumerate}
%% \end{definition}

%% \begin{definition}[Internal Profunctor]
%%   A profunctor $R$ between internal categories $\cat C$ and $\cat D$
%%   consists of
%%   \begin{enumerate}
%%   \item A span $R_s : \harr {C_0} {D_0}$.
%%   \item A ternary ``mixed composition'' action:
%%     $R_t :\pendallXdotY \alpha {\homrallXYtoZ {\alpha'} {\harrapp {C_1} {\alpha}{\alpha'}} {\homrallXYtoZ {\beta'} {\harrapp {R_s} {\alpha'}{\beta'}} {\homrallXYtoZ {\beta} {\harrapp {D_1} {\beta'} {\beta}} {\harrapp {R_s} {\alpha}{\beta}}}}}$

%%   \item Satisfying unitality (under a $\pendlambdaXdotY \alpha {\homrlambdaXatYdotZ f \beta {}}$):
%%     \[
%%     f = \homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {R_t} \alpha} {\pendappXtoY {C_r} \alpha} \alpha}f \beta} {\pendappXtoY {D_r} \beta} \beta
%%     \]
    
%%   \item And associativity (both with a large implicit
%%     $\pendlambdaXdotY \alpha {\homrlambdaXatYdotZ g \beta \homrlambdaXatYdotZ {g'} {\beta'}
%%     \homrlambdaXatYdotZ {r} {\beta''}\homrlambdaXatYdotZ {f'} {\alpha''}\homrlambdaXatYdotZ {f} {\alpha'}}$)

%%     % f : a -> a'
%%     % f' : a' -> a''
%%     % r : a'' -> b''
%%     % g' : b'' -> b'
%%     % g : b' -> b
%%     %%
%%     %
%%     % f o (f' o r o g') o g
%%     %% and
%%     % (f o f') o r o (g' o g)

%%     \[ \homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {R_t} {\alpha}} {f} {\alpha'}}{({\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {R_t} {\alpha'}} {f'} {\alpha''}}r {\beta''}} {g'} {\beta'}})} {\beta'}} {g} {\beta}\]
%%     is equal to
%%     \[ \homrappXtoYatZ
%%        {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {R_t} {\alpha}} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t} {\alpha}} {f} {\alpha'}} {f'} {\alpha''})} {\alpha''}} r {\beta''}}
%%        {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {D_t} {\beta''}} {g'} {\beta'}} g {\beta})} {\beta}\]
%%   \end{enumerate}
%% \end{definition}

%% We can immediately define the Hom profunctor for any category $C$ as
%% $(\text{Hom}_C R)_s = C_1$ with actions given by $C_t$.

%% Next, we show that Profunctors can be restricted by functors.

%% \begin{definition}[Restriction of Profunctors]
%%   If $C, D, C', D' : \text{Cat}$, and $F : \text{Functor} C C', G : \text{Functor} D D'$ and
%%   $R : \text{Prof} C' D'$, then we can define a profunctor $R[F;G] : \text{Prof} C D$ by
%%   \begin{enumerate}
%%   \item $R[F;G]_s = \lambda (\alpha:C,\beta:D). R_s (F_0 \alpha) (G_0 \beta)$
%%   \item with composition action given by

%%     \[ R[F;G]_t =
%%     \pendlambdaXdotY \alpha {\homrlambdaXatYdotZ f {\alpha'} {\homrlambdaXatYdotZ r {\beta'} {\homrlambdaXatYdotZ g {\beta} {\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {R_t} {F_0 \alpha}} {(\homrappXtoYatZ {\pendappXtoY {F_1} {\alpha}} f {\alpha'})} {F_0 \alpha'}} r {G_0 \beta'}} {(\homrappXtoYatZ {\pendappXtoY {G_1} {\beta'}} g \beta)} {G_0 \beta}}}} }
%%  \]
%%   %% \item $\cat C'$ composition:
%%   %%   \[ \lambda \alpha. \lambda^\triangleleft (\beta, (f : C_1 \alpha \alpha',\alpha',\alpha', r : R_s \alpha' \beta)). R_l(F_1 f, r) \]
%%   %% \item $\cat D'$ composition:
%%   %%   \[ \lambda \alpha. \lambda^\triangleleft ('\beta, (r : R_s \alpha \alpha',\alpha', \beta',h : D_1 \beta' \beta)). R_r(r, G_1 h) \]
%%   \end{enumerate}
%%   Identity and associativity properties should follow. TODO
%% \end{definition}

%% \begin{definition}[Homomorphism]
%%   Given $R : \text{Prof} C D$ and $S : \text{Prof} C D$, a
%%   homomorphism $m$ from $R$ to $S$ consists of
%%   \begin{enumerate}
%%   \item $m_f : \pendallXdotY \alpha {\homrallXYtoZ \beta {\harrapp R \alpha \beta}{\harrapp S \alpha \beta}}$
%%     % m_f (R_t f r g) = S_t f (m_f r) g
%%   \item Satisfying naturality (under a $\ldots$)

%%     \[
%%     \homrappXtoYatZ {\pendappXtoY{m_f} \alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {R_t} \alpha} f {\alpha'}} r {\beta'}} g \beta)} \beta
%%     =
%%     \homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {S_t} \alpha} {f} {\alpha'}} {(\homrappXtoYatZ {\pendappXtoY {m_f}{\alpha'}} r {\beta'})} {\beta'}} g \beta
%%     \]
%%   \end{enumerate}
%% \end{definition}

%% \begin{definition}
%%   An isomorphism between profunctors $R$ and $S$ is a mutually inverse
%%   pair of homomorphisms.
%% \end{definition}

%% Additionally, we can define natural transformations between functors,
%% but more generally, we can define a natural element of any
%% endo-profunctor, where natural transformations from $F$ to $G$ are the
%% same as natural elements of $\text{Hom}(F-,G=)$.

%% \begin{definition}[Natural Element]
%%   A natural element $\phi$ of a profunctor $R : \text{Prof}\,C C$ is a term
%%   \[ \phi : \pendallXdotY \alpha {\harrapp R \alpha \alpha} \]
%%   that is natural in that
%%   \[
%%   \homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t} \alpha} {\pendappXtoY \phi \alpha} \alpha} f {\alpha'}
%%   = \homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {C_t } \alpha} f {\alpha'}} {\pendappXtoY \phi {\alpha'}}{\alpha'}
%%   \]
%% \end{definition}

%% \begin{definition}[Natural Transformation]
%%   A natural transformation from $F : \text{Functor} \,C\, D$ and $G :
%%   \text{Functor}\,C\,D$ is a natural element of $\text{Hom}(D)[F;G]$
%% \end{definition}

%% Composition of natural transformations is then given by $C_t$.

%% Natural elements are closely related to homomorphisms: a natural
%% element equivalent to a homomorphism out of a Hom profunctor. This is
%% our first instance of a ``Yoneda'' principle that the behavior of some
%% structure that varies naturally with the morphisms of a category is
%% fully determined by its action on the identity morphisms.

%% \begin{theorem}
%%   Natural elements of $R : \text{Prof}\, C C$ are equivalent to
%%   homomorphisms from $\text{Hom}_C$ to $R$.
%% \end{theorem}
%% \begin{enumerate}
%% \item Given a natural element $\phi$ of $R$, we can define a
%%   homomorphism by
%%   \[ \pendlambdaXdotY \alpha {\homrlambdaXatYdotZ f {\alpha'} \homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {R_t} \alpha} {\pendappXtoY {C_r} \alpha} \alpha}{\pendappXtoY \phi \alpha} {\alpha}} f {\alpha'}} \]
%% \item Given a homomorphism $m$ from $\text{Hom}(C)$ to $R$, define the
%%   element as
%%   \[ \pendlambdaXdotY \alpha {\homrappXtoYatZ {\pendappXtoY {m_f} \alpha} {\pendappXtoY {C_r}\alpha} \alpha}  \]

%%   We should be able to show this is an isomorphism in the logic TODO!
%% \end{enumerate}

%% %% This last definition is probably unfamiliar to the reader that is not
%% %% experienced with profunctors.
%% %% %
%% %% However, we can show that the traditional definition is equivalent to
%% %% a natural transformation $\alpha : \cat C_0 \pipe \cdot \vdash
%% %% t_{\alpha} : F(\alpha) \to_{\cat D} G(\alpha')$.

%% %% \begin{definition}[Traditional Natural Transformation]
%% %%   A traditional natural transformation from $\alpha : \cat C_0 \vdash
%% %%   F(\alpha) : \cat D_0$ to $\alpha : \cat \vdash G(\alpha') : \cat
%% %%   D_0$ consists of
%% %%   \begin{enumerate}
%% %%   \item A term $\cdot \vdash t_{\alpha} : F(\alpha) \to_{\cat D} G(\alpha)$
%% %%   \item Such that
%% %%     \[ \phi : \alpha \to_{\cat C} \alpha' \vdash t_{\alpha'} \circ F_1(\phi) \equiv G_1(\phi) \circ t_{\alpha} : F(\alpha) \to_{\cat D} G(\alpha')
%% %%     \]
%% %%   \end{enumerate}
%% %% \end{definition}

%% %% \begin{theorem}[Equivalent Presentations of Natural Transformations]
%% %%   There is a bijection between traditional natural transformations $t
%% %%   : F \to G$ and profunctor homomorphisms $h : \alpha \to_{\cat C}
%% %%   \alpha' \vdash F(\alpha) \to_{\cat D} G(\alpha')$ given by
%% %%   \begin{enumerate}
%% %%   \item From a natural transformation $t$ we define a homomorphism
%% %%     $h(t)$ by composing on the $F$ side. The choice of this side is
%% %%     arbitrary and we could just as easily have used $G$ since they are
%% %%     equal by naturality.
%% %%     \[ \phi : \alpha \to_{\cat C} \alpha' \vdash t_{\alpha'} \circ F_1(\phi) : F(\alpha) \to_{\cat D} G_1(\alpha') \]
%% %%   \item From a homomorphism $\phi.h$, we define a natural transformation $t(h)$ as
%% %%     \[ \alpha \pipe \cdot \vdash h[{\id_{\alpha}}/\phi] \]
%% %%   \end{enumerate}
%% %% \end{theorem}
%% %% \begin{proof}
%% %%   First we show that the maps $h(\cdot),t(\cdot)$ actually produce
%% %%   homomorphisms and natural transformations.
%% %%   \begin{enumerate}
%% %%   \item On the left, we need to show $h(t)_{\phi} \circ F_1(\psi) =
%% %%     h(t)_{|phi \circ \psi}$. Expanding the definition, we just need
%% %%     associativity and functoriality of $F_1$:
%% %%     \begin{align*}
%% %%       h(t)_{\phi} \circ F_1(\psi) &\equiv (t_{\alpha'} \circ F_1(\phi)) \circ F_1(\psi)\\
%% %%       &\equiv t_{\alpha'} \circ F_1(\phi \circ \psi)\\
%% %%       &\equiv h(t)_{\phi \circ \psi}
%% %%     \end{align*}
%% %%     on the right, we use naturality:
%% %%     \begin{align*}
%% %%       G_1(\theta) \circ h(t)_{\phi} &\equiv G_1(\theta) \circ (t_{\alpha'} \circ F_1(\phi))\\
%% %%       &\equiv (t_{\alpha''} \circ F_1(\theta)) \circ F_1(\phi)\\
%% %%       &\equiv t_{\alpha''} \circ F_1(\theta \circ \phi)\\
%% %%       &\equiv t_{\theta \circ \phi}
%% %%     \end{align*}
%% %%   \item In the other direction, to prove naturality:
%% %%     \begin{align*}
%% %%       h[\id_\alpha/\phi] \circ F_1(\psi) &\equiv h[\id_\alpha \circ \psi/\phi]\\
%% %%       &\equiv h[\psi/\phi]\\
%% %%       &\equiv h[\psi \circ \id_{\alpha'}/\phi]\\
%% %%       &\equiv G_1(\psi) \circ h[\id_{\alpha}/\phi]
%% %%     \end{align*}
%% %%   \end{enumerate}
%% %%   Next we seek to prove that the functions are mutually inverse.
%% %%   \begin{enumerate}
%% %%   \item Round trip for homomorphisms:
%% %%     \begin{align*}
%% %%       h(t(h))_{\phi} &= t(h)_{\alpha} \circ F_1[\phi]\\
%% %%       &= h[\id_{\alpha}] \circ F_1[\phi]\\
%% %%       &= h[\id \circ \phi]\\
%% %%       &= h[\phi]
%% %%     \end{align*}
%% %%   \item Round trip for natural transformations uses the fact that
%% %%     functors preserve identity.
%% %%     \begin{align*}
%% %%       t(h(t))_{\alpha} &= h(t)_{\id_{\alpha}}\\
%% %%       &= t_{\alpha} \circ F_1[\id_{\alpha}]\\
%% %%       &= t_{\alpha} \circ \id_{F_0\alpha}\\
%% %%       &= t_{\alpha}
%% %%     \end{align*}
%% %%   \end{enumerate}
%% %% \end{proof}

%% \subsection{Internal Category Translation}



%% \subsection{Universal Properties}

%% Since we have profunctors as a primitive notion, the most natural
%% presentation of universal properties is given by the notion of a
%% functor representing a profunctor.

%% First, we have the ``algebraic'' notion of a functor representing a
%% profunctor, i.e., when a profunctor $R : C\pto D$ is equivalent to
%% $Hom_D(-,G=)$.
%% \begin{definition}[Right Representability]
%%   Let $C, D : \text{Cat}$ and $Q : \textrm{Prof}\,C D$ be a profunctor
%%   between them. Then a \emph{right representation} of $Q$ consists of
%%   \begin{enumerate}
%%   \item A functor $G : \algVarr\, D C$
%%   \item An isomorphism $I,I^-$ between $Q$ and $\text{Hom}(C)[Id;G]$
%%   \end{enumerate}
%% \end{definition}

%% This is a nice definition for applications, but a lot of the structure
%% (homomorphism, functoriality of G) is determined by other components
%% of the structure. This can be simplified to the notion of a
%% ``universal morphism''.

%% \begin{definition}[Universal Morphism]
%%   A profunctor $Q : \textrm{Prof}\, C D$ is right representable when
%%   there exists
%%   \begin{enumerate}
%%   \item A function on objects $G_0 : \varr {D_0} {C_0}$
%%   \item A ``universal morphism'', i.e., a term $\epsilon :
%%     \pendallXdotY \beta {\harrapp Q {G_0 \beta} \beta}$ (not
%%     presupposed to be natural).
%%   \item An ``introduction rule'', i.e., a term $I : \pendallXdotY
%%     \alpha {\homrallXYtoZ \beta {\harrapp {Q_s}\alpha \beta} {\harrapp
%%         {C_1} \alpha {G_0\beta}}}$ (not presupposed to satisfy the
%%     homomorphism condition).
%%   \item Such that composition with $\epsilon$ is a left and right
%%     inverse to $I$. In more detail, we have two equalities.

%%     \begin{enumerate}
%%     \item First, the $\beta$ rule states that composing the universal
%%       morphism with the introduction rule applied to a morphism $q : \harrapp {Q} \alpha {\beta}$ is
%%       equal to the original $q$:

%%       \[ q = \homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {Q_t} \alpha} {(\homrappXtoYatZ {\pendappXtoY I \alpha} {q} \beta)} {G_0 \beta}} {\pendappXtoY \epsilon \beta} {\beta}} {\pendappXtoY {D_r} \beta} {\beta} \]

%%     \item Second, the $\eta$ rule says that every morphism $f :
%%       \harrapp {C_1} \alpha {G_0 \beta}$ can be reconstructed using
%%       $I$ after postcomposing with $\epsilon$:

%%       \[ f = \homrappXtoYatZ {\pendappXtoY I \alpha} {({\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {Q_t} \alpha} {f} {G_0 \beta}} {\pendappXtoY \epsilon \beta} {\beta}} {\pendappXtoY {D_r} \beta} {\beta}  })} {\beta}\]

%%       As a special case, if $f = \pendappXtoY {C_r} {G_0 \beta}$, this shows that $\homrappXtoYatZ {\pendappXtoY I {G_0 \beta}} {\pendappXtoY \epsilon \beta} \beta = \pendappXtoY {C_r} {G_0 \beta}$
%%     \end{enumerate}
%%   \end{enumerate}
%% \end{definition}

%% These two notions turn out to be equivalent because the ``extra''
%% information in the hom isomorphism is in fact fully determined by the
%% data of a universal morphism: the functoriality of $G$ and the
%% naturality of $I,I_{inv}$.
%% %
%% The proof can be broken up into 3 conceptual steps:
%% \begin{enumerate}
%% \item First,, the functoriality of $G$ is derivable from $I,\epsilon$.
%% \item Next, $I_{inv}$ is a homomorphism automatically since composition
%%   with a morphism is automatically natural, where $I_{inv}$ is defined as
%%   \[\pendlambdaXdotY \alpha {\homrlambdaXatYdotZ f {\beta} \homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {Q_t} \alpha} f \beta}{\pendappXtoY \epsilon \beta} {\beta}} {\pendappXtoY {D_r }\beta} {\beta}} \]

%%   \item Finally, $I$ is a homomorphism because the inverse of a
%%     natural transformation is always natural.
%% \end{enumerate}

%% %% Part of this equivalence is the \emph{Yoneda Lemma}, which we state
%% %% now in its internal, parameterized form.
%% %% The usual non-parameterized Yoneda lemma can be formed if we have a
%% %% unit sort.

%% \begin{lemma}[Universal Constructions are functorial]
%%   For any universal construction $(G_0,\epsilon,I)$ for $Q :
%%   \text{Prof}\,C\,D$, we can extend $G_0$ to a functor by defining

%%   \[ G_1 = \pendlambdaXdotY \beta {\homrlambdaXatYdotZ f {\beta'}
%%     {\homrappXtoYatZ {\pendappXtoY I {G_0\beta}} {(\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {Q_t} {G_0\beta}} {\pendappXtoY {C_r} {G_0\beta}} {G_0\beta}} {\pendappXtoY \epsilon {\beta}} \beta} {f} {\beta'})} {\beta'}}
%%   }\]

%%   Furthermore, $I,I^-1$ are homomorphisms with respect to the induced
%%   profunctor structure.
%% \end{lemma}
%% \begin{proof}
%%   \begin{enumerate}
%%   \item To prove $G_1$ preserves identity we need to show
%%     \[ {\homrappXtoYatZ {\pendappXtoY I {G_0\beta}} {(\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {Q_t} {G_0\beta}} {\pendappXtoY {C_r} {G_0\beta}} {G_0\beta}} {\pendappXtoY \epsilon {\beta}} \beta} {\pendappXtoY {D_r} {\beta}} {\beta})} {\beta}} = \pendappXtoY{C_r} {G_0\beta}\]
%%     which is precisely the $\eta$ principle.

%%   \item Next, we show $I_{inv}$ is a homomorphism from $\text{Hom}(C)[\text{Id}(C);G]$ to $Q$.
%%     All of this is under the binders
%%     \[\lambdatrinary {\alpha : C} {f : \harrapp {C_s} \alpha {\alpha'}}
%%     {\alpha' : C} {g : \harrapp{C_s} {\alpha'} {G_0 \beta'}}
%%     {\beta' : D} {h : \harrapp {D_s} {\beta'} {\beta}}
%%     {}\]

%%     % given
%%     % f : a -> a' in C
%%     % g : a' -> G b'
%%     % h : b' -> b

%%     %% I_{inv} (f ;C (g ;C G_1 h)) = Q_t f (I_{inv} g) h

%%     \begin{align*}
%%       & \appunary
%%       {I_{inv}}
%%       \alpha
%%       {(\appbinary {C_t} \alpha f {\alpha'} {(
%%           \appbinary {C_t} {\alpha'} g {G_0\beta'}
%%           {(\appunary {G_1} {\beta'} h \beta)} {G_0 \beta})} {G_0 \beta})}
%%       {\beta}\\
%%       &=
%%       \apptrinary {Q_t} \alpha
%%       {(\appbinary {C_t} \alpha f {\alpha'} {(
%%           \appbinary {C_t} {\alpha'} g {G_0\beta'}
%%           {(\appunary {G_1} {\beta'} h \beta)} {G_0 \beta})} {G_0 \beta})} \beta
%%       {\pendappXtoY \epsilon \beta} \beta
%%       {\pendappXtoY {D_r} \beta} {\beta}\\
%%       &=
%%       \apptrinary {Q_t} \alpha
%%       {(\appbinary {C_t} \alpha f {\alpha'} {(
%%           \appbinary {C_t} {\alpha'} g {G_0\beta'}
%%           {(\appunary {G_1} {\beta'} h \beta)} {G_0 \beta})} {G_0 \beta})} \beta
%%       {\pendappXtoY \epsilon \beta} \beta
%%       {(\appbinary {D_t} \beta {\pendappXtoY {D_r} \beta} \beta {\pendappXtoY {D_r} \beta} \beta)} {\beta}\\
%%       &=
%%       \apptrinary {Q_t} \alpha
%%       {(\appbinary {C_t} \alpha {(\appbinary {C_t} \alpha f {\alpha'} g {G_0 \beta'})} {G_0 \beta'}
%%         {(\appunary {G_1} {\beta'} h \beta)} {G_0 \beta})} \beta
%%       {\pendappXtoY \epsilon \beta} \beta
%%       {(\appbinary {D_t} \beta {\pendappXtoY {D_r} \beta} \beta {\pendappXtoY {D_r} \beta} \beta)} {\beta}\\
%%       &=
%%       \apptrinary {Q_t} \alpha
%%       {(\appbinary {C_t} \alpha f {\alpha'} g {G_0 \beta'})} {G_0 \beta'}
%%       {(\apptrinary {Q_t} {G_0 \beta'}
%%         {(\appunary {G_1} {\beta'} h {\beta})} {G_0 \beta}
%%         {\pendappXtoY \epsilon \beta} \beta
%%         {\pendappXtoY {D_r} \beta} \beta)} \beta
%%       {\pendappXtoY {D_r} \beta} \beta
%%       \\
%%       &=
%%       \apptrinary {Q_t} \alpha
%%       {(\appbinary {C_t} \alpha f {\alpha'} g {G_0 \beta'})} {G_0 \beta'}
%%       {(\appunary {I_{inv}} {G_0 \beta'} {(\appunary {G_1} {\beta'} h \beta)} \beta)} \beta
%%       {\pendappXtoY {D_r} \beta} \beta
%%       \\
%%       &=
%%       \apptrinary {Q_t} \alpha
%%       {(\appbinary {C_t} \alpha f {\alpha'} g {G_0 \beta'})} {G_0 \beta'}
%%       {(\appunary {I_{inv}} {G_0 \beta'} {(\appunary {I} {G_0\beta'} {(\apptrinary {Q_t} {G_0 \beta'} {\pendappXtoY {C_r} {G_0 \beta'}} {G_0 \beta'} {\pendappXtoY \epsilon {\beta'}} {\beta'} h \beta)} \beta)} \beta)} \beta
%%       {\pendappXtoY {D_r} \beta} \beta
%%       \\
%%       &=
%%       \apptrinary {Q_t} \alpha
%%       {(\appbinary {C_t} \alpha f {\alpha'} g {G_0 \beta'})} {G_0 \beta'}
%%       {(\apptrinary {Q_t} {G_0 \beta'} {\pendappXtoY {C_r} {G_0 \beta'}} {G_0 \beta'} {\pendappXtoY \epsilon {\beta'}} {\beta'} h \beta)} \beta
%%       {\pendappXtoY {D_r} \beta} \beta
%%       \\
%%       &=
%%       \apptrinary {Q_t} \alpha
%%       {(\appbinary {C_t} \alpha {(\appbinary {C_t} \alpha f {\alpha'} g {G_0 \beta'})} {G_0 \beta'}
%%         {\pendappXtoY {C_r} {G_0 \beta'}} {G_0 \beta'})} {G_0 \beta'}
%%       {\pendappXtoY \epsilon {\beta'}} {\beta'}
%%       {(\appbinary {D_t} {\beta'} h \beta {\pendappXtoY {D_r} \beta} \beta)} \beta\\
%%       &=
%%       \apptrinary {Q_t} \alpha
%%       {(\appbinary {C_t} \alpha f {\alpha'} g {G_0 \beta'})} {G_0 \beta'}
%%       {\pendappXtoY \epsilon {\beta'}} {\beta'}
%%       {(\appbinary {D_t} {\beta'} {\pendappXtoY {D_r} {\beta'}} {\beta'} h \beta )} \beta\\
%%       &=
%%       \apptrinary {Q_t} \alpha
%%       f {\alpha'}
%%       {(\apptrinary {Q_t} {\alpha'} g {G_0 \beta'} {\pendappXtoY \epsilon {\beta'}} {\beta'}{\pendappXtoY {D_r} {\beta'}} {\beta'})} {\beta'}
%%       h \beta\\
%%       &= \homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {Q_t} \alpha} f {\alpha'}} {(\homrappXtoYatZ {\pendappXtoY {I_{inv}} {\alpha'}} {g} {\beta'})} {\beta'}} {h} {\beta}\\
%%     \end{align*}

    
%%   \item To prove $G_1$ preserves composition given $f : \harrapp {D_1} {\beta} {\beta'}$, $f' : \harrapp {D_1} {\beta'} {\beta''}$:
%%     \begin{align*}
%%       & \appunary {G_1} {\beta} {\appbinary {D_t} {\beta} f {\beta'} {f'} {\beta''}} {\beta'}\\
%%       &= \appunary {I} {G_0 \beta} {(\apptrinary {Q_t} {G_0 \beta} {\pendappXtoY {C_r} {G_0 \beta}} {G_0 \beta} {\pendappXtoY \epsilon {\beta}} {\beta} {({\appbinary {D_t} {\beta} f {\beta'} {f'} {\beta''}})} {\beta''})} {\beta''}\\
%%       &= \appunary {I} {G_0 \beta} {(\apptrinary {Q_t} {G_0 \beta} {(\appbinary {C_t} {G_0 \beta} {\pendappXtoY {C_r} {G_0 \beta}} {G_0 \beta} {\pendappXtoY {C_r} {G_0 \beta}} {G_0 \beta})} {G_0 \beta} {\pendappXtoY \epsilon {\beta}} {\beta} {({\appbinary {D_t} {\beta} f {\beta'} {f'} {\beta''}})} {\beta''})} {\beta''}\\
%%       &=
%%       \appunary {I} {G_0 \beta}
%%       {(\apptrinary {Q_t} {G_0 \beta}
%%         {\pendappXtoY {C_r} {G_0 \beta}} {G_0 \beta}
%%         {(\apptrinary {Q_t} {G_0 \beta}
%%           {\pendappXtoY {C_r} {G_0 \beta}} {G_0 \beta}
%%           {\pendappXtoY \epsilon {\beta}} {\beta}
%%           f {\beta'})} {\beta'}
%%         {f'} {\beta''}
%%         )}
%%       {\beta''}\\
%%       &=
%%       \appbinary {C_t} {G_0 \beta}
%%       {\pendappXtoY {C_r} {G_0 \beta}} {G_0 \beta}
%%       {(\appbinary {C_t} {G_0 \beta}
%%         {(\appunary {I} {G_0 \beta}
%%         {(\apptrinary {Q_t} {G_0 \beta}
%%           {\pendappXtoY {C_r} {G_0 \beta}} {G_0 \beta}
%%           {\pendappXtoY \epsilon {\beta}} {\beta}
%%           f {\beta'})} {\beta'})} {G_0 \beta'}
%%         {(\appunary {G_1} {\beta'} {f'} {\beta''})} {G_0 \beta''})}
%%       {G_0 \beta''}\\
%%       &=
%%       \appbinary {C_t} {G_0 \beta}
%%         {(\appbinary {C_t} {G_0 \beta}
%%           {\pendappXtoY {C_r} {G_0 \beta}} {G_0 \beta}
%%           {(\appbinary {C_t} {G_0 \beta}
%%             {(\appunary {I} {G_0 \beta} {\pendappXtoY \epsilon {\beta}} {\beta})} {G_0 \beta}
%%             {(\appunary {G_1} \beta f {\beta'})} {G_0 \beta'})} {G_0 \beta'})} {G_0 \beta'}
%%         {(\appunary {G_1} {\beta'} {f'} {\beta''})} {G_0 \beta''}\\
%%       &=
%%       \appbinary {C_t} {G_0 \beta}
%%         {(\appbinary {C_t} {G_0 \beta}
%%             {(\appunary {I} {G_0 \beta} {\pendappXtoY \epsilon {\beta}} {\beta})} {G_0 \beta}
%%             {(\appunary {G_1} \beta f {\beta'})} {G_0 \beta'})} {G_0 \beta'}
%%         {(\appunary {G_1} {\beta'} {f'} {\beta''})} {G_0 \beta''}\\
%%       &=
%%       \appbinary {C_t} {G_0 \beta}
%%         {(\appbinary {C_t} {G_0 \beta}
%%             {\pendappXtoY {C_r} {G_0 \beta}} {G_0 \beta}
%%             {(\appunary {G_1} \beta f {\beta'})} {G_0 \beta'})} {G_0 \beta'}
%%         {(\appunary {G_1} {\beta'} {f'} {\beta''})} {G_0 \beta''}\\
%%       &=
%%       \appbinary {C_t} {G_0 \beta}
%%       {(\appunary {G_1} \beta f {\beta'})} {G_0 \beta'}
%%         {(\appunary {G_1} {\beta'} {f'} {\beta''})} {G_0 \beta''}\\
%%       %% &\homrappXtoYatZ {\pendappXtoY {G_1} \beta} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {D_t} {\beta}} {f} {\beta'}} {f'} {\beta''})} {\beta''}\\
%%       %% &={\homrappXtoYatZ {\pendappXtoY I {G_0\beta}} {(\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {Q_t} {G_0\beta}} {\pendappXtoY {C_r} {G_0\beta}} {G_0\beta}} {\pendappXtoY \epsilon {\beta}} \beta} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {D_t} {\beta}} {f} {\beta'}} {f'} {\beta''})} {\beta''})} {\beta''}}\\
%%       %% &={\homrappXtoYatZ {\pendappXtoY I {G_0\beta}} {(\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {Q_t} {G_0\beta}} {({\pendappXtoY {C_r} {G_0\beta}})} {G_0\beta}} {\pendappXtoY \epsilon {\beta}} \beta} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {D_t} {\beta}} {f} {\beta'}} {f'} {\beta''})} {\beta''})} {\beta''}}\\
%%     \end{align*}
%%     %% \[
%%     %%   {\homrappXtoYatZ {\pendappXtoY I {G_0\beta}} {(\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {Q_t} {G_0\beta}} {\pendappXtoY {C_r} {G_0\beta}} {G_0\beta}} {\pendappXtoY \epsilon {\beta}} \beta} {(\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {D_t} {\beta}} {f} {\beta'}} {f'} {\beta''})} {\beta''})} {\beta''}}
%%     %% \]
%%   \end{enumerate}
%% \end{proof}

%% \begin{lemma}[Inverse of homomorphism is a homomorphism]
%%   Let $\phi$ be a homomorphism from $R$ to $S : \text{Prof} C D$ and
%%   let $\psi : \pendallXdotY \alpha {\homrallXYtoZ \beta {\harrapp S
%%       \alpha \beta}{\harrapp R \alpha \beta}}$. If $\psi$ is a
%%   two-sided inverse to $\phi_f$ then $\psi$ is a homomorphism.
%% \end{lemma}
%% \begin{proof}
%%   We need to show the homomorphism condition for $\psi$:
%%   \[ \homrappXtoYatZ {\pendappXtoY \psi \alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {S_t} \alpha} f {\alpha'}} s {\beta'}} g {\beta})} {\beta}
%%     = \homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {R_t} \alpha} f {\alpha'}} {(\homrappXtoYatZ {\pendappXtoY \psi {\alpha'}} s {\beta'})} {\beta'}} g \beta
%%     \]

%%     \begin{align*}
%%       \homrappXtoYatZ {\pendappXtoY \psi \alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {S_t} \alpha} f {\alpha'}} s {\beta'}} g {\beta})} {\beta}
%%       &= \homrappXtoYatZ {\pendappXtoY \psi \alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {S_t} \alpha} f {\alpha'}} {(\homrappXtoYatZ {\pendappXtoY {\phi_f} {\alpha'}} {(\homrappXtoYatZ {\pendappXtoY \psi {\alpha'}} s {\beta'})} {\beta'})} {\beta'}} g {\beta})} {\beta}\\
%%       &= \homrappXtoYatZ {\pendappXtoY \psi \alpha}
%%       {(\homrappXtoYatZ {\pendappXtoY {\phi_f} \alpha} {(\homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {R_t} \alpha} f {\alpha'}} {(\homrappXtoYatZ {\pendappXtoY \psi {\alpha'}} s {\beta'})} {\beta'}} g \beta)} \beta)} {\beta}\\
%%       & = \homrappXtoYatZ {\homrappXtoYatZ {\homrappXtoYatZ {\pendappXtoY {R_t} \alpha} f {\alpha'}} {(\homrappXtoYatZ {\pendappXtoY \psi {\alpha'}} s {\beta'})} {\beta'}} g \beta
%%     \end{align*}
%% \end{proof}



%% %% \subsection{Self-Interpretation: Hom of Internal Profunctors}

%% %% We can define a version of the hom $\homrallXYtoZ \alpha P Q$ on
%% %% \emph{internal} profunctors using a combination of this connective,
%% %% and an \emph{equalizer} to enforce a homomorphism condition.

%% %% \begin{definition}[Internal Covariant Hom of Profunctors]
%% %%   Let $P : \textrm{Prof}\,D\,E$ and $Q : \textrm{Prof}\,C\,E$. Define
%% %%   the covariant Hom $P \triangleright Q : \textrm{Prof}\,C\,D$ by
%% %%   \[ (P \triangleright Q)_1 = \lambda (\alpha;\beta). \equalizeVofWbyXeqYatZ \phi {\homrallXYtoZ \gamma {\harrapp {P_1} \alpha \gamma} {\harrapp {Q_1} \beta \gamma}} {\psi_{dom}} {\psi_{cod}} {\homrallXYtoZ {\gamma'} {\harrapp {P_1 }\beta {\gamma'}} {\homrallXYtoZ {\gamma} {\harrapp {E_1} {\gamma'} \gamma} {\harrapp {Q_1} \alpha \gamma}}}\]
%% %%   where $\psi_{dom}$ and $\chi_{cod}$ are  as
%% %%   \[ \psi_{dom} =\homrlambdaXatYdotZ p {\gamma'} {\homrlambdaXatYdotZ e \gamma
%% %%     {\homrappXtoYatZ {\phi} {(\apptrinary {P_t} \beta {\pendappXtoY {D_r} \beta} \beta p {\gamma'} e \gamma)} \gamma}}
%% %%   \]
%% %%   \[
%% %%   \psi_{cod} = \homrlambdaXatYdotZ p {\gamma'} {\homrlambdaXatYdotZ e \gamma
%% %%     {\apptrinary {Q_t} \alpha {\pendappXtoY {C_r} \alpha} \alpha {(\homrappXtoYatZ \phi {p} {\gamma'})} {\gamma'} e \gamma}}
%% %%   \]
%% %% \end{definition}

%% %% We can easily define a contravariant hom $P \triangleleft Q$ by a dual
%% %% definition (TODO).


%% %% We can also define a left Kan extensions using the contravariant
%% %% cotensors.  Normally the left Kan extension is defined using tensors,
%% %% but the definition using profunctors doesn't look right to me. Let's
%% %% work backwards from the definition of colimit to see why.

%% %% Let $\alpha : \cat C \vdash A : \cat D$ be a functor we want the
%% %% colimit of. The UP of a colimit is that maps out of it are equivalent
%% %% to cocones from $A$. Semi-formally this looks like
%% %% \[ (\colim_{\alpha} A \to_{\cat D} \beta) \cong \forall \alpha:\cat C.~ A \to_{\cat D} \beta \]
%% %% This looks a lot like a cotensor with a trivial domain:
%% %% \[ (\colim_{\alpha} A \to_{\cat D} \beta) \cong \forall \alpha. (() \to_{1} \gamma) \triangleright (A \to_{\cat D} \beta) \]
%% %% Suggesting that we define the left Kan extension profunctor as a
%% %% contravariant cotensor as follows.
%% %% \begin{definition}
%% %%   Let $\cat C,\cat C',\cat D$ be cats and let $\alpha:\cat C \vdash A
%% %%   : \cat D$ and $\alpha : \cat C \vdash J : \cat C'$ be functors.
%% %%   Then the left Kan extension profunctor $\gamma^o:\cat C'; \beta:\cat
%% %%   D \pipe (PLan_J A)[\gamma;\beta]$ is defined as
%% %%   \[
%% %%   \gamma^o:\cat C'; \beta:\cat D \pipe (PLan_J A)[\gamma;\beta]
%% %%   := \forall \alpha : \cat C.~ (J \to_{\cat C'} \gamma) \triangleright (A \to_{\cat D} \beta)
%% %%   \]
%% %%   Then a left Kan extension of $A$ along $J$ is a functor $\gamma :
%% %%   \cat C' \vdash Lan_J A : \cat D$ that represents $PLan_J A$ in that
%% %%   \[ (Lan_J A \to_{\cat D} \beta) \cong (LPan_J A)[\gamma;\beta] \]
%% %% \end{definition}


%% %% \begin{definition}
%%   %% Let $\cat C,\cat C',\cat D$ be cats and let $\alpha:\cat C \vdash
%%   %% : \cat D$ and $\alpha : \cat C \vdash J : \cat C'$ be functors.
%%   %% Then the left Kan extension profunctor $\beta^o:\cat D; \gamma:\cat
%%   %% C' \pipe (PLan_J F)[\beta;\gamma]$ is defined as
%% %%   \[
%% %%   \beta^o:\cat D; \gamma:\cat C' \pipe (PLan_J A)[\beta;\gamma] :=
%% %%   \exists \alpha:\cat C. (\beta \to_{\cat D} A[\alpha]) \odot (J[\alpha] \to_{\cat C'} \gamma)
%% %%   \]
%% %%   And a left Kan extension is a functor $\gamma :\cat C' \vdash Lan_J
%% %%   A : \cat D$ that represents $PLan_J A$ in that
%% %%   \[ (\beta \to_{\cat D} Lan_J A[\alpha]) \cong (PLan_J A)[\beta;\alpha] \]
%% %% \end{definition}


%% %% \begin{lemma}[Parameterized Yoneda Lemma]
%% %%   Given categories $\cat C, \cat D$ and a profunctor $\alpha^o:\cat
%% %%   C;\beta : \cat D \vdash \alpha \to_{Q} \beta$ and a function
%% %%   $\beta : \cat D \vdash G[\beta] : \cat C$, then there is an
%% %%   isomorphism between
%% %%   \begin{enumerate}
%% %%   \item Terms $\cdot \vdash t : G[\beta] \to_{Q} \beta$
%% %%   \item left-homomorphisms $\phi : \alpha \to_{\cat C} G[\beta] \vdash
%% %%     u : \alpha \to_{Q} \beta$ i.e. they satisfy homomorphism on the
%% %%     left (the other side doesn't make sense if $G$ is not a functor):
%% %%     $u[\phi \circ \psi] = u[\phi] \circ \psi$
%% %%   \end{enumerate}
%% %% \end{lemma}
%% %% \begin{proof}
%% %%   First, the constructions
%% %%   \begin{enumerate}
%% %%   \item Given $t$, we define $u(t)$ to be
%% %%     \[\phi : \alpha \to_{\cat C} G[\beta] \vdash t \circ_{Q} \phi : \alpha \to_{Q} \beta\]

%% %%     Which is a left-homomorphism because:
%% %%     \[ (t \circ_{Q} \phi) \circ_{Q} \psi = t \circ_{Q} (\phi \circ_{\cat C} \psi)\]
%% %%   \item Given $u$, we define $t(u)$ to be
%% %%     \[ \cdot \vdash u[\id_{G[\beta]}/\phi] : G[\beta] \to_{Q} \beta \]
%% %%   \end{enumerate}
%% %%   Now we show they are inverse
%% %%   \begin{enumerate}
%% %%   \item First, the very easy case, $\cdot \vdash t(u(t)) : G[\beta] \to_{Q} \beta$:
%% %%     \begin{align*}
%% %%       t \circ_{Q} \id_{G[\beta]} &= t
%% %%     \end{align*}
%% %%     by the fact that $Q$ is a profunctor.
%% %%   \item Next, $\phi : \alpha \to_{\cat C} G[\beta] \vdash u(t(u)) : \alpha \to_{Q} \beta$:
%% %%     \begin{align*}
%% %%       u[\id_{G[\beta]}/\phi] \circ_{Q} \phi &= u[\id \circ_{\cat C} \phi/\phi]\\
%% %%       &= u[\phi/\phi]\\
%% %%       &= u
%% %%     \end{align*}
%% %%     which uses the fact that $u$ is a left-homomorphism.
%% %%   \end{enumerate}
%% %% \end{proof}

%% %% \begin{theorem}[Negative Types and Right Representables are Equivalent]
%% %%   For any profunctor $\alpha^o: \cat C; \beta : \cat D \pipe \alpha
%% %%   \to_{Q} \beta$, there is a bijection between
%% %%   \begin{enumerate}
%% %%   \item Right Represntables $\beta : \cat D \vdash G[\beta] : \cat C$ for $Q$.
%% %%   \item Negative Types $\beta : \cat D \vdash N[\beta] : \cat C$
%% %%     representing $Q$.
%% %%   \end{enumerate}
%% %% \end{theorem}
%% %% \begin{proof}
%% %%   \begin{enumerate}
%% %%   \item Given a right representable $G[\beta]$, we set $N(G)[\beta] =
%% %%     G[\beta]$, the introduction rule is the same and the elimination
%% %%     rule is given as in the Yoneda lemma and the inverse property
%% %%     follows by the Yoneda isomorphism and the fact that $I_G^{-1}$ is
%% %%     an inverse for $I_G$.
%% %%   \item Given a negative type $N[\beta]$ we set $G(N)[\beta] =
%% %%     N[\beta]$, the introduction rule is the same and the inverse
%% %%     introduction rule is given as in the Yoneda lemma.  We need to
%% %%     show that $N[\beta]$ has the structure of a functor and that
%% %%     $I_{N}$ and $I_{N}^{-1}$ are homomorphisms on the right with
%% %%     respect to that structure.  Define $N_1$ as follows:
%% %%     \begin{mathpar}
%% %%       \inferrule
%% %%           {\beta_1^o:\cat D;\beta_2:\cat D \vdash \psi \circ \epsilon : N[\beta_1/\beta] \to_{Q} \beta_2\\
%% %%             \phi : N[\beta_1/\beta] \to_{Q} \beta_2 \vdash I_N[\phi] : N[\beta_1/\beta] \to_{\cat C} N[\beta_2/\beta]
%% %%           }
%% %%           {\beta_1^o:\cat D;\beta_2:\cat D\pipe \psi : \beta_1 \to_{\cat D} \beta_2 \vdash I_N[\psi \circ \epsilon_{\beta_1}/\phi] : N[\beta_1/\beta] \to_{\cat C} N[\beta_2/\beta]}
%% %%     \end{mathpar}
%% %%     We need to show functoriality.
%% %%     For identity we have
%% %%     \begin{align*}
%% %%       I_N[\id_{\beta} \circ \epsilon_{\beta}/\phi] &= I_N[\epsilon_{\beta}]\\
%% %%       &= I_N[\epsilon \circ \id_{N[\beta]}]\\
%% %%       &= \id_{N[\beta]} \tag{$\eta$}
%% %%     \end{align*}
%% %%     For composition,
%% %%     \begin{align*}
%% %%       N_1[\theta] \circ N_1[\psi]
%% %%       &= I_N[\theta \circ \epsilon] \circ I_N[\psi \circ \epsilon]\\
%% %%       &= I_N[(\theta \circ \epsilon) \circ I_N[\psi \circ \epsilon]]\tag{left homomorphism}\\
%% %%       &= I_N[\theta \circ (\epsilon \circ I_N[\psi \circ \epsilon])]\\
%% %%       &= I_N[\theta \circ (\psi \circ \epsilon)] \tag{$\beta$}\\
%% %%       &= I_N[(\theta \circ \psi) \circ \epsilon]\\
%% %%       &= N_1[\theta \circ \psi]
%% %%     \end{align*}
%% %%     Next we show $I_N$ is a right homomorphism, the typing here is
%% %%     $\phi : \alpha \to_{Q} \beta_1, \theta : \beta_1 \to_{\cat D}
%% %%     \beta_2$.
%% %%     \begin{align*}
%% %%       N_1[\theta] \circ I_N[\phi] &= I_N[\theta \circ \epsilon] \circ I_N[\phi]\\
%% %%       &= I_N[\theta \circ \epsilon \circ I_N[\phi]]\tag{left homomorphism}\\
%% %%       &= I_N[\theta \circ \phi] \tag{$\beta$}
%% %%     \end{align*}
%% %%     and to show $I_N^{-1}$ is a right homomorphism under $\phi : \alpha \to_{\cat C}N[\beta_1], \theta : \beta_1 \to_{\cat D} \beta_2$
%% %%     \begin{align*}
%% %%       I_N^{-1}[N_1[\theta] \circ \phi] &= \epsilon \circ (N_1[\theta] \circ \phi) \tag{def}\\
%% %%       &= \epsilon \circ (I_N[\theta \circ \epsilon] \circ \phi)\tag{def}\\
%% %%       &= (\epsilon \circ I_N[\theta \circ \epsilon]) \circ \phi\tag{assoc}\\
%% %%       &= (\theta \circ \epsilon) \circ \phi\tag{$\beta$}\\
%% %%       &= \theta \circ (\epsilon \circ \phi)\tag{assoc}\\
%% %%       &= \theta \circ I_N^{-1}[\phi] \tag{def}
%% %%     \end{align*}
%% %%   \end{enumerate}

%% %%   Next we need to show that this is a \emph{bijection}.
%% %%   \begin{enumerate}
%% %%   \item Starting with a negative type $N[\beta]$, we recover the
%% %%     original $\epsilon$ by the Yoneda lemma.
%% %%   \item Starting with a right representable $G[\beta]$, we recover the
%% %%     original $I_N^{-1}$ by the Yoneda lemma. We need to show that the
%% %%     action of $G$ on arrows is the same as the one defined from $G$
%% %%     viewed as a negative type, which we will call $G_1'$:
%% %%     \begin{align*}
%% %%       G_1'[\theta] &= I_G[\theta \circ \epsilon]\\
%% %%       &= G_1[\theta] \circ I_G[\epsilon]\tag{right homomorphism}\\
%% %%       &= G_1[\theta] \circ I_G[\epsilon \circ \id]\\
%% %%       &= G_1[\theta] \circ \id\\
%% %%       &= G_1[\theta]
%% %%     \end{align*}
%% %%   \end{enumerate}
%% %% \end{proof}


%% %% \subsection{Adjunctions by Universal Morphism}

%% %% As an example of formal category theory in our syntax, let's prove the
%% %% equivalence between two definitions of an adjunction: one by universal
%% %% morphism and the other by natural hom isomorphism.
%% %% %
%% %% Though the definitions and proof will look like we are doing ordinary
%% %% category theory, since it is syntactic it immediately applies to all
%% %% models, including enriched and internal category theory.

%% %% We start with the usual definition of an adjunction using
%% %% hom-isomorphism and a profunctor.
%% %% \begin{definition}
%% %%   Let $C,D$ be categories and $c^o:C_0,d:D_0 \vdash H[c,d]$ a
%% %%   profunctor between them. A \emph{left adjoint} to $H$ consists of
%% %%   \begin{enumerate}
%% %%   \item A functor $c:C \vdash F[c] : D$
%% %%   \item A natural isomorphism $c,d \pipe h : H[c,d] \vdash
%% %%     F_{ind}[h]: D_1[F_0[c],d]$. Call the inverse $g. F_{ind}^{-1}[g]$.
%% %%   \end{enumerate}
%% %% \end{definition}

%% %% \begin{definition}
%% %%   Let $c:C_0,d:D_0 \vdash H[c,d]$ be a profunctor.
%% %%   A \emph{universal $H$-heteromorphism from $C$} consists of
%% %%   \begin{enumerate}
%% %%   \item For every $c:C_0$, an $H$-morphism $\eta_c : H(c,F_0[c])$ for
%% %%     some function $c:C_0 \vdash F_0[c] : D_0$.
%% %%   \item Such that every $h : H[c,d]$ factors through $\eta_c$ in that
%% %%     there is a unique $h : H[c,d] \vdash F_{ind}[h] : D[F_0[c],d]$
%% %%     such that $h = F_{ind}[h] \circ \eta_c$.  Uniqueness means
%% %%     validity of the following rule:
%% %%     \begin{mathpar}
%% %%       \inferrule
%% %%       {g:D[F_0[c],d] \vdash g \circ \eta = h}
%% %%       {g:D[F_0[c],d] \vdash g = F_{ind}[h]}
%% %%     \end{mathpar}
%% %%     (Note that we do not require $F_{ind}$ to be natural in any sense)
%% %%   \end{enumerate}
%% %% \end{definition}

%% %% It is easy to see that a left adjoint gives a universal heteromorphism
%% %% by a Yoneda-like argument:
%% %% \begin{construction}
%% %%   Let $F$ be a left adjoint to $H$. Then we define a left universal
%% %%   $H$-heteromorphism by
%% %%   \begin{enumerate}
%% %%   \item $c \vdash \eta_c = F_{ind}^{-1}[\id[F_0[c]]]: H[c,F_0[c]]$
%% %%   \item Every $h : H[c,d]$ factorizes through $\eta$ because
%% %%     \begin{align*}
%% %%       F_{ind}[h] \circ F_{ind}^{-1}[\id] &= F_{ind}^{-1}[F_{ind}[h] \circ \id] \tag{naturality}\\
%% %%       &= F_{ind}^{-1}[F_{ind}[h]] \tag{unit}\\
%% %%       &= h \tag{isomorphism}
%% %%     \end{align*}
%% %%     This factorization is unique because if $g \circ F^{-1}[\id] = h$,
%% %%     then
%% %%     \begin{align*}
%% %%       F_{ind}[h] &= F_{ind}[g \circ F^{-1}[\id]] \tag{congruence}\\
%% %%       &= g \circ F_{ind}[F^{-1}[\id]] \tag{naturality}\\
%% %%       &= g \circ \id \tag{iso}\\
%% %%       &= g \tag{unit}
%% %%     \end{align*}
%% %%   \end{enumerate}
%% %% \end{construction}

%% %% But the utility of the universal morphism definition is that the
%% %% universal morphism extracted from a left adjoint is enough to uniquely
%% %% reconstruct the rest of the structure, which includes (1)
%% %% functoriality of $F$ and (2) naturality of $F_{ind}$.
%% %% \begin{construction}
%% %%   Let $(F_0,\eta,F_{ind}[h])$ be a left universal $H$-morphism.
%% %%   We extend this to a left adjoint as follows.
%% %%   \begin{enumerate}
%% %%   \item First, $F$ acts on morphisms by
%% %%     \begin{mathpar}
%% %%       \inferrule
%% %%       {
%% %%         \inferrule
%% %%          {f : C[c,c'] \and \eta_{c'} : H[c',F_0[c']]}
%% %%          {f : C[c,c'] \vdash \eta_{c'} \circ f : H[c,F_0[c']]}
%% %%       }
%% %%       {f : C[c,c'] \vdash F_{ind}[\eta_{c'} \circ f] : D[F_0[c],F_0[c']]}
%% %%     \end{mathpar}
%% %%     This preserves identity
%% %%     \begin{mathpar}
%% %%       \inferrule
%% %%       {
%% %%         \inferrule
%% %%         {\id \circ \eta = \eta}
%% %%         {\id = F_{ind}[\eta]}
%% %%       }
%% %%       {\id = F_{ind}[\eta \circ \id]}
%% %%     \end{mathpar}
%% %%     And composition
%% %%     \begin{mathpar}
%% %%       \inferrule
%% %%       {F_{ind}[\eta \circ f] \circ F_{ind}[\eta \circ g] \circ \eta = \eta \circ f \circ g}
%% %%       {F_{ind}[\eta \circ f] \circ F_{ind}[\eta \circ g] = F_{ind}[\eta \circ f \circ g]}
%% %%     \end{mathpar}
%% %%     Which follows by a couple uses of the factorization:
%% %%     \begin{align*}
%% %%       F_{ind}[\eta \circ f] \circ F_{ind}[\eta \circ g] \circ \eta
%% %%       &= F_{ind}[\eta \circ f] \circ \eta \circ g \\
%% %%       &= \eta \circ f \circ g
%% %%     \end{align*}
%% %%   \item Next, we show that $h : H[c,d] \vdash F_{ind}[h] :
%% %%     D[F_0[c],d]$ is a natural transformation. As a first step, we show
%% %%     that $\eta_c : H[c,F_0[c]]$ is natural in $c$ with the action of
%% %%     $F$ on morphisms we have just defined.
%% %%     \[ \eta \circ f = F[f] \circ \eta \]
%% %%     expanding the definition, this is precisely the factorization
%% %%     property:
%% %%     \[ \eta \circ f = F_{ind}[\eta \circ f] \circ \eta \]
    
%% %%     Next, to show that $F_{ind}$ is natural, we need to show that
%% %%     (when it is well-defined):
%% %%     \[F_{ind}[g \circ h \circ f] = g \circ F_{ind}[h] \circ F[f] \]
%% %%     By the factorization property, the following sufficeth:
%% %%     \begin{align*}
%% %%      g \circ F_{ind}[h] \circ F[f] \circ \eta
%% %%      &= g \circ F_{ind}[h] \circ \eta \circ f \tag{naturality of $\eta$}\\
%% %%      &= g \circ h \circ f \tag{factorization}
%% %%     \end{align*}
%% %%   \item Finally, we define $F_{ind}^{-1}[g]$ as
%% %%     \[ g : D[F_0[c],d] \vdash F_{ind}^{-1}[g] = g \circ \eta : H[c,d] \]
%% %%     And we need to confirm that it is (1) a section of $F_{ind}$ (2) a
%% %%     retraction of $F_{ind}$ and (3) natural.
%% %%     \begin{enumerate}
%% %%     \item For retraction we need to show $h \vdash F_{ind}[h] \circ
%% %%       \eta = h$ which is precisely the factorization property.
%% %%     \item For section, we need to show $g \vdash F_{ind}[g \circ \eta]
%% %%       = g$. Immediately the uniquenes principle says its sufficient to
%% %%       show $g \circ \eta = g \circ \eta$.
%% %%     \item For naturality, we need to show
%% %%       \[ F_{ind}^{-1}[k \circ g \circ F[f]] = k \circ F_{ind}^{-1}[g] \circ f \]
%% %%       expanding the definition this is just:
%% %%       \[ k \circ g \circ F[f] \circ \eta = k \circ g \circ \eta \circ f \]
%% %%       which is just naturality of $\eta$.
%% %%     \end{enumerate}
%% %%   \end{enumerate}
%% %% \end{construction}

%% \subsection{Products and Units of Internal Categories}

%% %% While we have now proved a beautiful internal theorem in great
%% %% generality that has many useful instances in different models, we are
%% %% hard pressed to actually \emph{instantiate} the theorem in the syntax
%% %% itself because we can't really come up with any useful universal properties!
%% %% The reason is that Judgment Theory itself is too bare-bones.

%% %% For instance how would we say that a category $\cat C$ has a
%% %% \emph{terminal object}? Well, it would have to be in the first place a
%% %% \emph{single} object in $\cat C$, but so far our syntax only enables
%% %% us to talk about functions and functors. Well an object of $\cat C$ is
%% %% the same as a function from the unit sort, but so far our syntax only
%% %% has base sorts.

%% %% So we see that defining the terminal object, \emph{necessitates} some
%% %% notion of terminal object in our ``metatheory'': Judgment Theory.
%% %% This mysterious and pervasive aspect of higher category theory is
%% %% called the \emph{microcosm principle} because it says that in order to
%% %% discuss a property of a single object in a single category (the
%% %% microcosm), we need the same sort of object at the meta-level (the
%% %% macrocosm). The adage here is ``As above, so below''.

%% %% That might all sound very spiritual, but we'll see that it's actually
%% %% quite a nice heuristic for formalizing universal properties in
%% %% internal category theory.
%% %% %
%% %% In the spirit of this heuristic, instead of first giving a bunch of
%% %% new type constructions for Judgment Theory and then applying them to
%% %% define universal properties, we will consider them in pairs, first
%% %% above, and then below.

%% First we consider the terminal sort and then the idea of a terminal
%% object in an internal category.

%% Next, the terminal sort trivially has a category structure using the
%% trivial judgment as its hom set:

%% \begin{definition}[Terminal Category]
%%   The terminal category $\cat 1$ is defined as having
%%   \begin{enumerate}
%%   \item Its object sort as $1$
%%   \item Its hom set as $\lambda \alpha:1;\beta:1. 1 : \harr 1 1$
%%   \item Its identity arrow is given by $\lambda \alpha: 1. () : 1$
%%   \item Composition is defined by $\phi : 1, \psi : 1 \vdash () : 1$
%%   \item Associativity and unitality are trivial by \textsc{1-$\eta$}
%%   \end{enumerate}
%% \end{definition}

%% \begin{definition}[Terminal Object Specification]
%%   In judgment type theory with a terminal sort/judgment, we can define
%%   for any category $\cat C$ a profunctor $\alpha^o:\cat C;\beta : \cat
%%   1 \pipe 1$, which specifies a terminal object.
%% \end{definition}

%% Now let's instantiate the definition for the terminal object defined
%% as a negative type and as a representable and see how it reproduces
%% the standard type-theoretic and category-theoretic definitions.

%% A representation of $\alpha^o:\cat C; \beta : \cat 1 \pipe 1$ consists
%% of a functor $\beta : \cat 1 \vdash 1_{\cat C} : \cat C$, an introduction rule
%% \[ \phi : 1 \vdash I_{1}[\phi] : \alpha \to_{\cat C} 1_{\cat C}[\beta] \]
%% satisfying $I_{1}[\phi] \circ \gamma =I_{1}[\phi \circ \gamma]$ and an
%% inverse $\psi : \alpha \to_{\cat C} 1_{\cat C}[\beta] \vdash
%% I_{1}^{-1}[\psi] : 1$ which by \textsc{1-$\eta$} is equal to $()$ and
%% therefore every $t : \alpha \to_{\cat C} 1_{\cat C}[\beta]$ is equal
%% to $I_{1}[\phi]$. In light of this it would be appropriate to write
%% $I_1[\phi]$ as $()$ and then the left-homomorphism property is $()
%% \circ \gamma = ()$, which is precisely the definition of substitution.

%% This alternate syntax makes even more sense in light of the negative
%% type presentation. A negative type satisfying the terminal object
%% specification consists of a functor $1_{\cat C}$ as above and an
%% introduction rule as above and an elimination form $\vdash \epsilon :
%% 1$, which is trivial.

%% First the product category
%% \begin{definition}[Product category]
%%   For any categories $\cat C_1$, $\cat C_2$ we can form the product
%%   category whose sort of objects is $\cat C_1 \times \cat C_2$, whose
%%   arrow judgment is $\alpha^o : \cat C_1 \times \cat C_2;\alpha \pipe
%%   (\pi_1 \alpha \to_{\cat C_1} \pi_1 \alpha) \times (\pi_2 \alpha
%%   \to_{\cat C_2} \pi_2 \alpha)$. Identity is given by $\alpha^o : \cat
%%   C_1 \times \cat C_2;\alpha\pipe\cdot \vdash (\id_{\pi_1 \alpha},
%%   \id_{\pi_2 \alpha}) : (\pi_1 \alpha \to_{\cat C_1} \pi_1 \alpha)
%%   \times (\pi_2 \alpha \to_{\cat C_2} \pi_2 \alpha)$ and composition
%%   by
%%   \[
%%   \phi %: (\pi_1 \alpha_0 \to_{\cat C_1} \pi_1 \alpha_1) \times (\pi_2 \alpha_0 \to_{\cat C_2} \pi_2 \alpha_1)
%%   ,
%%   \psi %: (\pi_1 \alpha_1 \to_{\cat C_1} \pi_1 \alpha_2) \times (\pi_2 \alpha_1 \to_{\cat C_2} \pi_2 \alpha_2)
%%   \vdash ((\pi_1 \phi) \circ (\pi_1 \psi), (\pi_2 \psi) \circ (\pi_2 \phi)) :
%%   (\pi_1 \alpha_0 \to_{\cat C_1} \pi_1 \alpha_2) \times (\pi_2 \alpha_0 \to_{\cat C_2} \pi_2 \alpha_2)  
%%   \]
%%   unitality, associativity follow from the same properties of $\cat C_1,\cat C_2$
%% \end{definition}

%% \begin{definition}[Product Functor Specification]
%%   For any category $\cat C$, we can specify the product functor by
%%   \begin{enumerate}
%%   \item The span is $\alpha^o:\cat C; \beta : \cat C \times \cat C \pipe (\alpha \to_{\cat C} \pi_1 \beta) \times (\alpha \to_{\cat C} \pi_2 \beta)$
%%   \item Left Composition is defined as
%%     \[ \phi, \psi \vdash (\pi_1 \phi \circ \psi, \pi_2 \phi \circ \psi)\]
%%   \item Left unitality:
%%     \begin{align*}
%%       (\pi_1 \phi \circ \id, \pi_2 \phi \circ \id)
%%       &= (\pi_1 \phi, \pi_2 \phi)\\
%%       &= \phi\tag{$\times-eta$}
%%     \end{align*}
%%   \item Left associativity:
%%     \begin{align*}
%%       (\phi \circ \psi) \circ \psi'
%%       &= (\pi_1 \phi \circ \psi, \pi_2 \phi \circ \psi) \circ \psi'\\
%%       &= (\pi_1 (\pi_1 \phi \circ \psi, \pi_2 \phi \circ \psi) \circ \psi',
%%       \pi_2 (\pi_1 \phi \circ \psi, \pi_2 \phi \circ \psi) \circ \psi')\\
%%       &= ((\pi_1 \phi \circ \psi) \circ \psi', (\pi_2 \phi \circ \psi) \circ \psi')\\
%%       &= (\pi_1 \phi \circ (\psi \circ \psi'), \pi_2 \phi \circ (\psi \circ \psi'))\\
%%       &= \phi \circ (\psi \circ \psi')
%%     \end{align*}
%%   \item Right composition is defined as
%%     \[ \phi, \theta \vdash (\pi_1 \theta \circ \pi_1 \phi, \pi_2 \theta \circ \pi_2 \phi) \]
%%   \item Right unitality:
%%     \begin{align*}
%%       (\pi_1 (\id,\id) \circ \pi_1 \phi, \pi_2 (\id,\id) \circ \pi_2 \phi)
%%       &= (\id \circ \pi_1 \phi, \id \circ \pi_2 \phi) \tag{$\times-\beta$}\\
%%       &= (\pi_1 \phi, \id \circ \pi_2 \phi)\\
%%       &= \phi \tag{$\times-\eta$}
%%     \end{align*}
%%   \item Right associativity
%%     \begin{align*}
%%       \theta' \circ (\theta \circ \phi)
%%       &= \theta' \circ (\pi_1 \theta \circ \pi_1 \phi, \pi_2 \theta \circ \pi_2 \phi)\\
%%       &= (\pi_1 \theta' \circ \pi_1(\pi_1 \theta \circ \pi_1 \phi, \pi_2 \theta \circ \pi_2 \phi),
%%       \pi_2 \theta' \circ \pi_2(\pi_1 \theta \circ \pi_1 \phi, \pi_2 \theta \circ \pi_2 \phi))\\
%%       &= (\pi_1 \theta' \circ (\pi_1 \theta \circ \pi_1 \phi), \pi_2 \theta' \circ (\pi_2 \theta \circ \pi_2 \phi))\\
%%       &= ((\pi_1 \theta' \circ \pi_1 \theta) \circ \pi_1 \phi, (\pi_2 \theta' \circ \pi_2 \theta) \circ \pi_2 \phi)\\
%%       &= (\pi_1(\theta' \circ \theta) \circ \pi_1 \phi, \pi_2(\theta' \circ \theta) \circ \pi_2 \phi)\\
%%       &= (\theta' \circ \theta) \circ \phi \\
%%     \end{align*}
%%   \end{enumerate}
%% \end{definition}

%% \subsection{Discrete and Codiscrete Categories}

%% If we have terminal judgments, then we can define the
%% \emph{codiscrete} category for any sort $\cat C$.
%% \begin{definition}
%%   The codiscrete category $\textrm{CoDisc} \cat C$ is defined as
%%   \begin{enumerate}
%%   \item Object sort is $\cat C$
%%   \item Morphisms judgment is $1$
%%   \item Identity and composition are given by the unique terms of
%%     those types, making associativity and unitality trivial to verify.
%%   \end{enumerate}
%% \end{definition}

%% If we have \emph{identity} objects, which we write as $\equiv_A$, then we
%% can define discrete categories.
%% \begin{definition}
%%   The discrete category $\textrm{Disc} \cat C$ is defined as
%%   \begin{enumerate}
%%   \item Object sort is $\cat C$
%%   \item Morphisms judgment is $\alpha;\alpha' \pipe \alpha \equiv \alpha'$
%%   \item Identity and composition are defined as in the section on
%%     synthetic category theory.
%%   \end{enumerate}
%% \end{definition}

%% \subsection{Internal Tensor, Cotensor}

%% We should be able to define internal \emph{tensor} using synthetic
%% tensor and coequalizers and also internal \emph{cotensor} using
%% synthetic cotensor and equalizers. These look exactly like the
%% set-theoretic definitions.
%% \begin{definition}
%%   Let $R$ be an internal profunctor from $C$ to $D$ and $S$ be an
%%   internal profunctor from $D$ to $E$.

%%   Then we can define the internal tensor product $R \odot S$, a
%%   profunctor from $C$ to $E$ as
%%   \begin{enumerate}
%%   \item The underlying span can be defined as a quotient of the synthetic tensor product
%%     \[ (R \odot S)[\alpha;\gamma] = \exists \beta:\cat D. R \odot S/Rcomp = Scomp \]

%%     Where R-comp and S-comp have as source the span
%%     \[ \exists \beta:\cat D.~ R[\alpha;\beta] \odot (\exists \beta':\cat D. Hom_C(\beta,\beta') \odot S[\beta';\gamma]) \]
%%     or the isomorphic
%%     \[ \exists \beta':\cat D.~ (\exists \beta:\cat D. R[\alpha;\beta] \odot Hom_C(\beta,\beta')) \odot S[\beta';\gamma] \]
%%     where R-comp composes the $C$-morphism with the $R$-morphism and
%%     S-comp the $S$-morphism.
%%   \item Composition is defined using composition in $R,S$.
%%   \end{enumerate}
%% \end{definition}
%% Note that $R$-comp and $S$-comp are each constructed using the 

%% \begin{definition}
%%   Let $R$ be an internal profunctor from $C$ to $D$ and $S$ be an
%%   internal profunctor from $C$ to $E$. Then the internal contravariant
%%   cotensor product $R \triangleright S$ is defined as
%%   \[ (R \triangleright S)[\beta;\gamma] = \{ p : \forall \alpha:\cat C.~ R[\alpha;\beta] \triangleright S[\alpha;\gamma] 
%%   \pipe R-comp = S-comp \}  \]
%%   R-comp and S-comp have as codomain the span
%%   \[ \forall \alpha:\cat C.~ R[\alpha;\beta] \triangleright \forall \alpha':\cat C.~ Hom_C(\alpha',\alpha) \triangleright S[\alpha';\gamma] \]
%%   or the isomorphic
%%   \[ \forall \alpha':\cat C.~ (\exists \alpha. Hom_C(\alpha',\alpha) \odot R[\alpha;\beta]) \triangleright S[\alpha';\gamma]
%%   \]
%% \end{definition}

%% We can also construct the \emph{free profunctor} from a span using tensor:

%% \begin{definition}
%%   Let $\cat C$ and $\cat D$ be internal categories and let $R[\alpha;\beta]$ be a
%%   span from $Ob(\cat C)$ to $Ob(\cat D)$. Then the free profunctor
%%   extending $R$ to be an internal profunctor from $\cat C$ to $\cat D$ is
%%   \[ F_{\cat C,\cat D}R[\alpha';\beta'] = \exists \alpha. Hom_C(\alpha',\alpha) \odot (\exists \beta. R[\alpha;\beta] \odot Hom_C(\beta,\beta')) \]
%%   or the isomorphic
%%   \[ F_{\cat C,\cat D}R[\alpha';\beta'] = \exists \beta. (\exists \alpha. Hom_C(\alpha',\alpha) \odot R[\alpha;\beta]) \odot Hom_C(\beta,\beta') \]
%% \end{definition}

%% And maybe we can even define the co-free profunctor from a span using cotensor?
%% \begin{definition}
%%   Let $\cat C$ and $\cat D$ be internal categories and let $R[\alpha;\beta]$ be a
%%   span from $Ob(\cat C)$ to $Ob(\cat D)$. Then the co-free profunctor
%%   extending $R$ to be an internal profunctor from $\cat C$ to $\cat D$ is
%%   \[ G_{\cat C,\cat D}R[\alpha';\beta'] =
%%   \forall \alpha. Hom_C(\alpha,\alpha') \triangleright (\forall \beta. R[\alpha;\beta] \triangleleft Hom_D(\beta',\beta)) \]
%%   or the isomorphic
%%   \[ G_{\cat C,\cat D}R[\alpha';\beta'] =
%%   \forall \beta. 
%%   (\forall \alpha. Hom_C(\alpha,\alpha') \triangleright R[\alpha;\beta]) \triangleleft Hom_D(\beta',\beta)) \]
%% \end{definition}



\end{document}
