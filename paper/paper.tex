\documentclass{llncs}

\usepackage{tikz-cd} \usepackage{amssymb} \usepackage{amsmath}
%% \usepackage{amsthm}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{mathpartir}
\usepackage{bbm}
\usepackage{cleveref}
\usepackage[utf8]{inputenc}

\DeclareMathOperator*{\colim}{colim}

\begin{document}
%% \newtheorem{theorem}{Theorem}
%% \newtheorem{lemma}{Lemma}
\newtheorem{construction}{Construction}
%% \newtheorem{definition}{Definition}
\newcommand{\vett}{VETT}
\newcommand{\ohol}{\vett}
\newcommand{\sem}[1]{\llbracket{#1}\rrbracket}
\newcommand{\pto}{\nrightarrow}
\newcommand{\pfrom}{\nleftarrow}
\newcommand{\vcat}{\mathcal}
\newcommand{\cat}{\mathbbm}
\newcommand{\isaSet}{\,\,\textrm{Set}}
\newcommand{\isaTy}{\,\,\textrm{Type}}
\newcommand{\isaCat}{\,\,\textrm{Cat}}
\newcommand{\isSmall}{\,\,\textrm{Small}}
\newcommand{\Set}{\textrm{Set}}
\newcommand{\MonCat}{\textrm{MonCat}}
\newcommand{\SymMonCat}{\textrm{SymMonCat}}
\newcommand{\vtkmnd}{\mathbb{K}\text{Mod} (\vcat{V},T)}
\newcommand{\rmod}{\text{RMod}}
\newcommand{\lmod}{\text{LMod}}

\newcommand{\smallCats}{\text{SmallCat}}
\newcommand{\Cats}{\text{Cat}}
\newcommand{\varr}[2]{\text{Fun}\,{#1}\,{#2}}
\newcommand{\harr}[2]{\text{Prof}\,{#1}\,{#2}}
\newcommand{\harrapp}[3]{#1(#2;#3)}

\newcommand{\defaultObCtx}{\Gamma\pipe\alpha:\cat C}

\newcommand{\jnctx}{\curlyveedownarrow}

\newcommand{\id}{\textrm{id}}
\newcommand{\for}{\textrm{for}\,}
\newcommand{\when}{\textrm{when}\,}
\newcommand{\lett}{\textrm{let}\,}
%% \newcommand{\sort}{\,\,\textrm{sort}}
\newcommand{\Sort}{\textrm{Sort}}
\newcommand{\isadtctx}{\,\,\textrm{type context}}
\newcommand{\isavectx}{\,\,\textrm{trans. context}}
%% \newcommand{\obctx}{\,\,\textrm{object context}}
\newcommand{\boundary}{\,\,\textrm{set context}}
\newcommand{\prof}{\,\,\textrm{span}}
\newcommand{\subst}{\,\,\textrm{subst}}
\newcommand{\sigctx}{\,\,\textrm{sig-ctx}}
\newcommand{\sig}{\,\,\textrm{sig}}
\newcommand{\pipe}{\mathrel{|}}

\newcommand{\punitinXfromYtoZ}[3]{#2 \mathop{\to_{#1}} #3}
\newcommand{\punitrefl}[1]{\textrm{id}_{#1}}
\newcommand{\punitelimtoYwithkontZ}[2]{\textrm{ind}_{\to}(#1,#2)}
\newcommand{\punitelimkontZatABC}[4]{\textrm{ind}_{\to}(#1,#2, #3, #4)}

\newcommand{\odotexists}[1]{\mathop{\overset{\exists #1}\odot}}
\newcommand{\tensorexistsXwithYandZ}[3]{#2 \odotexists{#1} #3}
\newcommand{\tensorintroofXandY}[2]{\textrm{pair}_\odot(#1,#2)}
\newcommand{\tensorintroatXwithYandZ}[3]{(#2,#1,#3)}
\newcommand{\tensorelimXtoYwithkontZ}[3]{\textrm{ind}_{\to}(#1,#2,#3)}
\newcommand{\tensorelimfromWXtoYwithkontZ}[4]{\textrm{ind}_{\odot}(#1,#2,#3,#4)}
\newcommand{\tensorelimVatWtoXtoYwithkontZ}[5]{\textrm{ind}_{\odot}(#4,#2,#1,#3,#5)}
\newcommand{\tensorelimWfromXtoYkontZ}[4]{\textrm{ind}_{\odot}(#4;#1,#2,#3)}
\newcommand{\tensorelimWkontZ}[2]{\textrm{ind}_{\odot}(#2;#1)}

\newcommand{\tlwith}[1]{\mathop{\prescript{#1}{}\triangleleft}}
\newcommand{\tlforall}[1]{\tlwith{\forall #1}}

\newcommand{\trwith}[1]{\mathop{\triangleright^{#1}}}
\newcommand{\trforall}[1]{\trwith {\forall #1}}

\newcommand{\homrallXYtoZ}[3]{#2 \trforall {#1} #3}

\newcommand{\homlallXYtoZ}[3]{#3 \tlforall {#1} #2}

\newcommand{\homrlambdaXatYdotZ}[3]{\lambda^\triangleright (#1, #2). #3}
\newcommand{\homllambdaXatYdotZ}[3]{\lambda^\triangleleft (#2, #1). #3}

\newcommand{\homrappXtoYatZ}[3]{#1 \trwith{#3} #2}
\newcommand{\homlappXtoYatZ}[3]{#2 \tlwith{#3} #1}

\newcommand{\homunary}[4]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} {#4}}}
\newcommand{\hombinary}[6]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} \homrallXYtoZ {#5} {#4} {#6}}}
\newcommand{\homtrinary}[8]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} \homrallXYtoZ {#5} {#4} \homrallXYtoZ {#7} {#6} {#8}}}

\newcommand{\homlunary}[4]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} {#4}}}
\newcommand{\homlbinary}[6]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} \homrallXYtoZ {#5} {#4} {#6}}}
\newcommand{\homltrinary}[8]{\pendallXdotY {#1} {\homrallXYtoZ {#3} {#2} \homrallXYtoZ {#5} {#4} \homrallXYtoZ {#7} {#6} {#8}}}

\newcommand{\lambdaunary}[4]{\pendlambdaXdotY {#1} {\homrlambdaXatYdotZ {#2} {#3} {#4}}}
\newcommand{\lambdabinary}[6]{\lambdaunary{#1}{#2}{#3}{\homrlambdaXatYdotZ{#4}{#5}{#6}}}
\newcommand{\lambdatrinary}[8]{\lambdabinary{#1}{#2}{#3}{#4}{#5}{\homrlambdaXatYdotZ{#6}{#7}{#8}}}

\newcommand{\appunary}[4]{\homrappXtoYatZ {\pendappXtoY {#1} {#2}} {#3} {#4}}
\newcommand{\appbinary}[6]{\homrappXtoYatZ {\appunary{#1}{#2}{#3}{#4}}{#5}{#6}}
\newcommand{\apptrinary}[8]{\homrappXtoYatZ {\appbinary{#1}{#2}{#3}{#4}{#5}{#6}}{#7}{#8}}

\newcommand{\pendallXdotY}[2]{\forall #1. #2}
\newcommand{\pendlambdaXdotY}[2]{\lambda #1. #2}
\newcommand{\pendappXtoY}[2]{#1^{#2}}

\newcommand{\Cat}{\textrm{Cat}}
\newcommand{\Id}[3]{\textrm{Id} #1\,#2\,#3}
\newcommand{\vlambda}[1]{\lambda^{F}{#1}.}
\newcommand{\hlambda}[2]{\lambda^{P}{#1};{#2}.}
\newcommand{\ran}[1]{\textrm{Ran}_{#1}\,}
\newcommand{\weightedLimitDW}[2]{\textrm{lim}^{#2}{#1}\,}

\newcommand{\equalizeVofWbyXeqYatZ}[5]{\{ {#1} : {#2} \pipe {#3} = {#4} : {#5} \}}

\newcommand{\paramPresheaf}[1]{\mathcal P^{#1}}
\newcommand{\pmPresheaf}{\paramPresheaf\pm}
\newcommand{\posPresheaf}{\paramPresheaf+}
\newcommand{\negPresheaf}{\paramPresheaf-}
\newcommand{\negPresheafAppPtoX}[2]{#2\in #1}
\newcommand{\posPresheafAppPtoX}[2]{#1 \ni #2}
\newcommand{\negPresheafApp}{\negPresheafAppPtoX}
\newcommand{\posPresheafApp}{\posPresheafAppPtoX}

\newcommand{\graphProf}[3]{\sum_{{#1};{#2}} #3}

% Algebraic notation
\newcommand{\algCtx}{\textrm{Ctx}}
\newcommand{\algSubst}{\textrm{Subst}}
\newcommand{\algTy}{\textrm{Type}}
\newcommand{\algTm}{\textrm{Term}}
\newcommand{\algCat}{\textrm{Cat}}
\newcommand{\algVarr}{\textrm{Functor}}
\newcommand{\algHCtx}{\textrm{ProfCtx}}
\newcommand{\algHSubst}{\textrm{ProfSubst}}
\newcommand{\algHarr}{\textrm{Prof}}
\newcommand{\algTrans}{\textrm{Trans}}
\newcommand{\algElts}{\textrm{Elts}}
\newcommand{\algEltsI}{\textrm{EltsI}}

\newcommand{\algLHom}{\textrm{LHom}}
\newcommand{\algLHomI}{\textrm{LHomI}}
\newcommand{\algLHomE}{\textrm{LHomE}}
\newcommand{\algRHom}{\textrm{RHom}}
\newcommand{\algRHomI}{\textrm{RHomI}}
\newcommand{\algRHomE}{\textrm{RHomE}}

\newcommand{\algUnit}{\textrm{Unit}}
\newcommand{\algUnitI}{\textrm{UnitI}}
\newcommand{\algUnitE}{\textrm{UnitE}}

\newcommand{\algTensor}{\textrm{Tensor}}
\newcommand{\algTensorI}{\textrm{TensorI}}
\newcommand{\algTensorE}{\textrm{TensorE}}

\newcommand{\algCatTy}{\textrm{Cat}}
\newcommand{\algCatQt}{\textrm{CatQt}}
\newcommand{\algCatUnqt}{\textrm{CatUnQt}}

\newcommand{\algTransTy}{\textrm{Trans}}
\newcommand{\algTransQt}{\textrm{TransQt}}
\newcommand{\algTransUnqt}{\textrm{TransUnQt}}

\newcommand{\algVarrQt}{\textrm{FunctQt}}
\newcommand{\algVarrUnqt}{\textrm{FunctUnQt}}

\newcommand{\quoth}[1]{\lceil{} {#1}\rceil{}}
\newcommand{\unquoth}[1]{\lfloor{} {#1}\rfloor{}}

\newcommand{\citet}[1]{\cite{#1}}
\newcommand{\citep}[1]{(\cite{#1})}

\title{A Constructive Ordered Predicate Logic \\ for Category Theory}
\author{Max S. New\inst{1,2} and Daniel R. Licata\inst{2}}
\institute{University of Michigan \and Wesleyan University}

\maketitle

\begin{abstract}
  We present a domain-specific type theory for constructions and proofs
  in category theory. The type theory axiomatizes notions of category,
  functor, profunctor and a generalized form of natural
  transformations. The type theory imposes an ordered linear restriction
  on standard predicate logic, which guarantees that all functions
  between categories are functorial, all relations are profunctorial,
  and all transformations are natural by construction, with no separate
  proofs necessary. Important category theoretic proofs such as the
  Yoneda lemma and Co-yoneda lemma become simple type theoretic proofs
  about the relationship between unit, tensor and (ordered) function
  types, and can be seen to be ordered refinements of theorems in
  predicate logic.  The type theory is sound and complete for a
  categorical model in \emph{virtual equipments}, which model both
  internal and enriched category theory. While the proofs in our type
  theory look like standard set-based arguments, the syntactic
  discipline ensure that all proofs and constructions carry over to
  enriched and internal settings as well.
\end{abstract}

\section{Introduction}

Category theory is a branch of mathematics that studies
higher-dimensional typed algebraic structures.
%
Originally developed for applications to homological algebra, it was
quickly discovered that categorical structures were common in logic and
computer science.  Formal systems like logics, type theories and
programming languages typically have sound and complete models given by
notions of structured categories,\cite{lawvere,goguen,lambek,moggi}.
%
This Curry-Howard-Lambek correspondence~\cite{curry-howard-lambek}
applies to simply typed lambda calculus~\cite{lambekscott},
computational lambda calculus~\cite{moggi}, linear logic~\cite{girard}
dependent type theory\cite{cartmell1986}, and many other type theories
designed based on category-theoretic semantics.
%
The syntax of a type theory should present an initial object in its
category of models, a category-theoretic reformulation of logical
soundness and completeness.

% TODO: do we have citations for this?
While this research program has been quite successful,
category-theoretic techniques in computer science are sometimes
criticized for being overly complex and hard to learn, especially for
computer scientists who do not have a strong background in pure
mathematics.
%
While in some ways this could be remedied by better introductory
materials, in some ways category theory is objectively complex.
%
In a traditional set-theoretic formulation, notions such as adjoint
functors and limits produce a proliferation of ``naturality'' and
``functoriality'' side-conditions that must be discharged.
%
For example, when constructing an adjoint pair of
functors between two categories, a na\"ive approach would define all of
the data of the action on objects, action on arrows, prove the
functoriality of such actions, as well as construct two families of
transformations, prove they are natural and then finally proving a pair
of equalities relating compositions of natural transformations.
%
Carrying out these proofs explicitly is quite tedious and many newcomers
to are left with the impression that category theory is full of long,
but ultimately trivial constructions.
%
This complexity is compounded when we move from ordinary category theory to
enriched and internal category theory, where constructions must be
additionally proven continuous, monotone, etc, in addition to natural
or functorial.
%
Moreover, these generalizations are often what is needed for programming
language applications; for example, domain- and metric- and
step-index-enriched categories have been used to model recursive
programming languages and internal categories have been used to model
parametricity and gradual
typing\cite{order-enriched-cats,topos-of-trees,reflexive-graphs,double-cats-gradual-typing}.

Fortunately, the tools of category theory itself can be employed to
simplify this complexity, specifically the tools of \emph{higher}
category theory.
%
As an analogy in differential calculus, when an adept analyst writes
down a function, they do not expand out the $\epsilon\mathord{-}\delta$
definition of continuity for a function and proceed from first
principles, but rather use certain \emph{syntactic principles} for
defining functions that are continuous by construction --- e.g. that
composition of continuous functions is continuous and that previously
defined functions are known to be continuous.
%
Similar principles apply to category theory itself: functors and
natural transformations are closed under composition and whiskering
operations, and experienced category theorists rely on these syntactic
principles to eliminate the tedium of explicit proofs.
%
In the case of category theory, these principles can be formalized
using algebraic structures such as 2-categories, bicategories,
(virtual) double categories and pro-arrow equipments\cite{TODO}, an
approach known as \emph{formal category theory}.
%
In these structures, rather than defining notions of category, functor
and natural transformation from first principles, they are axiomatized
in a manner similar to how a category axiomatizes a notion of space
and homomorphism.
%
The formal approaches also apply to enriched and internal settings, so
\emph{formal} category theory proofs apply to these settings.
%
A downside is that these algebraic structures are quite complicated, and
practitioners typically employ either an algebraic combinator syntax or
a 2-dimensional diagrammatic language that can be quite beautiful and
elegant, but is also somewhat removed from the traditional formulation
of category theory in terms of sets and functions.

In this work, we apply the techniques of categorical logic to define a
more familiar logical syntax for carrying out constructions and proofs
in formal category theory.  
%
We call the resulting theory \emph{virtual equipment type theory} (VETT)
as (hyperdoctrines of) \emph{virtual
  equipments}~\cite{virtualequipments}, a particular semantic model of
formal category theory, provide a sound and complete notion of model for
the theory.
%
VETT provides syntax for categories, functors, profunctors, and natural
transformations, which are defined using familiar term syntax and
$\beta\eta$ reasoning principles for $\lambda$-functions, bound
variables, tuples, etc.  
%
By adhering to a \emph{syntactic discipline}, the logic guarantees
that all functor terms are automatically functorial, all and natural
transformation terms are natural.
%
More specifically, the syntax for transformations is a kind of
\emph{indexed, ordered linear} $lambda$ calculus, where the indexing
ensures that transformations are correctly natural and the ordering and
linearity ensure that the proofs are valid in a large class of enriched
and internal categories, such as enrichment in a non-symmetric monoidal
category.
%
VETT provides an alternative alternative to algebraic and
string-diagram syntaxes for working with virtual equipments,
similar to how the lambda calculus provides an alternative to
categorical combinators and string diagram calculi for cartesian
closed categories.


%% The type theoretic syntax allows us to write all of our 
%% constructions are written as if they were
%% ordinary functors and profunctors in set-based category theory.


%%
%% DRL: I know what you mean, but I think conflating set theory and
%% type theory will put some people off... 
%% 
%% This is analogous to the situation in intuitionistic type theory,
%% where the syntax is similar to that of informal set theory, but by
%% restricting to intuitionistic reasoning, the constructions can all be
%% interpreted in models where types are spaces and terms are continuous
%% functions ``for free''.
%

The syntax of \vett{} is an indexed, ordered linear, proof-relevant
variant of predicate logic over a unary type theory.
%
Just as a predicate logic has a notion of type, term, relation and
implication, \vett{} is based on four analogous category theoretic
concepts: categories, functors, profunctors and natural transformations
of profunctors.
%
Categories are treated like types, and the unary functors we consider in
this paper are each represented by a term whose type is a category and
whose one free variable ranges over a category.
%
The analogue of a relation is a \emph{profunctor} (defined below), which
are written as a kind of set with free category variables.  Like the
restriction to unary functors, we restrict to profunctors with two free
variables.
%
The logic is proof-relevant in that the implications of relations are
generalized to natural transformations of profunctors, and we use a
$\lambda$-calculus notation to describe these ``proof terms''.
%
We can strengthen this analogy into a formal construction: any
construction in \vett{} can be erased to a corresponding construction
or proof in predicate logic, as sets, functions and relations define a 
(somewhat degenerate) virtual equipment.
%% %
%% Our syntax highlights this analogy in that some of our constructions
%% are generalizations of set comprehension or power-sets and we use
%% similar notation.

While the restricted syntax developed in this paper does not express
important concepts such as functor categories or opposite categories,
the restriction is natural in that it corresponds exactly to a
well-understood notion of model, virtual equipments, which can express a
great deal of fundamental results and constructions in category
theory~\cite{elements-of-oo-category-theory,
  enriched-indexed-categories}.
%
Moreover, we can work around these unary/binary restrictions to some
extent by viewing the type theory as a domain-specific language embedded
in a metalanguage.  For example, while we cannot talk about functor
categories, we can state a theorem that quantifies over functors using
the meta-language's ``external'' universal quantifier (which does not
have automatic functoriality/naturality properties).  To support this,
\vett includes a third layer, an extensional dependent type theory in
the style of Martin-L\"of type theory. All of our ordered predicate
logic judgments are also be indexed by a context from this dependent
type theory, and the type theory includes universe types for categories,
functors, profunctors and natural transformations.  This allow us to
formalize theorems the logic is too restrictive to encode, analogous to
2-level~\cite{voevodsky13hts,altenkirch+16strict} or indexed type
theories~\cite{isaev21indexed,cervesatopfenning02llf,vakar15linear,krishnaswami+15linear}.

%% This is analogous to the notion of a
%% \emph{2-level type theory}: we add a
%% dependent type theory for reasoning about the terms of our virtual
%% equipment type theory.  The dependent type theory layer also has an
%% additional purpose: since we can quantify over the structures in
%% \vett{}, we can additionally encode \emph{signatures} for \vett{} as
%% simply contexts of the dependent type theory. This allows for a clean
%% formalization of many categorical structures such as monoidal
%% categories, or strong monads.

While we emphasize the applications to enriched and internal category
theory in this work, there is potential for more direct application to
programming language semantics.
%
Ordinary predicate logic is the foundation for logical presentations of
logical relations, such as Abadi-Plotkin logic for parametricity and
LSLR and Iris for step-indexed logical relations proofs
\cite{abadi-plotkin,lslr,iris}.
%
We conjecture that \vett{} might similarly serve as the foundation for
a logic of \emph{ordered} structures, which abound in applications:
rewriting and approximation relations can both be modeled as orderings
and logical relations involving these structures are proven to respect
orderings: operational logical relations must be downward-closed and
approximation relations should satisfy transitivity.
%
Just as LSLR and Iris release the user from the syntactic burden of
explicit step-indexing, \vett{} may be used to release the user from
the syntactic burden of proving downward-closure or transitivity
side-conditions.
%
Additionally, \vett{} may serve as the basis of a future domain specific
proof assistant for category theoretic proofs.  To pilot-test this, we
have formalized the syntax of \vett{} in Agda 2.6.2.2, using the rewrite
mechanism to make \vett's substitution and $\beta$-reduction rules
definitional
equalities.\footnote{\url{https://github.com/maxsnew/virtual-equipments/blob/master/agda/STC.agda}}
We have used this lightweight implementation to check a number of
examples.  

\textbf{Basics of Profunctors.}  While we assume the reader has some
background knowledge of category theory, we briefly define profunctors,
which are not included in many introductory texts.  Recall that a
category $\cat C$ has a collection of objects and morphisms with
identity and composition, and a functor $F : \cat C \to \cat D$ is a
function on objects and a function on morphisms that preserves identity
and composition.  A category can be thought of as a generalization of a
preordered set, which has a set of elements and a binary \emph{relation}
on its objects satisfying reflexivity and transitivity.  A category is
then a \emph{proof-relevant preorder}, where morphisms are the proofs of
ordering, and the reflexivity and transitivity proofs must identity and
unit equations. A functor is then a \emph{proof-relevant monotone
  function}.  Given categories $\mathcal C$ and $\mathcal D$, a
profunctor $R$ from $\mathcal C$ to $\mathcal D$, written $R : \cat C
\pto \cat D$ is a functor $R : {\cat C}^{op} \times {\cat D} \to \Set$.
Because a profunctor outputs a $\Set$ rather than a proposition, it is
itself a \emph{proof-relevant relation}.  Thinking of categories as
proof-relevant preorders, functoriality says that the profunctor is
downward-closed in $\cat C$ and upward-closed in $\cat D$.  Given
profunctors $R, S : \cat C \pto \cat D$, a homomorphism from $R$ to $S$
is simply a natural transformation, which in the preordered setting is
simply an implication of relations.

%% We can think of each set $R(c,d)$ as a set of
%% ``heteromorphisms'' from $c$ (an object of $\cat C$) to $d$ (an object
%% of $\cat D$).  These ``heteromorphisms'' differ from the usual
%% ``homomorphisms'' in a single category $\cat C$ because they relate two
%% objects from two different categories.  Functoriality then defines a
%% notion of composition of heteromorphisms with homomorphisms in $\cat C$
%% and $\cat D$.

Profunctors are very useful for formalizing category theory, but an
additional reason we make them a basic concept of \vett{} is that they
allow us to give a \emph{universal property} for the type of ``morphisms
in a category ${\cat C}$''.  This is analogous to how the $J$
elimination rule for the identity type in Martin-L\"of type theory gives
a universal property for morphisms in a groupoid (the special case of a
category where all morphisms are
invertible)~\cite{hofmann98groupoid,awodeywarren09identity,voevodsky06homotopy}. The reason
profunctors are useful for this purpose is that, for any category $\cat
C$, $\text{Hom}_{\cat C} : \cat C \pto \cat C$ is a profunctor. On
preorders this is just the preorder's ordering relation
itself. Moreover, the hom profunctor is the unit for a composition of
profunctors $R \odot S$ which is defined as a \emph{co-end}.
%% The
%% heteromorphisms of $(R \odot S)(c,e)$ are triples $(d \in \cat D, f \in
%% R(c,d), g \in S(d,e))$ modulo the equivalence relation generated by
%% $(d,f,g) ~ (d', f', g')$ if there exists $h \in D(d,d')$ such that
%% $h\circ f = f'$ and $g'\circ h = g$.
The composition of profunctors is a generalization of the composition of
relations, and just as the equality relation is the identity for the
composition of relations, the hom profunctor is the identity for this
composition.  The unit law for the hom profunctor can be seen as a
``morphism induction'' principle, analogous to the ``path induction''
used in homotopy type theory (though in this paper we consider only
ordinary 1-dimensional categories, not higher generalizations).

%% orphaned --- move later? 
%% For any profunctor $R : \cat C \pto \cat D$ and functors $F : \cat C'
%% \to \cat C$ and $G : \cat D' \to \cat D$, by composition we can define a
%% profunctor $R(F,G)$, the ``restriction'' of $R$ along $F$ and $G$.
The remainder of this paper is organized as follows.  
In Section~\ref{sec:syntax} we introduce the syntax of \vett{}.  In
Section~\ref{sec:examples} we demonstrate how to use our syntax for formal
category theory.  In Section~\ref{sec:semantics}, we develop some model theory
for \vett{}, including a sound and complete notion of categorical model
and sound interpretation in virtual equipments modeling ordinary,
enriched and internal category theory.  In Section~\ref{sec:discussion}, we
discuss related type theories and potential extensions.

\section{Syntax of VETT}
\label{sec:syntax}

In Figure~\ref{fig:hol-cats} we give a table summarizing the
relationship between the judgments and connectives of higher-order
predicate logic with our ordered variant. Due to the incorporation of
variance, some unordered concepts generalize to multiple different
ordered notions. For instance, covariant and contravariant presheaf
categories generalize the power set. Further, because we only have
binary relations rather than relations of arbitrary arity, we have
only restricted forms of universal and existential quantification
which come combined with implications and conjunctions.

\begin{figure}
  \begin{center}
    \begin{tabular}{ |c|c| } 
      \hline
      Higher-Order Logic & Virtual Equipment Type Theory \\
      \hline
      Set $X$ & Category $\mathbb{C}$\\
      $X \times Y$ & $\mathbb C \times \mathbb D$ \\ 
      1 & $1$ \\
      $\mathcal P X$ & $\mathcal P^+ X$ \text{ and } $\mathcal P^- X$ \\
      $\{ (x,y) \in X \times Y | R(x,y) \}$ & $\sum_{\alpha:C;\beta:D} R$\\
      Function $f(x:X) : Y$ & Functor/Object $\alpha:\cat C \vdash A : \cat D$\\
      Relation $R(x,y)$ & Profunctor/Set $\alpha:\cat C; \beta:\cat D \vdash R$\\
      $R \wedge Q$ & $R \times Q$\\
      $\top$ & $1$\\
      $\forall x. P \Rightarrow Q$ & $\homrallXYtoZ {\alpha:\cat C} P Q \text{ and } \homlallXYtoZ {\alpha:\cat C} P Q$ \\
      $\exists x. P \wedge Q$ & $\tensorexistsXwithYandZ {\alpha:\cat C} P Q$\\
      $x =_X y$ & $\punitinXfromYtoZ {\cat C} \alpha \beta$\\
      Proof $\forall \overrightarrow \alpha. R_1 \wedge \cdots \Rightarrow Q$ & Nat. Trans./Element $\alpha_1,x_1: R_1(\alpha_1,\alpha_2),\ldots \vdash t : Q$\\
      \hline
    \end{tabular}
  \end{center}
  \caption{Analogy between Higher-Order Logic and \vett{} Judgments and Connectives}
\label{fig:hol-cats}
\end{figure}

The syntactic forms of \vett{} are given in
Figure~\ref{fig:syntax}.
%
First, we have categories, which are analogous to sorts in a
first-order theory. We have $M$ a base sort, product and unit sorts,
as well as the graph of a profunctor and the negative and positive
presheaf categories.
%
Next, objects $a,b,c$ are the syntax for the \emph{functors} between
categories. We call them objects rather than functors, because in
type-theoretic style, a functor is viewed as a ``generalized object''
parameterized by an input variable $\alpha : \cat C$.
%
Next, sets $P,Q,R$ are the syntax for \emph{sets}. These sets denote
\emph{profunctors}, i.e., a categorification of relations. Similar to
functors, rather than writing profunctors as functions ${\cat
  C}^o\times {\cat D} \to \Set$, we write them as sets with a
contravariant variable $\alpha:\cat C$ and a covariant variable
$\beta:\cat D$. The sets we can define are the Hom-set, the tensor and
internal hom, as well as products of sets, profunctors applied to two
objects and elements of positive and negative presheaves. Finally we
have elements of sets, which correspond to natural transformations of
multiple inputs, where again we view natural transformations valued in
a profunctor as generalized elements of profunctors.

After these forms we have types and terms, which represent the
meta-language that we use to talk about categories/profunctors/natural
transformations.  In addition to standard dependent type theory with
$\Pi$ and $\Sigma$ and identity types, we have universes of
categories, functors, profunctors and natural transformations.

Finally we have several forms of context which are used in the theory.
The contexts $\Gamma$ of term variables with their types are as usual;
we write ${\Gamma \isadtctx}$ to indicate that a context is well-formed.
We name the remaining contexts after the judgements that they are used
by.  The set contexts $\Gamma \vdash \Xi \boundary$, which will be used
to type-check sets, contain object variables with their categories. The
two forms of set context are $\alpha : \cat C$, containing one variable
that can be used both contravariantly and covariantly, and $\alpha :
\cat C ; \beta : \cat D$, containing a contravariant variable $\alpha$
and covariant variable $\beta$.  Finally, the transformation contexts
$\Gamma \vdash \Phi \isavectx$ contain element variables with their sets, alternating with those
sets' object variables with their categories.  A typical $\Phi$ has the
shape
\[
\alpha_1 : \cat C_1, x_1:R_1(\alpha_1,\alpha_2), \alpha_2 : \cat C_2,
x_2:R_2(\alpha_2,\alpha_3), \ldots, R_n(\alpha_n,\alpha_{n+1}),
\alpha_{n+1} : \cat C_{n+1}
\]
and represents the composition of the ``relations'' $R_1, R_2, R_3, \ldots,
R_n$.  We write $d^-(\Phi)$ for the first category variable in $\Phi$
(which we regard as the negative/contravariant position), $d^+(\Phi)$
for the last category variable in $\Phi$ (which we regard as the
positive/covariant position), and $\Phi_1 \jnctx \Phi_2$ for the append
of two category contexts where the last variable in $\Phi_1$ is equal to
the first variable in $\Phi_2$.  Formal inductive definitions are in the
appendix, but intuitively we have: 
\[
\begin{array}{ccl}
d^-(\alpha_1 : \cat C_1, x_1:R_1(\alpha_1,\alpha_2), \ldots, x_n:R_n(\alpha_n,\alpha_n), \alpha_{n+1} : \cat C_{n+1}) & = & \alpha_1 : \cat C_1\\
d^+(\alpha_1 : \cat C_1, x_1:R_1(\alpha_1,\alpha_2), \ldots, x_n:R_n(\alpha_n,\alpha_n), \alpha_{n+1} : \cat C_{n+1}) & = & \alpha_{n+1}:\cat C_{n+1}\\
(\Phi_1,\beta:\cat D) \jnctx (\beta:\cat D, \Phi_2) & = & \Phi_1, \beta : \cat D, \Phi_2
\end{array}
\]

%% %
%% First, we have the types and terms of the logic over our category
%% theory. Types include the usual dependent sum, product and identity
%% types of dependent type theory, as well as several forms that allow us
%% to abstract over the category theoretic constructions: a type $\Cat$
%% of categories, a type $\varr{\cat C}{\cat D}$ for functors from $\cat
%% C$ to $\cat D$, a type $\harr{\cat C}{\cat D}$ for profunctors
%% contravariant in $\cat C$ and covariant in $\cat D$, and finally a
%% type $\pendallXdotY {\alpha:{\cat C}} R$ that, when combined with
%% other constructions on profunctors, allows for abstraction over
%% arbitrary natural transformations.
%% %
%% Terms $L,M,N$ describe the elements of our logic's types, and include
%% the usual constructions as well as forms for defining categories,
%% functors, profunctors and natural transformations.
%% %
%% Next, we have a syntax for categories, which are written using a
%% blackboard font $\cat C, \cat D, \cat E$. Categories include terms $M$
%% of the category type (allowing for abstraction), in addition to
%% primitives for product and unit categories.
%% %
%% Next, we have a syntax for objects of a category, which, because they
%% are typed with respect to an input variable, provide a syntax for
%% functors.
%% %
%% The objects we can define are object variables, application of a
%% functor $M a$, and pairs of objects (for the product category) and the
%% unique object of the unit category.
%% %
%% Next, $P,Q,R$ stand for \emph{sets}, but similar to objects, they are
%% always typed with respect to a contravariant and covariant variable,
%% and so denote profunctors.
%% %
%% These include first the multiplicatives: the hom set
%% $\punitinXfromYtoZ {\cat C} a b$ representing the morphisms from $a$
%% to $b$ in $\cat C$, a tensor product $\tensorexistsXwithYandZ
%% {\beta:\cat D} P Q$, and two kinds of ``ordered function types''
%% $\homrallXYtoZ \beta P Q$ and $\homlallXYtoZ \alpha R S$. 
%% %
%% We also include application of a profunctor term $M$ to two objects,
%% and cartesian product and unit sets.
%% %
%% Next, we have transformations $s,t,u$, which are typed with respect
%% to (0 or more) input and (one) output set.

%% Finally, we have three forms of contexts, type contexts $\Gamma$, set
%% contexts $\Xi$ and transformation contexts $\Phi$. A type context
%% $\Gamma$ is the familiar notion of context from dependent type
%% theory. We use uppercase $X,Y,Z$ for term variables to distinguish
%% them from set variables. Every set expression $P$ must depend on an
%% object of one category covariantly and an object of one category
%% contravariantly, however these are allowed to be the same
%% object. These two scenarios are captured by the notion of set context
%% $\Xi$. The set context $\alpha:\cat C; \beta: \cat D$ gives the common
%% case where the contravariant variable $\alpha$ is different from the
%% covariant variable $\beta$, and the set context $\alpha: \cat C$ alone
%% gives the case where the profunctor depends on the same variable both
%% covariantly and contravariantly. Note that we write object variables
%% as greek letters $\alpha, \beta$. Transformation contexts $\Phi$
%% describe the inputs to a natural transformation. The input variables
%% of a natural transformation $x: R$ stand for elements of sets, but as
%% just described, sets always have covariant and contravariant
%% dependencies. For this reason, transformation contexts include
%% category variables $\alpha: \cat C$ interleaved with the set variables
%% $x : R$, a typical context $\Phi$ would look like $\alpha_1:\cat C_1,
%% x_1:R_1, \alpha_2: \cat C_2, x_2 : R_2, \alpha_3: \cat C_3$, where
%% $R_1$ is parameterized by $\alpha_1$ contravariantly and $\alpha_2$
%% covariantly and $R_2$ is similarly parameterized by
%% $\alpha_2;\alpha_3$. Note that we consider transformation contexts up
%% to associativity in that $(\Phi, x:R, \Psi), y : S, \Sigma$ should be
%% considered equal to $\Phi, x:R, (\Psi, y: S, \Sigma)$.  In this
%% calculus there is no single ``empty'' transformation context, but
%% rather the empty context is one that consists of a single category
%% variable $\alpha:\cat C$ and no set variables. Each form of context
%% has a corresponding form of substitution, denoted using the lower-case
%% form of the same greek letters.

\begin{figure}[t]
  \begin{mathpar}
    \begin{array}{rccl}
      \textrm{Categories} &\cat C, \cat D, \cat E & ::= & \unquoth M \pipe \cat C \times \cat D \pipe \cat 1
      \pipe \graphProf \alpha \beta P \pipe \negPresheaf {\cat C} \pipe \posPresheaf {\cat C}
      \\
      \textrm{Objects} & A, B, C, a, b, c & ::= & \alpha \pipe M a \pipe (a,b)
      \pipe () \pipe \pi_i a \pipe (a_-, a_+, s) \pipe \pi_- a \pipe
      \pi_+ a \pipe \lambda \alpha:\cat C.R \\
      \textrm{Sets} & P,Q,R & ::= & \punitinXfromYtoZ {\cat C} a b \pipe \tensorexistsXwithYandZ {\beta} P Q \pipe \homrallXYtoZ \beta P Q \pipe \homlallXYtoZ \alpha R S 
      \pipe 1 \pipe P \times Q\\
      &&& \pipe \harrapp M a b \pipe \negPresheafAppPtoX a b \pipe \posPresheafAppPtoX a b\\
      \textrm{Elements} & s,t,u & ::= & 
    x \pipe 
    {\punitelimkontZatABC {\alpha. t}{b_1} s {b_2}} \pipe
    \punitrefl b \pipe 
    {\tensorelimWkontZ s {x.\beta.y.r}} \pipe 
    {\tensorintroatXwithYandZ b s t} \pipe
    {\homrappXtoYatZ s t a} \\
    &&&
    \pipe {\homrlambdaXatYdotZ {x}{\alpha} s}\pipe 
    {\homlappXtoYatZ t s a} \pipe 
    {\homllambdaXatYdotZ {x}{\alpha} s} \pipe
    \pi_i s \pipe 
    (s_1,s_2) \pipe
    () \pipe \pi_e a \pipe \pendappXtoY M b \\ 
      \textrm{Type} & A,B,C & ::= &
%      \sum_{X:A} B \pipe \prod_{X:A} B \pipe \Id A M N \\
      \ldots \pipe \smallCats \pipe \Cat \pipe \varr{\cat C}{\cat D}\pipe \harr {\cat C} {\cat D}\pipe \pendallXdotY {\alpha:{\cat C}} R\\
      \textrm{Term} & L,M,N & ::= & 
      %% & X \pipe \lambda X:M. N \pipe M\,N \pipe (M,N) \pipe \pi_1 M \pipe \pi_2 M \mid \text{refl}_{M} \\
      \ldots \pipe \lceil \cat C \rceil \pipe \lambda {\alpha:\cat C}. a \pipe \lambda ({\alpha:\cat C};{\beta: \cat D}). R \mid \lambda \alpha.t \\
      \textrm{Type Context} & \Gamma, \Delta & ::= & \cdot \pipe \Gamma, X : A\\
      \textrm{Set Context} & \Xi, Z & ::= & \alpha:\cat C \pipe \alpha:\cat C;\beta: \cat D\\
      \textrm{Trans. Context} & \Phi,\Psi & ::= & \alpha : \cat C \pipe \Phi , x : P,\beta:\cat D\\
    \end{array}
  \end{mathpar}
  \caption{\vett{} Syntactic Forms}
  \label{fig:syntax}
\end{figure}

Next, we overview our basic judgement forms.  We have
\begin{itemize}
\item Categories: ${\Gamma\vdash \cat C \isaCat}$, where ${\Gamma \isadtctx}$.
  
\item Objects/functors: ${\Gamma \pipe \alpha : \cat C \vdash a : \cat
  D}$, where $\Gamma \vdash \cat C\isaCat$ and $\Gamma \vdash \cat D
  \isaCat$.  Objects are typed with an input object variable $\alpha :
  \cat C$ and an output category $\cat D$; in the semantics, objects are
  modeled as functors $\cat C \to \cat D$.
  
\item Sets/profunctors: ${\Gamma \pipe \Xi \vdash S \isaSet}$, where
  $\Gamma \vdash \Xi \boundary$. A set $S$ is typed with respect to a set
  context $\Xi$ to describe its covariant/contravariant dependence on
  some input objects. Sets are semantically modeled as profunctors.
  
\item Elements/natural transformations: ${\Gamma \pipe \Phi \vdash s :
  R}$, where ${\Gamma \vdash \Phi \isavectx}$ and $\Gamma\pipe
  \underline \Phi \vdash R \isaSet$.  A transformation $s$ has a context
  $\Phi$ of transformation variable and a single set output $R$. To be
  well formed, the context and set must be parameterized by the same
  contravariant and covariant object variables. To ensure this, we use a
  coercion operation $\underline \Phi$ from transformation contexts to
  set contexts that erases everything in the context but the left-most
  and right-most object variables ($\underline{\alpha : \cat C} = \alpha
  : \cat C$ and $\underline{\Phi} = d^-(\Phi);d^+(\Phi)$).

\item Meta-language types and terms: $\Gamma \vdash A \isaTy$ and
  $\Gamma \vdash M : A$ as in standard dependent type theory.
\end{itemize}

%% \begin{figure}
%%   \begin{mathpar}
%%     \inferrule*[right=Cat-form]
%%     {\Gamma \isadtctx}
%%     {\Gamma\vdash \cat C \isaCat}

%%     \inferrule*[right=Ob-form]
%%     {\Gamma \vdash \cat C\isaCat\and \Gamma \vdash \cat D \isaCat}
%%     {\Gamma \pipe \alpha : \cat C \vdash a : \cat D}\\

%%     \inferrule*[right=SetForm]
%%     {\Gamma \isadtctx \and \Gamma \vdash \Xi \boundary}
%%     {\Gamma \pipe \Xi \vdash S \isaSet}

%%     \inferrule*[right=TransFormation]
%%     {\Gamma \vdash \Phi \isavectx\and
%%      \Gamma\pipe \underline \Phi \vdash R \isaSet}
%%     {\Gamma \pipe \Phi \vdash s : R}
%%   \end{mathpar}
%%   \caption{Selected Formation Rules}
%%   \label{fig:formation}
%% \end{figure}

%% The following figures present the basic formation, primitive and
%% admissible equality rules of our type theory, an internal language for
%% virtual double categories with restrictions.
%% %
%% The type theory has 4 central concepts, which we will refer to
%% sometimes using type theoretic/set theoretic and at other times
%% category-theoretic terminology.
%% %
%% In type theoretic terminology, judgment theory has \emph{sorts} $\cat
%% C, \cat D, \cat E$, and \emph{types} $A,B,C$ which have a given sort
%% and are also \emph{parameterized} by an object of some other sort, and
%% so can also be thought of as \emph{functions} with input and output
%% sorts.
%% %
%% Next there are \emph{judgments} $P,Q,R,S$ which are parameterized by
%% two variables.
%% %
%% In $\alpha^o:\cat C;\beta : \cat D \pipe R$, we say $R$ depends on
%% $\alpha$ \emph{contravariantly} and in $\beta$ \emph{covariantly}.
%% %
%% Finally, we have \emph{terms} $s,t,u$ that are elements of some
%% judgment $R$ but are also parameterized by elements of some other
%% judgments which are given by a \emph{context} $\Phi$, which is a
%% ``compatible string'' of judgments where the covariant variable of one
%% judgment is the same as the contravariant variable of the next.
%% %
%% Since these terms are parameterized by other terms, we can see these
%% as \emph{inference rules} for the judgments.

%% At other times we will want to think of these using set-theoretic
%% terminology, in which case we have sets $\cat C,\cat D, \cat E$,
%% functions/elements $A,B,C$, \emph{spans} $R,\ldots$ and morphisms of
%% spans $s,t,u$.
%% %
%% Finally when we develop multicategory theory we will use
%% category-theoretic terminology, in which the structure is most
%% familiar and we have categories, objects/functors,
%% \emph{profunctors}/bimodules and 2-cells/homomorphisms of bimodules.

%% Figure\ref{fig:formation} introduces the formation rules for the basic
%% constructs. Sorts give a syntax for objects of the double
%% category. Types have an output sort and a sorted input variable, and
%% model vertical arrows. Next, judgments have two sorted variables, one
%% contravariant and one covariant, which can be the same
%% variable. Judgments model the horizontal arrows. Next are contexts,
%% whose formation rule is the same as judgments, and which give a syntax
%% for ``compatible strings'' of judgments. Then terms have an input
%% context and an output judgment, which must have the same covariant and
%% contravaiant variables, modeling ``globular'' 2-cells. Finally, we
%% have substitutions for terms, which are typed with respect to an input
%% context, an output context and two types, forming a kind of
%% square. These model the ``compatible string'' of 2-cells that arise in
%% the composition laws.

%% Next, Figure~\ref{fig:basic-rules} gives the basic structural rules of
%% judgment theory, which model composition and restrictions in a virtual
%% double category. First, we have varialbes and substitution for types,
%% modeling identity and composition of vertical arrows. Next, we have
%% restriction of a judgment to more specific types, which is given by
%% substitution of types for the judgment's parameter variables. Next, we
%% have rules for constructing an ``empty'' context, which is just a

The variable rules for objects and elements are 
\[
\inferrule*{}{ \Gamma \pipe \alpha : \cat C \vdash \alpha : \cat C}
\qquad
\inferrule*{}{ \Gamma \pipe \alpha : \cat C, x : R, \beta : \cat D \vdash x : R}
\]
All syntactic forms typed in context admit an action of substitution.
For types and terms, this is as usual. Objects $\alpha:\cat C \vdash a :
\cat D$ can be substituted for object variables $\beta : \cat D$ in
other objects. We can also substitute objects into \emph{sets}, that is,
if we have a set $P$ parameterized by a contravariant variable $\alpha :
\cat C$ and a covariant variable $\beta: \cat D$, then we can substitute
objects $a : \cat C$ and $b : \cat D$ for these variables
$P[a/\alpha;b/\beta]$. This generalizes the ordinary precomposition of a
relation by a function.  Semantically this is the ``restriction'' of a
profunctor along two functors, which is just composition of functors if
a profunctor is viewed as a functor to $\Set$. Modeling this operation
as a substitution considerably simplifies reasoning using profunctors.
%
Finally we have the action of substitution on elements/natural transformations.
First, we can substitute elements/natural transformations for the set
variables in elements, denoting the composition of natural
transformations.  Second, an element is also parameterized
by a contravariant and a covariant category variable $\alpha;\beta$. We
can think of natural transformations as \emph{polymorphic} in the
categories involved, and so when we make a transformation substitution,
we also \emph{instantiate} the polymorphic category variables with
objects.
%
The full syntactic details of substitution are included in the appendix.

\subsection{Category Connectives}

In this section we discuss some connectives for constructing categories,
which are specified by introduction and elimination rules in
Figure~\ref{fig:category-connectives} (the $\beta\eta$ equality and
substitution rules are included in the appendix).  The introduction and
elimination rules make use of functors, profunctors, and natural
transformations.
%
First we introduce the additives: the unit category $1$ and product
category $\cat C \times \cat D$ have the usual introduction and
elimination rules defining functors to/from them.  
%
Next, we introduce the \emph{graph of a profunctor} $\graphProf \alpha
\beta P$. Just as a relation $R : A \times B \to \Set$ can be viewed
as a subset $\{ (a,b) \in A\times B | R(a,b)\}$, any profunctor $P :
C_-^o\times C_+ \to \Set$ can be viewed as a category with a functor
to $C_- \times C_+$ (no op), specifically a two-sided discrete
fibration. In set-based category theory, the objects are triples
$(a_-, a_+, s : P(a_-,a_+))$ and morphisms from $(a_-,a_+, s)$ to
$(a_-',a_+', s')$ are pairs of morphisms $f_- : a_- \to a_-'$ and $f_+
: a_+ \to a_+'$ such that $P(\id,f_+)(s) = P(f_-,\id)(s')$.
%
With various choices of $P$, this connective can be used to define the
arrow category, slice category and comma category constructions.
%
In our syntax we define it as the universal category $\cat C$ equipped
with functors to $\cat C_-$ and $\cat C_+$ and a morphism to $P$.

Lastly, we define the \emph{negative} and \emph{positive} presheaf
categories $\negPresheaf \cat C$ and $\posPresheaf \cat D$. These are
given a syntax suggestive of the fact that they generalize the notion
of a powerset, and so can be thought of as ``power categories''.
%
Note that we include a restriction that the input category is
\emph{small}, which is an inductively defined by saying all base
categories are small, the unit is small, product of small categories
is small and the graph of a profunctor over small categories is
small. Notably, the presheaf categories themselves are not small.
%
The negative presheaf category is defined by its universal property
that a functor into it $\cat D \to \negPresheaf \cat C$ is equivalent
to a profunctor $\cat C^o \times \cat D \to \Set$.
%
The introduction rule constructs an object of the negative presheaf
category from such a profunctor and the elimination rule inverts
it. We use the notation $\negPresheafApp a p$ for the elements of the
induced profunctor.
%
The positive presheaf category is then the dual. In ordinary
set-theoretic category theory the negative presheaf category is the
usual presheaf category $\Set^{\cat C^o}$, and the positive presheaf
category is the opposite of the dual presheaf category $(\Set^{\cat
  D})^o$.

\begin{figure}[t]
  \begin{scriptsize}
  \[
  \begin{array}{l}
    \text{Unit:} \quad
    \inferrule{ ~ }{\Gamma \vdash 1 \isaCat}
    \quad
    \inferrule*{ ~ }{\Gamma\pipe\alpha:C \vdash () : 1}\\\\
    
    \text{Product:} \quad
    \inferrule
        {\Gamma \vdash \cat C_1 \isaCat \and \cat C_2 \isaCat}
        {\Gamma \vdash {\cat C_1} \times {\cat C_2} \isaCat}
    \quad    
    \inferrule
    {\Gamma \pipe \alpha:\cat C \vdash a_1 : \cat C_1 \and \Gamma \pipe \alpha:\cat C \vdash a_2 : \cat C_2}
    {\Gamma \pipe\alpha:\cat C \vdash (a_1,a_2) : {\cat C_1} \times {\cat C_2}}
    \quad
    \inferrule
    {\Gamma \pipe\alpha:\cat C \vdash a : {\cat C_1} \times {\cat C_2}}
    {\Gamma\pipe\alpha:\cat C\vdash \pi_i a : \cat C_i}
    \\\\
    
    \text{Graph of a profunctor:} \\
    \inferrule
    {\Gamma \pipe \alpha:\cat C;\beta:\cat D \vdash P \isaSet}
    {\Gamma \vdash \graphProf{\alpha}{\beta} P \isaCat}
    \quad
    \inferrule
    {\defaultObCtx \vdash a_- : C_-\and
      \defaultObCtx \vdash a_+ : C_+\and
      \defaultObCtx \vdash s : P[a_-/\alpha;a_+/\beta]}
    {\defaultObCtx \vdash (a_-,a_+,s) : \graphProf{\alpha:\cat C_-}{\beta:\cat C_+} P}
    \\
    \inferrule
    {\defaultObCtx \vdash a : \graphProf{\alpha:\cat C_-}{\beta} P}
    {\defaultObCtx \vdash \pi_- a : \cat C_-}
    \quad
    \inferrule
    {\defaultObCtx \vdash a : \graphProf{\alpha}{\beta:C_+} P}
    {\defaultObCtx \vdash \pi_+ a : \cat C_+}
    \quad
    \inferrule
    {\defaultObCtx \vdash a : \graphProf{\alpha}{\beta} P}
    {\defaultObCtx \vdash \pi_e a : P[\pi_-a/\alpha;\pi_+a/\beta]}
    \\\\
    \text{Negative Presehaf:} \\
    \inferrule
    {\Gamma \vdash \cat C \isaCat \and \cat C \isSmall}
    {\Gamma \vdash \negPresheaf {\cat C} \isaCat}
    \quad
    \inferrule
    {\Gamma \pipe d^-\Xi \vdash a : \cat C \and
     \Gamma \pipe d^+\Xi \vdash p : \negPresheaf {\cat C}
    }
    {\Gamma \pipe \Xi \vdash \negPresheafAppPtoX p a \isaSet}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C;\beta:\cat D \vdash R : \isaSet}
    {\Gamma \pipe \beta:\cat D \vdash \lambda \alpha:\cat C. R : \negPresheaf {\cat C}}
    \\
    \\
    \text{Positive Presehaf:} \\
    \inferrule
    {\Gamma \vdash \cat D \isaCat \and \cat D \isSmall}
    {\Gamma \vdash \posPresheaf {\cat D} \isaCat}
    \quad
    \inferrule
    {\Gamma \pipe d^-\Xi \vdash p : \posPresheaf {\cat D}\and
     \Gamma \pipe d^+\Xi \vdash a : \cat D
    }
    {\Gamma \pipe \Xi \vdash \posPresheafAppPtoX p a \isaSet}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C;\beta:\cat D \vdash R : \isaSet}
    {\Gamma \pipe \alpha:\cat C \vdash \lambda \beta:\cat D. R : \posPresheaf {\cat D}}
  \end{array}
  \]
  \end{scriptsize}
  \caption{Category Conectives}
  \label{fig:category-connectives}
\end{figure}

\subsection{Set Connectives}

Next, in Figure~\ref{fig:set-connectives}, we cover the connectives for
the sets/profunctors, which classify elements/natural transformations
(the $\beta/eta$-rules are in the appendix).
%% %
%% The top of the figure includes the formation rules for tensor products
%% $\tensorexistsXwithYandZ \beta P Q$, the covariant $\homrallXYtoZ
%% \alpha R P$ and contravariant homs $\homlallXYtoZ {\alpha} R P$ and
%% the unit type $\punitinXfromYtoZ {\cat C} {a_1}{a_2}$, and
%% the cartesian unit and product types $1$ and $R \times S$.  
%% %
%% The remainder of the figure gives the introduction and elimination rules
%% for these sets .  
%% %
First, the unit set is our syntax for the profunctor of morphisms of a
category $\cat C$, which is well-formed when given two objects of the
same category.  
%
Its introduction and elimination rules are analogous to the usual rules
for equality in Martin-L\"of type theory.  The introduction rule is the
identity morphism (reflexivity) and the elimination rule is an induction
principle: we can use a term of $s : \punitinXfromYtoZ {\cat C} A B$ by
specifying the behavior when $s$ is of the form $\punitrefl \alpha$ in
the form of a continuation $\alpha. t$.  Like the $J$ elimination rule
for equality in Martin-L\"of type theory, $P$ must be ``fully general'',
i.e. well-typed for variables $\alpha$ and $\beta$; this is because for
distinct variables $\alpha$ and $\beta$, $\punitinXfromYtoZ{\cat
  C}{\alpha}{\beta}$ denotes the unit, which has a universal property,
but $\punitinXfromYtoZ{\cat C} A B$ denotes a restriction of a unit,
which in general does not.  Those familiar with linear
logic~\cite{polakawpfenning} might expect a more general rule, with the
continuation $t$ typed in a context $\Phi_l \jnctx \Phi_r$ and $\Phi_l
\jnctx \Phi \jnctx \Phi_r$ as the context of the conclusion of the rule.
Because of dependency, this is not necessarily well-formed in cases
where the endpoints $A$ and $B$ of $\punitinXfromYtoZ{\cat C} A B$ are
not distinct variables.  However, the instances of this more general
rule that do type check are derivable from our more restricted rule
using right/left-hom types.

The tensor product of sets is a kind of combined existential quantifier
and monoidal product, which we combine into a single notation
$\tensorexistsXwithYandZ \beta P Q$, where $\beta$ is the covariant
variable of $P$ and the contravariant variable of $Q$. Then the
covariant variable of the tensor product is the covariant variable of
$Q$ and the contravariant variable similarly comes from $P$.
%
In ordinary category theory, this is the \emph{composition} of
profunctors, and is defined by a coend of a product. We require that
the variable $\beta$ quantifies over a small category $\cat D$, as in
general this composite doesn't exist for large categories.
%
The introduction and elimination are like those for a combined tensor
product and existential type: the introduction rule is a pair of
terms, with an appropriate instantiation of $\beta$, and the
elimination rule says to use a term of a tensor product, it is
sufficient to specify the behavior on two elements typed with an
arbitrary middle object $\beta$.

Next, we introduce the contravariant ($\homlallXYtoZ \alpha R P$) and
covariant ($\homrallXYtoZ \alpha R P$) homs of sets, which are
different from each other because we are in an ordered logic.
%
These are a kind of universally quantified
function type, where the universally quantified variable must occur
with the same variance in domain and codomain. In the contravariant
case, it occurs as the contravariant variable in both, and vice-versa
for the covariant case.
%
To highlight this, the notation for the contravariant dependence puts
the quantified variable on the \emph{left} of the triangle, as
contravariant variables occur to the left of the covariant variable,
and similarly the covariant hom has the quantified variable on the
right.
%
Then the
covariant variable of the contravariant hom set is the covariant
variable of the codomain and, and the contravariant variable of the
hom set is the \emph{covariant} variable of the domain, as the two
contravariances cancel. The covariant hom is dual.
%
Semantically, in ordinary category theory these are known as the
\emph{hom} of profunctors and are constructed using a combination of
an end and a function set.
%
The two connectives have similar introduction and elimination rules in
the form of $\lambda$ terms abstracting over both the object of the
category and the element of the set, and appropriate application
forms.
%
To keep with our invariant that the variable occurrences occur left to
right in the term syntax in a manner matching the context, we write
the covariant application in the usual order $\homrappXtoYatZ s t a$
where the function is on the left and the argument is on the right,
and the contravariant application in the flipped order.
%
We also write the instantiating object as a superscript to
de-emphasize it, as in practice it can often be inferred.

Finally, we have the cartesian unit and product sets, which are
analogous to the normal unit and product of types. The most notable
point to emphasize is that in the formation rule for the product, the
two subformulae should have the same covariant and contravariant
dependence (as with linear logic, some constructions can
syntactically use a variable more than once and still be ``linear'').  
%% the
%% unit constructor ``uses'' all variables and the product ``uses'' all
%% variables in both cases.

\begin{figure}[t]
  % unit,
  \begin{scriptsize}
  \[
  \begin{array}{l}
    
    \text{Unit/morphism set:}\\
    \inferrule
  {\Gamma \pipe d^-\Xi \vdash a_1 : \cat C\\\\ \Gamma \pipe d^+ \Xi \vdash a_2 : \cat C}
  {\Gamma \pipe \Xi \vdash \punitinXfromYtoZ {\cat C} {a_1} {a_2} \isaSet}
  \quad
    \inferrule
    {\Gamma\pipe\beta: \cat D \vdash a : \cat C}
    {\Gamma \pipe \beta : \cat D \vdash \punitrefl a : \punitinXfromYtoZ {\cat C} a a}
    \quad
%%     \inferrule*[right=Unit Elim]
%%     {\Gamma\vdash Q : \harr {\cat C} {\cat C}\and
%%      \Gamma\vdash t : \pendallXdotY {\alpha:\cat C} {\harrapp Q \alpha \alpha}}
%%     {\Gamma \vdash \punitelimtoYwithkontZ Q N :
%%       \pendallXdotY {\alpha_1} {\homrallXYtoZ {\alpha_2} {\punitinXfromYtoZ {\cat C} {\alpha_1}{\alpha_2}} {\harrapp Q {\alpha_1}{\alpha_2}}}}
    \inferrule
    {\Gamma\pipe \alpha:\cat C; \beta:\cat C \vdash P \isaSet \\\\
     \Gamma\pipe \alpha:\cat C\vdash t : P[\alpha/\alpha;\alpha/\beta]\\\\
     \Gamma\pipe\Phi \vdash s : \punitinXfromYtoZ {\cat C} A B}
    {\Gamma \pipe \Phi \vdash \punitelimkontZatABC {\alpha. t} A s B : P[A/\alpha;B/\beta]}
    \\
  %% \inferrule*[right=Tensor intro function]
  %% {}
  %% {\alpha : \cat C, q : Q, \beta : \cat D, r : R, \gamma : \cat E \vdash (q, \beta,r) : \exists \beta : \cat D. Q \odot R}

  %% \inferrule*[right=Tensor introduction]
  %% {\Gamma \vdash P : \harr C D \and
  %%   \Gamma \vdash Q : \harr D E}
  %% {\Gamma\pipe\cdot\vdash \tensorintroofXandY P Q : \pendallXdotY {\alpha} \homrallXYtoZ \beta {\harrapp P \alpha \beta} {\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta}{\harrapp Q \beta \gamma})}}}

    \\
    \text{Tensor product:}\\
    \inferrule
    {\cat D \isSmall\\\\
      \Gamma \pipe d^-\Xi; \beta:D\vdash P \isaSet\\\\
     \Gamma \pipe \beta:D;d^+\Xi \vdash Q \isaSet}
    {\Gamma \pipe \Xi \vdash \tensorexistsXwithYandZ {\beta:D} P Q \isaSet}
    \quad
  \inferrule
  {\Gamma \pipe d^+\Psi_s \vdash b : \cat D\\\\
   \Gamma \pipe \Psi_s \vdash s : P[b/\beta] \\\\
   \Gamma \pipe \Psi_t \vdash t : Q[b/\beta]}
  {\Gamma\pipe\Psi_s \jnctx \Psi_t\vdash \tensorintroatXwithYandZ b s t : \tensorexistsXwithYandZ {\beta : \cat D} P Q}
  \quad
  \inferrule
  {
   \Gamma\pipe \Phi_l \jnctx x:P, \beta:\cat D, y:Q \jnctx \Phi_r \vdash t : R\\\\
   \Gamma \pipe\Phi_m \vdash s : \tensorexistsXwithYandZ {\beta} P Q}
  {\Gamma\pipe\Phi_l\jnctx \Phi_m \jnctx \Phi_r \vdash \tensorelimWkontZ s {x.\beta.y. t} : R}
  \\
  %% \tensorintroatXwithYandZ B M N [\phi,B'/\beta',\psi] = \tensorintroatXwithYandZ {B[B'\beta]} {M[\phi]} {N[\psi]}

  %% \inferrule*[right=Tensor simpl]
  %% {\Gamma\pipe\cdot \vdash R : \harr {C} {E}\and
  %%  \Gamma\pipe\cdot \vdash N : \pendallXdotY {\alpha:C} {\homrallXYtoZ {\beta:D} P {\homrallXYtoZ {\gamma:E} Q {\harrapp R \alpha\gamma}}}}
  %% {\Gamma\pipe\alpha:C,p:\tensorexistsXwithYandZ {\beta:D} P Q,\gamma:E \vdash\tensorelimVatWtoXtoYwithkontZ p \alpha \gamma R N : \harrapp R A G}

%%   \inferrule*[right=Tensor-elim]
%%   {\Gamma \pipe \vdash P : \harr {\cat C} {\cat D}\and\Gamma \vdash Q : \harr {\cat D}{\cat E}\and
%%    \Gamma \vdash R : \harr {\cat C}{\cat E}\and
%%    \Gamma \vdash N : \hombinary \alpha {\harrapp P \alpha \beta} \beta {\harrapp Q \beta \gamma} \gamma {\harrapp R \alpha \gamma}}
%%   {\Gamma \vdash \tensorelimfromWXtoYwithkontZ P Q R N : \homunary \alpha {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\gamma} {\harrapp R \alpha \gamma}}

  \\
  \text{Right hom:} \quad
  \inferrule
  {d^+\Xi \isSmall\\\\ \Gamma \pipe d^+\Xi; \alpha : \cat C \vdash  R
    \isaSet \\\\ \Gamma \pipe  d^-\Xi; \alpha : \cat C \vdash P \isaSet}
  {\Gamma \pipe \Xi \vdash \homrallXYtoZ {\alpha:\cat C} R P \isaSet}
  \quad
  \inferrule
  {\Gamma \pipe \Phi, x : R, \alpha : \cat C \vdash t : P}
  {\Gamma \pipe \Phi \vdash
   \homrlambdaXatYdotZ {x : R} {\alpha : \cat C} t : \homrallXYtoZ \alpha R P}
  \quad
  \inferrule
  {\Gamma\pipe\Phi_f \vdash s : \homrallXYtoZ {\alpha:\cat C} R P \\\\
    d^+\Phi_a \vdash a : \cat C\\\\
    \Phi_a \vdash t : R[a/\alpha]
  }
  {\Gamma\pipe \Phi_f \jnctx \Phi_a \vdash \homrappXtoYatZ s t a : P[a/\alpha]}\\
  \quad

      %% \inferrule*[right=Covar Hom elim simple]
      %% {}
      %% {\alpha: \cat C, f:\forall \gamma. P \triangleleft R, \beta : \cat D, x : R, \gamma : \cat E \vdash f\triangleleft (x, \gamma) : P}

  \\ 
  \text{Left hom:} \quad
  \inferrule
    {d^-\Xi \isSmall\\\\
      \Gamma \pipe \alpha:\cat C; d^-\Xi\vdash R \isaSet \\\\ \Gamma
      \pipe \alpha : \cat C; d^+\Xi\vdash P \isaSet }
    {\Gamma \pipe \Xi \vdash \homlallXYtoZ {\alpha: \cat C} R P \isaSet}
  \quad
  \inferrule
  {\Gamma\pipe\alpha:\cat C, x : R, \Phi \vdash t : P}
  {\Gamma\pipe\Phi \vdash \homllambdaXatYdotZ {x : R} {\alpha : \cat C} t : \homlallXYtoZ \alpha R P}
  \quad
  \inferrule
  {\Gamma \pipe d^-\Phi_a \vdash a : \cat C\\\\
   \Gamma \pipe \Phi_a \vdash s : R[a/\alpha] \\\\
   \Gamma \pipe \Phi_f \vdash t : \homlallXYtoZ {\alpha:\cat C} R P}
  {\Gamma \pipe \Phi_a \jnctx \Phi_f \vdash \homlappXtoYatZ t s a : P[a/\alpha]}\\
  % tensor,
  % hom,
  % cartesian products,
  % 

  \\
  \text{Cartesian unit and products:} \quad
      \inferrule{~}{\Gamma\pipe \Xi \vdash 1 \isaSet}
      \quad
      \inferrule{~}{\Gamma\pipe \Phi \vdash () :  1}
      \\ 
    \inferrule{\Gamma\pipe\Xi \vdash R \isaSet \\\\ \Gamma\pipe\Xi \vdash S\isaSet}
              {\Gamma\pipe\Xi \vdash R \times S\isaSet}
    \quad
    \inferrule{\forall i \in \{1,2\}.~ \Gamma \pipe\Phi \vdash s_i : R_i}{\Gamma \pipe\Phi \vdash (s_1,s_2) : R_1 \times R_2}
    \quad
    \inferrule{\Gamma \pipe\Phi\vdash s : R_1 \times R_2}{\Gamma \pipe\Phi \vdash \pi_i s : R_i}
  \end{array}
  \]
  \end{scriptsize}
  \caption{Set Connectives}
  \label{fig:set-connectives}
\end{figure}

\subsection{Type Connectives}

Finally, we briefly describe the connectives for the ``meta-logic'',
which extends Martin-L\"of type theory with $\Pi$/$\Sigma$ and extensional
identity types (with their standard rules)~\cite{emltt}. We use
extensional identity types so that the description of models is simpler,
but intensional identity types could be used instead.
%
The types we include are \emph{universes} for the object categorical
logic: types of small categories and locally small categories, functors,
profunctors and natural transformations.
%
The rule for the types of small categories and (large) categories are
very similar: any definable category defines an element of type $\Cats$,
and any element of that type can be reflected back into a category. The
only difference for $\smallCats$ is that the categories involved
additionally satisfy $\cat C \isSmall$. Again we elide the $\beta\eta$
principles, which state that $\quoth{-}$ and $\unquoth{-}$ are mutually
inverse.
%
Since every small category $\cat C \isSmall$ is a category $\cat C
\isaCat$, there is a definable inclusion function from $\smallCats$ to
$\Cat$ and the $\beta\eta$ properties ensure that this is a
monomorphism.

Next, we have the types of all functors and profunctors between any
two fixed categories.
%
The introduction and elimination forms are those for unary and binary
function types respectively, where metalanguage terms of type
$\varr{\cat C}{\cat D}$ can be used to construct an object/functor,
while metalanguage terms of type $\harr{\cat C}{\cat D}$ can be used to
construct a set/profunctor.

Finally we include a type $\pendallXdotY {\alpha:\cat C} P$ which we
call the set of ``natural elements'' of $P$.
%
The name comes from the case that $P$ is of the form
$\punitinXfromYtoZ {}{F(\alpha)}{G(\alpha)}$ in which case the type
$\pendallXdotY {\alpha:\cat C} \punitinXfromYtoZ
{}{F(\alpha)}{G(\alpha)}$ can be interpreted as the set of all natural
transformations from $F$ to $G$.
%
More generally this is modeled as an end, and we notate it with a
universal quantifier (just as we do for the quantifiers in left/right
hom types).  Syntactically, $\pendallXdotY{\alpha}{P}$ is a
meta-language type that represents elements/natural transformations with
exactly one free variable.  

\begin{figure}
  \begin{scriptsize}
  \[
  \begin{array}{l}
    \inferrule
    {~}
    {\Gamma\vdash \smallCats}
    \quad
    \inferrule
    {\Gamma \vdash \cat C \isSmall}
    {\Gamma \vdash \quoth {\cat C} : \smallCats}
    \quad
    \inferrule
    {\Gamma \vdash M : \smallCats}
    {\Gamma \vdash \unquoth M \isSmall}
    \quad
    \inferrule
    {~}
    {\Gamma\vdash \Cats}
    \quad
    \inferrule
    {\Gamma \vdash \cat C \isaCat}
    {\Gamma \vdash \quoth {\cat C} : \Cat}
    \quad
    \inferrule
    {\Gamma \vdash M : \Cat}
    {\Gamma \vdash \unquoth M \isaCat}
    \\ \\
    
    \inferrule
    {\Gamma \vdash \cat C \isaCat \and\Gamma \vdash \cat D \isaCat}
    {\Gamma \vdash \varr{\cat C}{\cat D} \isaTy}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C \vdash A : \cat D}
    {\Gamma \vdash \lambda \alpha:\cat C. A : \varr{\cat C}{\cat D}}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C \vdash A : \cat D\and
      \Gamma \vdash M : \varr{\cat D}{\cat E}}
    {\Gamma\pipe \alpha:\cat C \vdash M A : \cat E}
    \\ \\
    
    \inferrule
    {\Gamma \vdash \cat C \isaCat \and\Gamma \vdash \cat D \isaCat}
    {\Gamma \vdash \harr{\cat C}{\cat D} \isaTy}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C;\beta:\cat D \vdash R \,\isaSet}
    {\Gamma \vdash \lambda \alpha:\cat C;\beta:\cat D. R : \harr{\cat C}{\cat D}}
    \quad
    \inferrule
    {\Gamma \vdash M : \harr{\cat C}{\cat D}\\\\
     \Gamma \pipe d^- \Xi \vdash A : \cat C\\\\
     \Gamma \pipe d^+ \Xi \vdash B : \cat C}
    {\Gamma \pipe \Xi \vdash M A\, B \isaSet}
    \\ \\
    
    \inferrule
    {\Gamma \pipe \alpha:\cat C\vdash P \isaSet}
    {\Gamma \vdash \pendallXdotY {\alpha:{\cat C}} P \isaTy}
    \quad
    \inferrule
    {\Gamma \pipe \alpha:\cat C\vdash t : P}
    {\Gamma \vdash \pendlambdaXdotY \alpha t : \pendallXdotY \alpha P}
    \quad
    \inferrule
    {\Gamma \vdash M : \pendallXdotY \alpha P\and
     \Gamma \pipe \beta:\cat D \vdash a : \cat C}
    {\Gamma \pipe \beta:\cat D \vdash \pendappXtoY M a : P[a/\alpha]}
  \end{array}
  \]
  \end{scriptsize}
  \caption{Type Connectives}
\end{figure}

\section{Formal Category Theory in VETT}
\label{sec:examples}

To demonstrate what formal category theory in VETT looks like, we
demonstrate some basic definitions and theorems.  While it is well known
that much category theory can be formalized in virtual equipments, we
show these examples to demonstrate how the VETT syntax gives a more
familiar syntax to these constructions, while still avoiding the need
for explicit naturality and functoriality side conditions.  We have
checked some of the results in this section (e.g. Lemma~\ref{lem:yoneda}
and Lemma~\ref{lem:fubini-short} and the maps in
Lemma~\ref{lem:adjunction}) in
Agda.\footnote{\url{https://github.com/maxsnew/virtual-equipments/blob/master/agda/Examples.agda}}

First, we using the elimination for the unit set, we can see that all
constructions are (pro-)functorial:
\begin{construction}
  For any small category $\cat C$, we can construct natural elements
  \begin{enumerate}
  \item Identity: $\pendallXdotY {\alpha} {\punitinXfromYtoZ {\cat C}{\alpha}{\alpha'}}$
  \item Composition: $\hombinary {\alpha_1} {\punitinXfromYtoZ {}{\alpha_1}{\alpha_2}} {\alpha_2} {\punitinXfromYtoZ {}{\alpha_1}{\alpha_2}} {\alpha_3} {\punitinXfromYtoZ {}{\alpha_1}{\alpha_3}}$
  \item Functoriality: for any $F : \varr {\cat C}{\cat D}$, $\homunary {\alpha_1} {\punitinXfromYtoZ {}{\alpha_1}{\alpha_2}} {\alpha_2} {\punitinXfromYtoZ {} {F(\alpha_1)}{F(\alpha_2)}}$.
   \item Profunctoriality: for any $R : \harr {\cat C}{\cat D}$ if
     $\cat D$ is small then \\ $\homtrinary {\alpha_1}
     {\punitinXfromYtoZ{} {\alpha_1}{\alpha_2}} {\alpha_2}
     {R{\alpha_2}{\beta_2}} {\beta_2} {\punitinXfromYtoZ{} {\beta_2}
       {\beta_1}} {\beta_1} {R\alpha_1\beta_1}$
  \end{enumerate}
\end{construction}
Reflexivity and transitivity generalize the corresponding properties
of equality, with the lack of symmetry being a key feature of the
generalization.
%
In addition, we can prove that the (pro)-functoriality axioms commute
with the composition proof by the $\eta$ principle for the unit.
%
(Pro-)Functoriality generalizes the statement that all functions and
relations respect equality.
%
Naturality is more complex to state, and it is a statement about the
\emph{proofs} so it has no analogue in ordinary higher-order
logic. The following version is stated for any \emph{profunctor}, with
the usual case of naturality arising when $R \alpha \beta =
\punitinXfromYtoZ {\cat C}{F \alpha}{G \beta}$.
\begin{lemma}[Naturality]
  For any $t : \pendallXdotY {\alpha:\cat C}{\harrapp R \alpha
    \alpha}$, by composing with profunctoriality, we can construct
  terms $\alpha_1, f : \punitinXfromYtoZ {\cat C} {\alpha_1}
  {\alpha_2}, \alpha_2 \vdash \textrm{lcomp}(f,\pendappXtoY t
  {\alpha_2})$ and $\textrm{rcomp}(\pendappXtoY t {\alpha_1}, f) :
  \harrapp R {\alpha_1}{\alpha_2}$ that are both equal to
  $\punitelimtoYwithkontZ f {t}$.
\end{lemma}

Next, we turn to some of the central theorems of category theory, the
Yoneda and Co-Yoneda lemmas. Despite being ultimately quite elementary,
these are notoriously abstract. In \ohol{}, we can view these as
ordered generalizations of some very simple tautologies about
equality. For instance, the Yoneda lemma generalizes
the equivalence between the formulae $\forall x. \forall y. x = y
\Rightarrow P y$ and $P x$.
\begin{lemma} \label{lem:yoneda}
  Let $\alpha^o : \cat C$ and $\pi : \negPresheaf {\cat C}$. Then
  \begin{enumerate}
  \item (Yoneda) The profunctor $\homrallXYtoZ {\alpha'} {\punitinXfromYtoZ {\cat C} {\alpha'}{\alpha}} {\negPresheafAppPtoX \pi {\alpha'}}$ is isomorphic to $\negPresheafAppPtoX \pi \alpha$
  \item (Co-Yoneda) The profunctor $\tensorexistsXwithYandZ {\alpha'}{\punitinXfromYtoZ{}{\alpha}{\alpha'}} {\negPresheafAppPtoX \pi \alpha}$ is isomorphic to $\negPresheafAppPtoX \pi \alpha$
  \end{enumerate}
\end{lemma}
The proofs both follow from the unit elimination rule, which is
essential the Yoneda lemma---the two cases of showing (1) is an
isomorphism are precisely the $\beta$ and $\eta$ rules for the unit.

Next, we have the ``Fubini'' theorems, which are analogous to simple
theorems relating tensor and hom types in ordered logic, and whose proofs are 
\begin{lemma}[{Fubini}]
  \label{lem:fubini-short}
  The following isomorphisms hold when the corresponding profunctors
  are well typed.
  \begin{enumerate}
  \item $\tensorexistsXwithYandZ {\beta} {\harrapp P \alpha \beta} {(\tensorexistsXwithYandZ \gamma {\harrapp Q \beta \gamma} {\harrapp R \gamma \delta})} \cong \tensorexistsXwithYandZ {\gamma} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp R \gamma \delta}$
  \item $\homrallXYtoZ {\gamma} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp S \alpha \gamma} \cong \homrallXYtoZ \beta {\harrapp P \alpha \beta} {\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {\harrapp S \alpha \gamma}}$
  \item $\homlallXYtoZ {\alpha} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp S \alpha \gamma} \cong \homlallXYtoZ \beta {\harrapp Q \beta \gamma} {\homlallXYtoZ \alpha {\harrapp P \alpha \beta} {\harrapp S \alpha \gamma}}$
  \item $\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {(\homlallXYtoZ \alpha {\harrapp P \alpha \beta} {\harrapp S \alpha \gamma})} \cong \homlallXYtoZ \alpha {\harrapp P \alpha \beta} {(\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {\harrapp S \alpha \gamma})}$
  \item $\pendallXdotY \alpha \homrallXYtoZ \beta P {P'} \cong \pendallXdotY \beta \homlallXYtoZ \alpha P {P'}$
  \end{enumerate}  
\end{lemma}
\begin{proof}
  Straightforward, for instance the forward direction of (1) is given
  by $\lambdaunary \alpha {x} \delta {\tensorelimWkontZ x
    {p.\beta.y. \tensorelimWkontZ y
      {q.\gamma.r. \tensorintroatXwithYandZ {\gamma}
        {\tensorintroatXwithYandZ \beta p q} {r}}}}$
\end{proof}

Next, we can prove that two definitions of an adjunction are equivalent:
\begin{lemma} \label{lem:adjunction}
  For $R : \varr {\cat D}{\cat C}$ and $L : \varr {\cat
    C}{\cat D}$, the following are in bijection:
  \begin{enumerate}
  \item An isomorphism of profunctors $(\punitinXfromYtoZ {\cat D} {L \alpha}{\beta}) \cong (\punitinXfromYtoZ {\cat C} \alpha {R \beta})$
  \item A unit $\eta : \pendallXdotY \alpha {\punitinXfromYtoZ {\cat C} \alpha
    {R(L\alpha)}}$ and co-unit $\varepsilon: \pendallXdotY \beta
    {\punitinXfromYtoZ {\cat D} {L(R(\beta))}{\beta}}$ satisfying triangle
    identities.
  \end{enumerate}
\end{lemma}
\begin{proof}
  Given the forward homomorphism $\text{lr}$, we can construct $\eta =
  \pendlambdaXdotY \alpha \appunary {\text{lr}} \alpha {\punitrefl
    \alpha} {L \alpha}$ and given the unit we can reconstruct the
  forward homomorphism using
  $\text{comp}$ and $\text{fctor}$ as defined in
  Construction\ref{construction:synthetic-composition} as
  $\appbinary {\text{comp}} \alpha
  {\pendappXtoY \eta \alpha} {R(L\alpha)} {(\appunary
    {\text{fctor}(R)}{L \alpha} {f} {\beta})} {R \beta}$.
\end{proof}

\noindent We can define weighted limits, which include ordinary limits and
Kan extensions.
\begin{definition}
  For a functor $D : \varr {\cat J}{\cat C}$ and a profunctor $W :
  \harr{\cat K}{\cat J}$, the limit of $D$ weighted by $W$ is (if it
  exists) a functor $\weightedLimitDW D W : \varr{\cat K}{\cat C}$
  with an isomorphism $\punitinXfromYtoZ {\cat C} {\alpha} {(\weightedLimitDW D W) k} \cong \homrallXYtoZ j {W k j} {(\punitinXfromYtoZ {\cat C} \alpha {D j})}$
\end{definition}
This generalizes the usual definition that a morphism into a limit is
a cone over the diagram $(\punitinXfromYtoZ {\cat C} \alpha {D j})$ to
be parameterized by a weight $W k j$.
Then we can prove the well-known theorem that right adjoints preserve (weighted) limits:
\begin{theorem}
  If $\weightedLimitDW D W$ exists and is a limit and $R : \varr{\cat
    C}{\cat C'}$ has a left adjoint $L$, then $\lambda
  \kappa. R((\weightedLimitDW D W) \kappa)$ is the limit of $\lambda
  j. R(D j)$ weighted by $W$.
\end{theorem}
\begin{proof}
\[
    \punitinXfromYtoZ {} {\gamma} {R ((\weightedLimitDW D W) \kappa)}
    \cong \punitinXfromYtoZ {}{L \gamma} {(\weightedLimitDW D W) \kappa}
    \cong \homrallXYtoZ {j}{W k j} {\punitinXfromYtoZ {}{L \gamma}{D j}}
    \cong \homrallXYtoZ {j}{W k j} {\punitinXfromYtoZ {}{\gamma}{R(D j)}}\\
\]
This is a high level proof in terms of isomorphisms that may be written
in VETT. The first two steps are the instantiation of assumptions
(adjointness, weighted limits). The last step uses the fact that a
natural isomorphisms lift to natural isomorphism of homs of profunctors.
The construction of this isomorphism illustrates how naturality need not
be proved explicitly in \vett{}.  For any $\phi: \homunary \alpha {R'
  \alpha \beta} \beta {R \alpha \beta}$ and $\psi : \homunary \gamma {S
  \gamma \beta} \beta {S' \gamma \beta}$ we can construct a natural
transformation $\phi \triangleright \psi : \hombinary \gamma
{(\homrallXYtoZ \beta {R \alpha \beta}{S \gamma \beta})} {\alpha}
{R'\alpha\beta} \beta {S'\gamma\beta}$ as \\ $\lambdabinary {\gamma} {f}
{\alpha} r \beta {\appunary \psi \gamma {(\homrappXtoYatZ f {(\appunary
      \phi \alpha r \beta)} \beta)} \beta}$. Furthermore if $\phi$ and
$\psi$ have inverses, then $\phi^{-1} \triangleright \psi^{-1}$ is the
inverse of $\phi \triangleright \psi$.
\end{proof}

%% \subsection{Ordered Theories}

%% Just as we can define theories in first-order logic or higher-order
%% logic by assuming base sorts, function and relation symbols and
%% axioms, we can define ordered, or categorical theories in \ohol{}
%% easily by using the two-level type theory structure.
%% %
%% We can define an \emph{ordered theory} to be any context $\Gamma$ and
%% a translation of theories to be a substitution.
%% %
%% Then we can define theories for cartesian categories, monoidal
%% categories, bicartesian categories, strong monads, (strong)
%% adjunctions.
%% %
%% However the utility for applications to programming language semantics
%% is limited due to the lack of opposite categories.

%% \subsection{Duality Principle}
%% One common source of category theoretic arguments is the duality
%% principle: since the opposite of any category is also a category, any
%% statement that quantifies over all categories is equally true of their
%% opposites. Furthermore in a formal language of categories, any
%% statement can be dualized to a statement where domains and codomains
%% are swapped and composition is flipped.
%% %
%% A similar duality principle holds in SCT.
%% %
%% The basic idea is to reverse the orientation of all \emph{set}
%% expressions by swapping which variable is covariant and which is
%% contravariant.
%% %
%% This has the effect of reversing the order of the context $\Phi$.
%% %
%% We can define this as a translation $\cdot^* : SCT \to SCT$ defined on
%% syntactic forms of SCT in Figure~\ref{fig:duality}.
%% \begin{figure}
%%     \begin{align*}
%%       (\harr {\cat C} {\cat D})^* &= \harr {\cat D^*} {\cat C^*}\\
%%       (\alpha:\cat C)^* &= \alpha: \cat C^*\\
%%       (\alpha:\cat C; \beta:\cat D)^* &= \beta:\cat D^*; \alpha:\cat C^*\\
%%       (\Phi,x:R,\Psi)^* &= \Psi^*,x:R^*, \Phi^*\\
%%       (\homrallXYtoZ \alpha P Q)^* &= \homlallXYtoZ \alpha {P^*} {Q^*}\\
%%       (\homlallXYtoZ \alpha P Q)^* &= \homrallXYtoZ \alpha {P^*} {Q^*}\\
%%       (\homrlambdaXatYdotZ x \alpha s)^* &= \homllambdaXatYdotZ x \alpha s^*\\
%%       (\homrappXtoYatZ s t a)^* &= \homlappXtoYatZ {s^*} {t^*} {a^*}\\
%%       (\tensorexistsXwithYandZ \beta P Q)^* &=
%%       \tensorexistsXwithYandZ \beta {Q^*}{P^*}\\
%%       (\tensorintroatXwithYandZ b s t)^* &= \tensorintroatXwithYandZ {b^*} {t^*} {s^*}\\
%%       (\punitinXfromYtoZ {\cat C} {a_1}{a_2})^* &= \punitinXfromYtoZ {\cat C^*} {a_2^*}{a_1^*}
%%     \end{align*}
%%   \caption{Duality Involution}
%%   \label{fig:duality}
%% \end{figure}

%% MOVE TO APPENDIX examples section?

%% \subsection{Extensionality Axioms}

%% Finally, we discuss some non-theorems that would be desirable to add
%% as axioms to the theory of \ohol{}.
%% %
%% Chief among these are principles about the hom type $\punitinXfromYtoZ
%% {\cat C} \alpha \beta$ when $\cat C$ is a connective.
%% %
%% Since the hom type is defined as a kind of unit type, rather than
%% defined inductively, we are not guaranteed that the hom type for the
%% product category $\cat C \times \cat D$ or the presheaf categories are
%% what we expect.
%% %
%% For the product type, we expect there should be an isomorphism
%% $\punitinXfromYtoZ {\cat C \times \cat D} \alpha \beta \cong
%% (\punitinXfromYtoZ {\cat C} {\pi_1 \alpha} {\pi_1 \beta}) \times
%% (\punitinXfromYtoZ {\cat D} {\pi_2 \alpha} {\pi_2 \beta})$ saying an
%% arrow in a product category is a pair of arrows.
%% %
%% Similarly, the hom type in the presheaf category should be given by
%% the end formula $\punitinXfromYtoZ {\negPresheaf {\cat C}} \alpha
%% \beta \cong \homlallXYtoZ {\gamma}{\negPresheafApp \alpha
%%   \gamma}{\negPresheafApp \beta \gamma}$. This would allow us to
%% relate the Yoneda Lemma \ref{lem:yoneda} to the morphisms of
%% presheaves, and prove that the Yoneda embedding is fully faithful.
%% %
%% We call these extensionality principles because they are analogous to
%% principles such as function extensionality but for the directed hom
%% type rather than equality.

%% The presheaf extensionality principle is independent from the existing
%% axioms of \ohol{}: it is true in the ordinary category theoretic
%% model, but it is false in the set theoretic model. That is, in the set
%% theoretic model, the presheaf category is simply the powerset, the hom
%% type is \emph{equality} and the function profunctor is interpreted as
%% a universally quantified \emph{implication}, but equality in the
%% powerset should be \emph{bi-implication}, so the theorem is false. We
%% expect the product extensionality is independent as well, but a
%% counter-model would likely be quite exotic as we expect it to be
%% provable in a system with functor categories, in analogy with the
%% proof for the identity type in MLTT.
%% %
%% Note that these axioms can easily be added as assumptions in the
%% dependently typed context, though this will break the constructive
%% character of the system. We expect techniques from type theory might
%% be applied to incorporate these as computationally meaningful
%% principles rather than assumed as axioms \cite{obs-tt,xtt,cubical-type-theory}.

\section{Semantics}
\label{sec:semantics}

Next, we develop the basics of the model theory for \ohol{}.
%
First, we demonstrate that a hyperdoctrine of virtual equipments
provides a sound and complete notion of categorical model.
%
Then we instantiate this general notion of model to show that the
\ohol{} can be interpreted in ordinary category theory as well as
enriched, internal and indexed notions.

%% \subsection{Notion of Model}

First, we can model the judgmental structure of the unary type theory
and predicate logic in certain \emph{virtual equipments}
\cite{leinster,crutwell-shulman}, i.e., virtual double categories with
restrictions. We briefly recount the structure present in a virtual
double category, but see \citet{crutwell-shulman} for a precise
definition of the composition rules for 2-cells and functor of virtual
double categories.
%
Our notion here differs from \citet{crutwell-shulman} in several ways
to more closely match our judgmental structure: (1) we require that
restrictions are given as coherent structure rather than mere
existence (2) we include a notion of ``small'' object and (3) we don't
yet require the existence of unit horizontal arrows, as these are
modeled by a connective rather than judgmental structure.

\begin{definition}[Virtual Equipment]
  A virtual equipment $\mathcal V$ consists of
  \begin{enumerate}
  \item A category $V_o$ of ``objects and vertical arrows''
  \item A chosen subset of the objects $V_s \subseteq V_o$ of ``small objects''
  \item A set ${\mathcal V}_h$ of ``horizontal arrows'' with source
    and target functions $s,t : {\mathcal V}_h \to {\mathcal V_o}^2$
  \item Sets of 2-cells of the following form, 
    with appropriate ``multi-categorical'' notions of identity and
    composition:
\[\begin{tikzcd}% https://q.uiver.app/?q=WzAsNixbMCwwLCJDXzAiXSxbMCwyLCJEXzAiXSxbMiwwLCJDX3tufSJdLFsxLDAsIlxcY2RvdHMiXSxbMiwyLCJEXzEiXSxbMSwxLCJcXHBoaSJdLFszLDIsIlJfbiIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9fX1dLFswLDEsIkYiLDJdLFsyLDQsIkciXSxbMSw0LCJTIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn19fV0sWzAsMywiUl8wIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn19fV1d
	{C_0} & \cdots & {C_{n}} \\
	& \phi \\
	{D_0} && {D_1}
	\arrow["{R_n}", "\shortmid"{marking}, from=1-2, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow["g", from=1-3, to=3-3]
	\arrow["S"', "\shortmid"{marking}, from=3-1, to=3-3]
	\arrow["{R_0}", "\shortmid"{marking}, from=1-1, to=1-2]
\end{tikzcd}\]
    We say that the 2-cell $\phi$ has $S$ as codomain, the sequence
    $R_0 \ldots R_n$ as domain and call $f$ and $g$ the left and right
    ``frames'', or that $\phi$ is framed by $f$ and $g$.
  \end{enumerate}
  We say a virtual double category has \emph{split restrictions} when
  for any horizontal arrow $R : C \pto D$ and vertical arrows $f : C'
  \to C$ and $g : D' \to D$ there is a chosen horizontal arrow $R(f,g)
  : C' \pto D'$ with a cartesian 2-cell to $R$ framed by $f,g$ and
  these chosen cartesian lifts are functorial in $f,g$.
  
  A functor of virtual equipments is a functor of the virtual double
  categories that additionally preserves the restrictions and
  smallness of objects.
\end{definition}

In the presence of restrictions, every 2-cell can be represented as a
``globular'' 2-cell where the left and right frame are identities. For
example the 2-cell $\phi$ above can be represented as one with the
same domain but whose codomain is $S(f,g)$. This property is crucial
for the completeness of our semantics as we only include a syntax for these globular terms 
%
Each component of this definition has a direct correspondence to a
syntactic structure in \ohol{}. The objects of $\mathcal V_o$ models
the category judgment and the morphisms model the functor
judgment. The set $\mathcal V_h$ models the profunctor judgment. A
composable string $R_0 \cdots R_n$ models the profunctor contexts. The
2-cells correspond to the natural transformation judgment where we
have taken the restriction $S(F,G)$ of the codomain.

To model the dependent type theory and fact that the categorical
judgments are all typed under a context $\Gamma$ with an action of
substitution, we use a variation on Lawvere's notion of
\emph{hyperdoctrine} for modeling predicate logic\cite{Lawvere69}:
\begin{definition}[Hyperdoctrine of Virtual Equipments]
  A hyperdoctrine of virtual equipments is a pair of a category with
  families $\mathcal C$ and a functor $V^{(-)} : \mathcal C^o \to
  \text{vEq}$ to the category of virtual equipments and functors.
\end{definition}
Categories with families $\mathcal C$ model dependent type theory
\citep{cwf} and for each semantic context $\Gamma$, $V^\Gamma$ models
the VETT judgments in context $\Gamma$, with the functoriality
modeling the fact that all of these judgments admit a well-behaved
action of substitution.

An HVE is then precisely the structure corresponding to the
\emph{judgments} and actions of substitution in VETT.
\begin{construction}[Syntactic Model]
  \label{cons:syn-model}
  The syntax of VETT with any choice of which subset of connectives
  are included presents an HVE.
\end{construction}
\begin{proof}
  Straightforward, defining the category of families using the dependent
  type structure and the virtual equipment structure having
  ($\alpha$-equivalence classes of) syntactic categories as objects,
  functors/sets as vertical/horizontal arrows and interpreting
  compositions/restrictions as substitutions.  The biggest gap is in the
  definition of the 2-cells.  A 2-cell from\\ $(\alpha_1:\cat
  C_1\mathord{;}\alpha_2:\cat C_2\vdash R_1),(\alpha_2:\cat
  C_2;\alpha_3:\cat C_3 \vdash R_2),\ldots$ to $(\beta_1:\cat
  D_1;\beta_2\vdash S)$ with frames $\alpha_1:\cat C_1\vdash b_1 : \cat
  D_1$ and $\alpha_n:\cat C_n\vdash b_2 : \cat D_2$ given by a term
  $x_1:R_1,x_2:R_2\ldots \vdash s :
  S[b_1/\beta_1;b_2/\beta_2]$. Composition is defined by substitution.
\end{proof}

Then the \emph{connectives} of VETT each precisely correspond to a
universal construction of structures in an HVE. The
$\Pi,\Sigma,\text{Id}$ types correspond to their standard semantics in
a CwF and the types of categories, functors etc as representing
objects for the virtual equipment structures. Products of categories
are interpreted as products in the vertical category, and products of
sets as products in the category of pro-arrows and 2-cells. The units,
tensor and covariant and contravariant homs are modeled by the
universal properties of the same names, as described for instance in
\citet{shulmanFrBicats}. The graph of a profunctor is modeled by
\emph{tabulators} \citet{grandis-pare}. Finally, the covariant and
contravariant presheaf categories can be described as a weakening of
the definition of a Yoneda equipment from \citet{yosegi-boxes} to
virtual double categories. More detailed descriptions of these
universal properties are included in the appendix.
%
Then we can package up the soundness and completeness of this notion
of categorical model in the following modular initiality theorem.

\begin{theorem}[Initiality]
  The syntax of VETT with almost any choice of connectives presents an
  HVE that is initial in the category of HVEs with the chosen
  instances of the universal properties and functors that preserve
  such chosen instances. The only exception is that if units are
  included, then contravariant and covariant hom sets must be included
  as well.
\end{theorem}
\begin{proof}
  It is straightforward to extend the construction
  \ref{cons:syn-model} for any connective modularly, with the
  exception that the unit relies on the presence of hom sets in order
  to satisfy the ``distributivity'' requirement that its elimination
  can occur in any context. Then we can construct the unique morphism
  to any HVE by straightforward induction on syntax.
\end{proof}

%% \subsection{Examples of Models}

Now that we have a category-theoretic notion of model, we give some
model construction theorems that can be used to justify our intuitive
notion of semantics in (enriched, internal, indexed) category theory.
%
First, we can extend any virtual equipment to an HVE as follows:
\begin{construction}
  Given a virtual equipment $\mathcal V$, we
  can construct a functor $\mathcal V^{-}: \Set \to \text{vDbl}_r$ by
  defining the objects of $\mathcal V^\Gamma$ to be functions $\Gamma
  \to \mathcal V_o$, and similarly for morphisms and 2-cells with all
  operations given pointwise. 
\end{construction}
% NOTE: this should be some kind of general theorem right?
% Sketch:
% 1. VDCrs are a finite limit theory
% 2. A hyperdoctrine L : C -> VDCr is the same as a VDCr in Pr(C)
% 3. The Yoneda embedding preserves finite limits 

%% Semantic Qs:
%
%% (1) The virtual equipment of locally small categories is a model of everything.
%% (2) Are Shulman's enriched indexed categories strict enough?

Then to define a model of VETT with a collection of connectives it is
sufficient to construct a virtual equipment with the corresponding
universal properties.
%
\begin{construction}
  Fix a cardinal $\kappa$. The virtual equipment $\Cat_{\kappa}$ is
  defined to have as objects locally $\kappa$-small categories, small
  objects as $\kappa$-small categories, vertical morphisms as functors,
  horizontal arrows as functors $\cat C^o \times \cat D \to \kappa Set$ and
  2-cells as morphisms of profunctors. Restriction of profunctors is
  given by composition, which is strictly associative and unital.
  $\Cat_{U}$ has objects satisfying the universal properties of all
  connectives in VETT.
\end{construction}

More generally, categories internal to, enriched in and/or indexed by
sufficiently nice categories define a virtual equipment that model the
connectives of VETT. We highlight one example from the literature that
is highly general: Shulman's enriched indexed categories. Shulman's
construction defines a virtual double category of large and small
$\mathcal V$-categories for any pseudofunctor $\mathcal V : S^o \to
\MonCat$ where $S$ is a category with finite products. He gives
examples that show that this subsumes ordinary internal, enriched and
indexed categories for suitable choices of $\mathcal V$, as well as
more general categories that can be thought of as both indexed and
enriched.
%
This is slightly weaker then what we require: to have
\emph{split} restrictions, we need that $\mathcal V$ be a
\emph{strict} functor, not merely a pseudo-functor.
%
This is analogous to the situation for dependent type theory where
substitution is strictly associative but in models is typically
modeled by pullback which is only associative up to unique
isomorphism.
%% In fact, one of the main examples is only a
%% pseudo-functor for precisely this reason that the action on morphisms
%% is given by pullback.
%
We leave strictification theorems to future work.  

\begin{construction}[(\citet{shulman-enriched-indexed})]
  Given any functor $\mathcal V : S^o \to \SymMonCat$ such that $S$
  and $\mathcal V$ have sufficiently well-behaved (indexed)
  $\kappa$-products, then there is a virtual equipment $\mathcal
  V-\textrm{Cat}$ whose objects are locally $\kappa$-small $\mathcal
  V$-categories, small objects are $\kappa$-small $\mathcal
  V$-categories etc. This virtual equipment has objects satisfying all
  of the universal properties needed for a model of VETT.
\end{construction}

\section{Related and Future Work}
\label{sec:discussion}

We now compare \vett{} with other calculi for formal category theory.  

Riehl and Verity~\cite{rvXXelements} use a formal language of virtual
equipments to prove results valid for $\infty$-categories without
concrete manipulation of model categories. They formalize this language
as a theory in Makkai's framework of first-order logic with dependent
sorts (FOLDS).  While this previous work has the same models as \vett{},
we believe that the syntax we propose in this paper formalizes informal
arguments more directly, as shown in Section~\ref{sec:examples}.  This
is because FOLDS approach approach is entirely relational, whereas we
formalize concepts like restriction of a profunctor or composition of
natural transformations as functional operations (substitution).  In
particular, this means that our calculus requires only vertically
degenerate squares (elements/natural transformations) as a
``user-facing'' notion, with general squares occurring only in the
admissible substitution operations.

%% The main difference is that their theory is built on top of
%% first-order logic, whereas ours is built on a custom-made variant of
%% higher-order logic over a (unary) simple type theory. For this reason,
%% statements in their theory are quite complex as they have to be encoded
%% into first-order logic, whereas we argue our type-theoretic approach
%% %

The coend calculus~\citet{coend-calculus} is an informal syntax for
manipulating profunctors involving ends and coends; an extension of
\vett{} to treat profunctors of many variables of different variances
may provide a formal treatment of it.

\citet{djm-string-diagrams} provides a string diagram calculus for
double categories and pro-arrow equipments, generalizing string
diagrams for monoidal categories \citet{joyal?}. These are an
alternative approach to type theoretic calculi, with the string
diagrams typically making tensor products simpler to work with, while
a type theoretic calculus like SCT makes the closed structure
$\homrallXYtoZ \alpha P Q$ simpler to work with by using bound
variables.

One alternative to proarrow equipments is to axiomatize the bicategory
of categories, profunctors and natural transformations rather than the
virtual double category of categories, functors, profunctors and natural
transformations. An abstract structure along these lines is a
\emph{Cartesian
  bicategory}~\citet{carboni-walters,carboni-walters-someonelese}.  (In
a terminological collision, \citet{fioresaville} give a syntax for a a
bicategory with products/finite limits, but this is a different notion.)
\citet{jonasfreycartesianbicategories} describe some preliminary work on
a proof system for Cartesian bicateogires.  This calculus is more
general than \vett{} in that their profunctors may have 0, 1 or more
covariant or contravariant variables, but they do not have a term syntax
for the natural transformations/elements, and Cartesian bicategories do
not have functors and restriction of profunctors by
functors. Semantically, Cartesian bicategories are less general
than virtual equipments because in general the set of functors between
two categories can only be recovered from the set of profunctors if the
codomain category is Cauchy complete, in which case functors are
equivalent to adjoint pairs of profunctors.

Our work in this paper fits broadly into a line of work on
\emph{directed dependent type theories}, a type theory where the
identity type is interpreted as morphisms in a (possibly
$\infty$-)category.  In directed type theories based on a bisimplicial
model~\cite{riehlshulman17directed,buchholtzweinberger21fibered,weinberger22thesis,WeaverLicata20},
morphism types are defined using an interval object, like in cubical
type
theory~\cite{bch18,cchm18cubical,angiuli+18cartesian-csl,abcfhl17cartesian},
and universal properties like ``morphism induction'' are an internally
definable property of certain types.  Other type
theories~\cite{north18,ahrens+22semantics-2dtt} define morphism types via an induction
principle, corresponding to the lifting properties of certain kinds of
fibrations of categories.  While these previous works can express some
constructions on $\Cat$ that are not expressible in \vett{}, because
\vett{} is more restricted, \vett{} contrariwise has more models, for
instance categories enriched in non-cartesian monoidal categories, so
the theorems that are provable in \vett{} apply in more settings.

%% Directed dependent type theories
%% should generalize \ohol{} in the same way that dependent type theory
%% generalizes higher order logic: internally there should be a type that
%% models the category of sets, and terms of this type should model the
%% profunctors of \ohol{}.  As a foundation for a domain-specific proof
%% assistant for category theory, \ohol{} may provide a foundation for a
%% proof assistant in the style of Isabelle/HOL \cite{isabelle-hol},
%% whereas directed type theory would provide a foundation for a proof
%% assistant in the style of Agda or Coq \cite{agda,coq}.

Finally, some variations on double categories have been used to model
the structure of certain program logics. \citet{newlicata20} present a
logic for \emph{vertically thin} pro-arrow equipments, i.e., pro-arrow
equipments where the functor and natural transformation judgments are
posetal. This calculus is quite different from ours in that the
horizontal morphisms are terms of a programming language, and so they
are not presented as relations with co-variant and contravariant
variables, and the equipment structure is modeled by explicit coercions
rather than by syntactic substitution of vertical arrows in horizontal
arrows. Another similar calculus is System P \citep{systemP} which is an
internal language of \emph{reflexive graph categories}, which are like
double categories without horizontal composition.

%% DRL note: I would compress the rest of this to a couple of sentences
%% as the first thing to remove for space.  

In future work, \vett{} could incorporate functor categories by
generalizing the unary type theory of functors to functors of many
variables, in which case ordinary $\lambda$ calculus can be used to
define functor categories as function types. Similarly, ideas from modal
type theory/graded linear logic could be used for defining opposite
categories \cite{mike-contravariance-enrichment,semiring-stuf??}. 

%% while many constructions in category theory can be formalized in
%% virtual equipments, and therefore \vett{}, others require more
%% structure. Future extensions to

%% While we have demonstrated that some common constructions in category
%% theory can be expressed using the simple combination of homs, tensors
%% and units, there are several that are out of reach for SCT due to its
%% restrictive judgmental structure. These require extensions to the
%% judgmental structure that would move beyond virtual equipments.

%% First, while we can add products to the calculus, adding in a
%% \emph{functor category} ${\cat C}^{\cat D}$ would necessitate adding a
%% syntax for functors of multiple arguments, to allow for the lambda rule:
%% \[ \inferrule {\alpha:\cat C, \beta:\cat D \vdash e : \cat E} {\alpha:\cat C \vdash \lambda \beta:\cat D. e : \cat E} \]
%% This would then require also some extension to profunctors for
%% allowing 0 or more covariant/contravariant dependencies as well.
%% %
%% Semantically, this would correspond to generalizing from virtual
%% equipments to some kind of (possibly cartesian) \emph{monoidal closed}
%% virtual equipments.

%% In addition, we could consider extending our semantics with a notion
%% of \emph{opposite category}, with the property that a covariant
%% dependence of a profunctor on a variable in a category should be
%% equivalent to a contravariant dependence on a variable in the opposite
%% category.
%% %
%% This could possibly be done by introducing a modal distinction
%% $\alpha:^{+}\cat C$ for covariant dependence and $\alpha:^{-}\cat C$
%% for contravariant dependence, with the opposite category being a
%% modality that internalizes flipping the variance as a type
%% constructor.
%% %
%% With these two extensions, possibly, the category contexts for
%% functors and profunctors could be unified as one notion of a sequence
%% of object variables with variances.
%% %
%% With this unification, it would then be simpler to incorporate a third
%% extension: a universe object, corresponding to an object
%% $\textrm{Set}$, which would allow us to internalize the profunctor
%% judgment in the functor judgment, modeling that in classical category
%% theory, profunctors are the same as certain functors to the category
%% of Sets.
%% %
%% While all of these extensions seem plausible, they all move away to
%% the simple ordered type theory structure that allowed us to define
%% units, tensor and hom profunctors so easily. It is unclear how to
%% define these types in this extended structure. As a simple example, if
%% profunctors have many variables of mixed variance, rather than exactly
%% one of each variance, it is unclear what the appropriate
%% generalization of the transformation context $\Phi$ should be.

%% An orthogonal extension to these would be to consider adding a
%% \emph{discretization} modality $\Delta\cat C$ that gives the discrete
%% category on the underlying set of objects of $\cat C$. This would give
%% us the ability to formalize concepts like ``function on objects'' or
%% ``unnatural transformation'' without the need to define internal
%% categories. This could be modeled by adding a modal distinction
%% $\alpha:^{\#}\cat C$ for ``crisp'' dependence on an object of $\cat
%% C$, i.e., dependence merely on the object of $\cat C$ with no
%% functoriality/naturality conditions. This would then be internalized
%% by the discretization modality.

%% A third approach would be to extend the calculus to model general
%% monoidal closed structures and more generally multicategories, which
%% provides semantics of modal substructural type theories.
%% %
%% This can be modeled by extending the ``universe'' $\Set$ to be a
%% monoidal closed category, which induces a monoidal closed structure on
%% profunctors by the Day convolution product \cite{...}.
%% %
%% Similar developments along these lines have already been done for
%% coend calculus \citep{coend-calculus} and in formalization of
%% substructural type theories \citep{atkey-woods}.

%% A recent development in the formalization of substructural type
%% theories is to use monoidal connectives at the meta-level when
%% defining multiplicative connectives\cite{woodsatkeyesop2022}. This
%% suggest one approach to extending the theory to support the
%% formalization of multiplicative universal properties would be, in
%% adherence to the microcosm principle, to add linear judgments and
%% multiplicative connectives to the metalevel.

%% \paragraph{As a tool for Formal Type Theory}

%% While we can model ``unary'' type theories using profunctors, to model
%% theories like simple intuitionistic, linear or bunched type theories
%% we need a way to talk about ``profunctors of many arguments''. This
%% can be accomplished using \emph{multicategory} theory, which models
%% the structure of the context with its structural rules as a monad of
%% ``contexts and substitutions''. A suitable notion of monad on a
%% virtual double category has been developed and was in fact the
%% original motivation for the concept of a virtual double
%% category. However while an abstract monad of contexts $T$ is enough to
%% define what a $T$-multicategory internal to a virtual equipment is, it
%% does not appear possible to define the multiplicative connectives as a
%% universal property, i.e., to define when the multicategory is
%% \emph{representable}.

\textbf{Acknowledgments.}  This material is based on research sponsored
by the National Science Foundation under agreement number CCF-1909517
and the United States Air Force Research Laboratory under agreement
number FA9550-21-0009 (Tristan Nguyen, program manager).
%% The U.S. Government is authorized to reproduce and distribute
%% reprints for Governmental purposes notwithstanding any copyright
%% notation thereon.  The views and conclusions contained herein are
%% those of the authors and should not be interpreted as necessarily
%% representing the official policies or endorsements, either expressed
%% or implied, of the National Science Foundation, the United States Air
%% Force Research Laboratory, or the U.S. Government.
The authors would like to thank David Jaz Myers, Emily Riehl, Mike
Shulman, Dominic Verity for helpful feedback on this work.

%% %%
%% %% Bibliography
%% %%

%% %% Please use bibtex, 

\bibliographystyle{splncs04}
\bibliography{cats}

\appendix

\section{\vett{} Syntactic Metatheory}
\label{sec:appendix:syntax}

\subsection{Contexts and Substitutions}

In Figure~\ref{fig:ctx} we include the formation rules and definitions
of the three kinds of contexts that are used in \vett{}.
%
In Figure~\ref{fig:substitutions} we give definitions for
well-typedness of the corresponding three kinds of substitutions.

\begin{figure}
  \begin{mathpar}
    \inferrule*[right=TyCtxForm]
    {}
    {\Gamma \isadtctx}

    \inferrule*[right=MtTyCtx]{}{\cdot \isadtctx}

    \inferrule*[right=TyCtxExt]
    {\Gamma \isadtctx \and \Gamma \vdash A \isaTy}
    {\Gamma , X : A \isadtctx}

    \inferrule*[right=BoundaryForm]
    {\Gamma \isadtctx}
    {\Gamma \vdash \Xi \boundary}

    \inferrule*[right=BoundarySingle]
    {\Gamma \vdash \cat C \isaCat}
    {\Gamma \vdash \alpha: \cat C \boundary}

    \inferrule*[right=BoundaryDbl]
    {\Gamma \vdash \cat C \isaCat \and \Gamma\vdash\cat D \isaCat}
    {\Gamma \vdash \alpha: \cat C; \beta: \cat D \boundary}

    \inferrule*[right=SetCtxForm]
    {\Gamma \isadtctx}
    {\Gamma \vdash \Phi \isavectx}

    \inferrule*[right=SetCtxMt]
    {\Gamma \vdash \cat C \isaCat}
    {\Gamma \vdash \alpha: \cat C \isavectx}

    \inferrule*[right=SetCtxExt]
    {\Gamma \vdash \Phi \isavectx\and
    \Gamma \pipe d^+\Phi; \beta:\cat D \vdash R \isaSet}
    {\Gamma \vdash \Phi, x:R, \beta:\cat D \isavectx}
  \end{mathpar}
  \caption{Contexts}
  \label{fig:ctx}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \begin{array}{rccl}
      \textrm{Term Substitution} & \gamma, \delta & ::= & \cdot \pipe \gamma, M/X\\
      \textrm{Object Substitution} & \xi, \zeta & ::= & a/\alpha \pipe a/\alpha;b/\beta\\
      \textrm{Transformation Substitution} & \phi, \psi & ::= & a/\alpha \pipe \phi,s/x, \psi      
    \end{array}

    \inferrule*[right=TermSubstFormation]
    {\Delta \isadtctx \and \Gamma \isadtctx}
    {\Delta \vdash \gamma :: \Gamma}
    
    \inferrule*[right=TermSubstMt]
    {}
    {\Delta \vdash \cdot :: \cdot}

    \inferrule*[right=TermSubstExt]
    {\Delta \vdash \gamma :: \Gamma \and \Delta \vdash M : A[\gamma]}
    {\Delta \vdash \gamma,M/X :: \Gamma,X:A}

    \inferrule*[right=BoundarySubstFormation]
    {\Gamma \vdash Z \boundary \and \Gamma \vdash \Xi \boundary}
    {\Gamma\pipe Z \vdash \xi :: \Xi}

    \inferrule*[right=BoundarySubstSingle]
    {\Gamma\pipe \alpha:\cat C \vdash b : \cat D}
    {\Gamma \pipe \alpha:\cat C \vdash b/\beta :: \beta:\cat D}

    \inferrule*[right=BoundarySubstDbl]
    {\Gamma\pipe d^-\Xi \vdash a : \cat C\and
     \Gamma\pipe d^+\Xi \vdash b : \cat D}
    {\Gamma \pipe \Xi \vdash a/\alpha;b/\beta :: (\alpha : \cat C; \beta:\cat D)}

    \inferrule*[right=ElementSubstFormation]
    {\Gamma \vdash \Psi \isavectx \and \Gamma \vdash \Phi \isavectx}
    {\Gamma\pipe \Psi \vdash \phi :: \Phi}

    % horizontal identity
    \inferrule*[right=ElementSubstMt]
    {\Gamma\pipe \beta:\cat C \vdash a : \cat C}
    {\Gamma \pipe \beta:\cat C \vdash a/\alpha : (\alpha : \cat C)}

    \inferrule*[right=ElementSubstExt]
    {\Gamma\pipe\Psi \vdash \phi :: \Phi \and
      d^+\Psi = d^-\Psi'
     \Gamma\pipe\Psi' \vdash t : R[d^+\phi;b/\beta]\and
     \Gamma\pipe d^+\Psi'\vdash b : \cat D}
    {\Gamma\pipe\Psi \vdash \phi,t/x,b/\beta :: (\Phi,x:R,\beta:\cat D)}
  \end{mathpar}
  \caption{Substitution}
  \label{fig:substitions}
\end{figure}

These definitions involve several operations $d^\pm\Phi$, $\underline
\Phi$ and $\Phi\jnctx \Psi$ on contexts (and their functorial lift to
substitutions) that we now define.

\begin{definition}
  We define operations $d^\pm$ that project out the covariant and
  contravariant boundary of a set context.
  This can be typed with the admissible rule
  \begin{mathpar}
    \inferrule*[right=(*)]
               {\Gamma \vdash \Phi \isavectx}
               {\Gamma \vdash d^\pm\Phi \boundary}
  \end{mathpar}
  and is defined as
  \begin{align*}
    d^{\pm}(\alpha:\cat C) &= \alpha : \cat C\\
    d^{-}(\Phi,x:R,\Psi) &= d^-\Phi\\
    d^{+}(\Phi,x:R,\Psi) &= d^-\Psi
  \end{align*}
  This operation extends to the substitutions with admissible rule
  \begin{mathpar}
    \inferrule*[right=(*)]
    {\Gamma\pipe\Psi \vdash \phi :: \Phi}
    {\Gamma\pipe d^\pm \Psi \vdash d^\pm\phi :: d^\pm \Phi}
  \end{mathpar}
  defined as
  \begin{align*}
    d^{\pm}(a/\alpha) &= a/\alpha\\
    d^{-}(\phi,t/x,\psi) &= d^-\phi\\
    d^{+}(\phi,t/x,\psi) &= d^+\psi\\
  \end{align*}
\end{definition}

\begin{definition}
  We define the operation of restricting a set context to both sides
  of its boundary with admissible typing
  \begin{mathpar}
    \inferrule*[right=(*)]
    {\Gamma \vdash \Phi \isavectx}
    {\Gamma \vdash \underline\Phi \boundary}
  \end{mathpar}
  and definition
  \begin{align*}
    \underline{\alpha:C} &= \alpha:C\\
    \underline{\Phi,x:R,\Psi} &= d^-\Phi; d^+{\Psi}
  \end{align*}
  The extension to substitutions has admissible typing
  \begin{mathpar}
    \inferrule*[right=(*)]
    {\Gamma \pipe \Psi \vdash \phi :: \Phi}
    {\Gamma\pipe\underline \vdash \Phi \boundary}
  \end{mathpar}
  and definition
  \begin{align*}
    \underline{\alpha:C} &= \alpha:C\\
    \underline{\Phi,x:R,\Psi} &= d^-\Phi; d^+{\Psi}
  \end{align*}
\end{definition}

Finally, we define the operation of ``horizontal composition'' of set
contexts $\Phi \jnctx \Psi$ and its functorial lift $\phi \jnctx
\psi$.
\begin{definition}
  We define horizontal composition of transformation contexts with the
  admissible typing rule
  \[\inferrule*[right=(*)]
  {\Gamma\vdash \Phi\isavectx\and \Gamma\vdash \Psi\isavectx\and d^+\Phi=d^-\Psi}
  {\Gamma\vdash \Phi \jnctx \Psi \isavectx }\]
  as follows
  \begin{align*}
    \Phi \jnctx \alpha:\cat C &= \Phi\\
    \Phi \jnctx (\Psi,x:R,\alpha:\cat C) &= (\Phi\jnctx \Psi), x:R, \alpha:\cat C
  \end{align*}

  And we extend this to an operation on substitutions with the
  admissible rule
  \[\inferrule*[right=(*)]
  {\Gamma\pipe\Psi \vdash \phi : \Phi \and
   \Gamma\pipe\Psi' \vdash \phi' : \Phi'\and
   d^+\phi = d^-\phi'
  }
  {\Gamma\pipe\Psi \jnctx \Psi' \vdash \phi \jnctx \phi' :: \Phi \jnctx \Phi' }
  \]
  Defined as follows
  \begin{align*}
    \phi \jnctx a/\alpha &= \phi\\
    \phi\jnctx (\psi, s/x,a/\alpha) &= (\phi\jnctx\psi), s/x, a/\alpha
  \end{align*}  
\end{definition}

\begin{lemma}[Horizontal Category of Contexts/Substitutions]
  Horizontal composition of contexts is associative (when defined)
  \[ (\Phi \jnctx \Psi) \jnctx \Sigma = \Phi \jnctx (\Psi \jnctx \Sigma) \]
  and unital with identity for $\cat C$ given by the single category
  variable context $\alpha:\cat C$:
  \[ \alpha:\cat C \jnctx \Phi = \Phi = \Phi \jnctx \beta:\cat D\]
  when $d^-\Phi = \alpha:\cat C$ and $d^+\Phi = \beta:\cat D$.

  These properties extend to the horizontal composition of element substitutions:
  \[ \phi \jnctx (\psi \jnctx \sigma) = (\phi \jnctx \psi) \jnctx \sigma \]
  where the identity is the single variable substitution:
  \[ a/\alpha \jnctx \phi = \phi = \phi \jnctx b/\beta \]
  when $d^-\phi = a/\alpha$ and $d^+\phi = b/\beta$.
\end{lemma}

Next, we define the actions of substitutions on terms. We elide the
obvious action of term substitutions $\gamma$ and include only the
more unusual substructural substitutions.
\begin{definition}[Substitution Actions]
  For any $\Gamma \pipe \alpha: \cat C \vdash a : \cat D$ and $\Gamma
  \pipe \beta:\cat D \vdash b \cat E$, we define $b[a/\beta]$ by
  recursion on $b$:

  \begin{align*}
    \beta[a/\beta] &= a\\
    (M\,b)[a/\beta] &= M\,(b[a/\beta])\\
    (\lambda \beta)    
    (\pi_\pm b)[a/\beta] &= \pi_\pm b[a/\beta]\\
    (b_-,b_+,s)[a/\beta] &= (b_-[a/\beta],b_+[a/\beta], s[a/\beta])\\
  \end{align*}

  Simultaneously by recursion on $s$ we define $s[\phi]$
  \begin{align*}
    x[a/\alpha,t,b/\beta] &= t\\
    \pendappXtoY M b[a/\alpha] &= \pendappXtoY M {b[a/\alpha]}\\
    {\punitelimkontZatABC {\alpha. t}{b_1} s {b_2}}[\phi] &=
    {\punitelimkontZatABC {\alpha. t}{b_1[d^-\phi]} {s[\phi]} {b_2[d^+\phi]}}\\
    (\punitrefl b)[a/\alpha] &= \punitrefl {b[a/\alpha]}\\
    {\tensorelimWkontZ s {x.\beta.y.r}[\phi_l\jnctx\phi_m\jnctx\phi_r]} &=
    \tensorelimWkontZ {s[\phi_m]} {x.\beta.y. r[\phi_l,x/x,\beta/\beta \jnctx \beta/\beta,y/y,\phi_r]}\\
    {\tensorintroatXwithYandZ b s t}[\phi_s \jnctx \phi_t] &= \tensorintroatXwithYandZ {d^+\phi_s} {s[\phi_s]} {t[\phi_t]}\\
    {(\homrappXtoYatZ s t a)}[\phi_f\jnctx \phi_a] &=
    {\homrappXtoYatZ {s[\phi_f]} {t[\phi_a]} {a[d^+\phi_f]}}\\
    {(\homrlambdaXatYdotZ {x}{\alpha} s)}[\phi] &=
    {\homrlambdaXatYdotZ {x}{\alpha} {s[\phi,x/x,\alpha/\alpha]}}\\
    {(\homlappXtoYatZ t s a)}[\phi_a\jnctx \phi_f] &=
    {\homlappXtoYatZ {t[\phi_a]} {s[\phi_f]} {a[d^-\phi_f]}}\\
    {(\homllambdaXatYdotZ {x}{\alpha} s)}[\phi] &=
    {\homllambdaXatYdotZ {x}{\alpha} {s[\alpha/\alpha,x/x,\phi]}}\\
    (\pi_i s)[\phi] &= \pi_i s[\phi]\\
    (s_1,s_2)[\phi] &= (s_1[\phi], s_2[\phi])\\
    ()[\phi] &= ()
  \end{align*}
  Several rules assume the substitution is in a particular form, such
  as the tensor elimination which expects an input context
  $\phi_s\jnctx\phi_t$. The fact that the context can be uniquely
  decomposed in a well-typed way follows from an inversion principle (Lemma~\ref{lem:inversion})
  for well-typed substitutions.

  And finally, we define $P[\xi]$ by recursion on $P$:
  \begin{align*}
    (M\,a\,b)[\xi] &= M\,(a[d^-\xi])\,(b[d^+\xi])\\
    (\punitinXfromYtoZ {\cat C} a b)[\xi] &= \punitinXfromYtoZ {\cat C} {a[\xi]}{b[\xi]}\\
    (\tensorexistsXwithYandZ \beta P Q)[\xi] &= \tensorexistsXwithYandZ \beta {P[d^-\xi;\beta/\beta]}{P[\beta/\beta;d^+\xi]}\\
    (\homrallXYtoZ \alpha R P)[\xi] &= \homrallXYtoZ \alpha {R[d^+\xi;\alpha/\alpha]} {P[d^-\xi;\alpha/\alpha]}\\
    (\homlallXYtoZ \alpha P Q)[\xi] &= \homlallXYtoZ \alpha {P[\alpha/\alpha;d^-\xi]} {Q[\alpha/\alpha;d^+\xi]}\\
    1[\xi] &= 1\\
    (P_1 \times P_2)[\xi] &= P_1[\xi] \times P_2[\xi]
  \end{align*}
\end{definition}

\begin{lemma}[Inversion]
  \label{lem:inversion}
  \begin{enumerate}
  \item If $\Phi \vdash \psi :: (\alpha:\cat C)$ then $\Phi =
    \beta:\cat D$ for some $\cat D$ and $\psi = a/\alpha$ where
    $\beta:\cat D \vdash a : \cat C$.
  \item If $\Phi \vdash \psi :: \Psi_1 \jnctx \Psi_2$, then there
    exists unique $\Phi_1,\Phi_2,\psi_1,\psi_2$ such that $\Phi =
    \Phi_1\jnctx\Phi_2$ and $\Phi_1\vdash\psi_1 :: \Psi_1$ and
    $\Phi_2\vdash \psi_2 : \Psi_2$ and $\psi = \psi_1\jnctx\psi_2$.
  \end{enumerate}
\end{lemma}

%% \begin{lemma}[Vertical category]
%%   \label{lem:vertical-cat}
%%   Substitution of object terms $A[B/\beta]$ is associative with
%%   identity given by the variable $\alpha:\cat C \vdash \alpha:\cat C$.
%% \end{lemma}

%% To define vertical composition of squares, we need the following lemma.

%% Theorems about substitution?

% TODO: more properties of substitution??

\subsection{Equational Theory}

Next we present the $\beta\eta$ rules that generate the equational
theory of the terms. In keeping with the extensional style of the type
theory, we do not present explicit transitivity, congruence, or
transport rules, but rather consider these as inherent to the notion
of equality. This can be formalized by modeling the terms of our type
theory as a quotient inductive inductive type
\cite{altenkirch-kaposi-popl17}.

\begin{figure}
  \begin{mathpar}
    % Type connectives: small and large cats, functors, profs, nat transformations, and if we want also Pi/Sigma/Id
    \inferrule*[right=SmallCat$\beta$]
    {~}
    {\unquoth {\quoth {\cat C}}  = \cat C}

    \inferrule*[right=SmallCat$\eta$]
    {\Gamma \vdash M : \smallCats}
    {\Gamma \vdash \quoth {\unquoth {M}}  = M : \smallCats}

    \inferrule*[right=Cat$\beta$]
    {~}
    {\unquoth {\quoth {\cat C}}  = \cat C}
    
    \inferrule*[right=Cat$\eta$]
    {\Gamma \vdash M : \Cats}
    {\Gamma \vdash \quoth {\unquoth {M}}  = M : \Cats}

    \\
    \inferrule*[right=Fctor$\beta$]
    {~}
    {(\lambda \alpha. b)\,a = b[a/\alpha]}

    \inferrule*[right=Fctor$\eta$]
    {\Gamma \vdash M : \varr {\cat C}{\cat D}}
    {\Gamma \vdash M = \lambda \alpha. M\,\alpha : \varr {\cat C}{\cat D}}

    \inferrule*[right=Prof$\beta$]
    {~}
    {(\lambda \alpha \beta. P)\,a\,b = P[a/\alpha;b/\beta]}

    \inferrule*[right=Prof$\eta$]
    {\Gamma \vdash M : \harr {\cat C}{\cat D}}
    {\Gamma \vdash M = \lambda \alpha\,\beta. M\,\alpha\,\beta : \harr {\cat C}{\cat D}}

    \inferrule*[right=NatElt$\beta$]
    {~}
    {(\pendlambdaXdotY \alpha s) a = s[a/\alpha]}

    \inferrule*[right=NatElt$\eta$]
    {\Gamma \vdash M : \pendallXdotY \alpha P}
    {\Gamma \vdash M = \pendlambdaXdotY \alpha {M\,a} : \pendallXdotY\alpha P}

    \\\\\\\\

    % Object connectives: 0,2-products, tabulators, +/- presheafs

    \inferrule*[right=NegPresheaf$\beta$]
    {~}
    {\negPresheafApp a (\lambda \alpha. R) = R[a/\alpha]}

    \inferrule*[right=NegPresheaf$\eta$]
    {\Gamma \pipe \beta:\cat D \vdash p : \negPresheaf {\cat C}}
    {p = \lambda \alpha. \negPresheafApp \alpha p}
    
    \inferrule*[right=NegPresheaf$\beta$]
    {~}
    {\posPresheafApp {(\lambda \beta. R)} b = R[b/\beta]}

    \inferrule*[right=PosPresheaf$\eta$]
    {\Gamma \pipe \alpha:\cat C \vdash p : \posPresheaf {\cat D}}
    {p = \lambda \beta. \posPresheafApp p \beta}
    
    \inferrule*[right=Graph$\beta-$]
    {~}
    {\pi_- (a_-,a_+,s) = a_-}

    \inferrule*[right=Graph$\beta+$]
    {~}
    {\pi_+ (a_-,a_+,s) = a_+}
    
    \inferrule*[right=Graph$\beta e$]
    {~}
    {\pi_e (a_-,a_+,s) = s}
    
    \inferrule*[right=Graph$\eta$]
    {\Gamma \pipe \alpha:\cat C \vdash b : \graphProf{\beta_-}{\beta_+} P}
    {\Gamma \pipe \alpha:\cat C \vdash b = (\pi_-b, \pi_+b, \pi_e b) : \graphProf{\beta_-}{\beta_+} P}
    
  \inferrule*[right=${1}\eta$]
  {\Gamma \pipe \alpha:\cat C \vdash a : 1}
  {\Gamma \pipe \alpha:\cat C \vdash a = () : 1}\\

  \inferrule*[right=${\times}\beta$]
  {~}
  {\pi_i(a_1,a_2) = a_i}

  \inferrule*[right=${\times}\eta$]
  {\Gamma \pipe \alpha:\cat C \vdash a : \cat D_1 \times \cat D_2}
  {\Gamma \pipe \alpha:\cat C \vdash a = (\pi_1a, \pi_2a) : \cat D_1 \times \cat D_2}
  \end{mathpar}
  \caption{$\beta\eta$ Equality for type and object connectives}
\end{figure}

\begin{figure}
  \begin{mathpar}
  % Set connectives: unit, tensor, +/- hom, 0,2-products
  \inferrule*[right=CovHom$\beta$]
    {~}
    {\homrappXtoYatZ {(\homrlambdaXatYdotZ x \alpha s)} t a = s[t/x,a/\alpha]}
    \inferrule*[right=CovHom$\eta$]
               {\Gamma\pipe\Phi \vdash s : \homrallXYtoZ \alpha R P}
               {\Gamma\pipe\Phi \vdash s = \homrlambdaXatYdotZ {x}{\alpha} \homrappXtoYatZ s x \alpha}

    \inferrule*[right=ConHom$\beta$]
                 {~}
                 {\homlappXtoYatZ {(\homllambdaXatYdotZ x \alpha t)} s a = t[a/\alpha,s/x]}
      \inferrule*[right=ConHom$\eta$]
      {\Gamma \pipe \Phi \vdash t : \homlallXYtoZ \alpha R P}
      {\Gamma \pipe \Phi \vdash t = \homllambdaXatYdotZ x \alpha \homlappXtoYatZ t x \alpha : \homlallXYtoZ \alpha R P}

    \inferrule*[right=Unit$\beta$]
    {~}
    {(\punitelimkontZatABC {\alpha. t} a {\punitrefl a} a) = t[a/\alpha]}
    \inferrule*[right=Unit$\eta$]
    {\Gamma\pipe\Phi \vdash s : \punitinXfromYtoZ {\cat C}{a}{b}}
    {\Gamma\pipe\Phi\vdash s = \punitelimkontZatABC {\alpha. \punitrefl \alpha} a s b: \punitinXfromYtoZ {\cat C}{a}{b}}
      
    \inferrule*[right=Tensor$\beta$]
    {~}
    {\tensorelimWkontZ {\tensorintroatXwithYandZ b s t} {x.\beta.y. r} = t[s/x;b/\beta;t/y]}
    \inferrule*[right=Tensor$\eta$]
    {\Gamma\pipe\Phi \vdash s : \tensorexistsXwithYandZ \beta P Q}
    {\Gamma\pipe\Phi\vdash s = \tensorelimWkontZ s {x.\beta.y. \tensorintroatXwithYandZ \beta x y}: \tensorexistsXwithYandZ \beta P Q}

  \inferrule*[right=$1\eta$]
  {\Phi \vdash s : 1}
  {\Phi \vdash s = () : 1}\\

  \inferrule*[right=${\times}\beta$]
  {~}
  {\pi_i(s_1,s_2) = s_i}

  \inferrule*[right=${\times}\eta$]
  {\Phi \vdash s : P \times Q}
  {\Phi \vdash s = (\pi_1 s, \pi_2 s) : P \times Q}
  \end{mathpar}
  \caption{$\beta\eta$ Equality for set connectives}
  \label{fig:betaeta-sets}
\end{figure}

\subsection{Generalized Unit Elimination}

The unit elimination rule presented in Section~\ref{sec:syntax} is
more restrictive than universal property of a unit in a virtual double
category that we use in the semantics. So in order for our calculus to
be complete for virtual equipments with units, we need to show that
the more general unit elimination principle is admissible and
satisfies the correct $\beta\eta$ rules.

The more general rules are as follows
\begin{mathpar}
  \inferrule*[Right=UnitElim]
  {\Phi[\alpha/\alpha_-]\jnctx \Psi[\alpha/\alpha_+] \vdash t : P[\alpha/\alpha_-;\alpha/\alpha_+]}
  {\Phi,x:\punitinXfromYtoZ {}{\alpha_-} {\alpha_+}, \Psi \vdash \textrm{ind}_{\to}^{\Phi;\Psi}(\alpha.t; x) : P}

  (\textrm{ind}_{\to}^{\Phi;\Psi}(\alpha.t; x))[\phi,\punitrefl \alpha,\psi] = t[\phi\jnctx\psi]

  \inferrule
  {\Phi,x:\punitinXfromYtoZ {}{\alpha_-} {\alpha_+}, \Psi \vdash s : P}
  {\Phi,x:\punitinXfromYtoZ {}{\alpha_-} {\alpha_+}, \Psi \vdash s = \textrm{ind}_{\to}^{\Phi;\Psi}(\alpha. s[\punitrefl \alpha/x]; x){}}
\end{mathpar}

The rule is more general because it allows the elimination of an input
of the unit type with non-trivial contexts $\Phi, \Psi$ surrounding
it, whereas the rule presented earlier would only allow this
elimination if $x$ were the only variable. We did not include this
more general rule because it does not seem possible to define it with
an admissible action of substitution, and would require a notion of
explicit substitution.

In the presence of hom types, we can prove this more general
elimination is admissible, because the judgment
\[ \Phi,x:\punitinXfromYtoZ {}{\alpha_-} {\alpha_+}, \Psi \vdash s : P \]
is in natural bijection with the judgment
\[ \alpha_-,x:\punitinXfromYtoZ {}{\alpha_-} {\alpha_+}, \alpha_+ \vdash s : \Phi \triangleright P \triangleleft \Psi \]
where $\Psi \triangleright P \triangleleft \Phi$ (note the reversal of
order) is a type constructed by recursion on $\Phi$ and $\Psi$ using
uses the hom types.

\begin{definition}[Generalized Unit Elimination]
  We define $\textrm{ind}_{\to}^{\Phi;\Psi}(\alpha.t; x)$ by induction
  on $\Phi/\Psi$.
  \begin{align*}
    \textrm{ind}_{\to}^{\alpha_-;\alpha_+}(\alpha.t; x) &= \punitelimkontZatABC{\alpha.t}{\alpha_-}{x}{\alpha_+}\\
    \textrm{ind}_{\to}^{\alpha_-;\Psi,y,\beta}(\alpha.t; x) &=
    \homrappXtoYatZ
        {(\textrm{ind}_{\to}^{\alpha_-;\Psi}(\alpha.\homrlambdaXatYdotZ y \beta t; x))} y \beta \\
    \textrm{ind}_{\to}^{\beta, y, \Phi;\Psi}(\alpha.t; x) &=
    \homlappXtoYatZ
        {(\textrm{ind}_{\to}^{\alpha_-;\Psi}(\alpha.\homllambdaXatYdotZ y \beta t; x))} y \beta \\
  \end{align*}
\end{definition}

\begin{lemma}[Generalized Unit Elim $\beta\eta$]
  The admissible generalizaed unit elimination satisfies the described $\beta\eta$ equations.
\end{lemma}
\begin{proof}
  By induction on $\Phi/\Psi$
  First, $\beta$
  \begin{itemize}
  \item If $\Phi = \Psi = \alpha$
    \begin{align*}
    (\punitelimkontZatABC{\alpha.t}{\alpha_-}{x}{\alpha_+})[\alpha,\punitrefl \alpha, \alpha] &=
    \punitelimkontZatABC{\alpha.t}{\alpha}{\punitrefl}{\alpha}\\
    &= t \tag{Unit$\beta$}
  \end{align*}
  \item If $\Phi = \alpha$ and $\Psi = \Psi, y, \beta$
    \begin{align*}
    (\homrappXtoYatZ
      {(\textrm{ind}_{\to}^{\alpha_-;\Psi}(\alpha.\homrlambdaXatYdotZ y \beta t; x))} y \beta)[\phi,\punitrefl \alpha, \psi, s/y, b/\beta]
      &= (\homrappXtoYatZ
        {(\textrm{ind}_{\to}^{\alpha_-;\Psi}(\alpha.\homrlambdaXatYdotZ y \beta t; x)[[\phi,\punitrefl \alpha, \psi]])} s b)\tag{Definition}\\
      &= (\homrappXtoYatZ {\homrlambdaXatYdotZ y \beta t[\phi,\psi]} s b) \tag{Induction}\\
      &= t[\phi,\psi,s/y,b/\beta]\tag{Hom$\beta$}
    \end{align*}
  \item $\Phi = \beta, y, \Phi$ case is similar to previous.
  \end{itemize}
  
  Next $\eta$.
  \begin{itemize}
  \item $\Phi = \alpha_- $ and $\Psi = \alpha_+$: immediate by unit $\eta$.
  \item $\Phi = \alpha_-$ and $\Psi = \Psi, y, \beta$:
    \begin{align*}
      s &= \homrappXtoYatZ {\homrlambdaXatYdotZ y \beta s} y \beta\tag{Hom $\beta$}\\
      &= \homrappXtoYatZ {(\textrm{ind}_{\to}^{\alpha_-;\Psi}(\alpha.\homrlambdaXatYdotZ y \beta {s[\punitrefl \alpha/x]}; x))} y \beta \tag{Induction}\\
      &= \textrm{ind}_{\to}^{\Phi;\Psi,y,\beta}(\alpha. s[\punitrefl \alpha/x]; x)\tag{Definition}
    \end{align*}
  \end{itemize}
\end{proof}


\section{Extended Formal Category Theory Examples}
\label{sec:appendix:examples}

Next, we provide some futher detailed examples of the formal category
theory constructions and theorems from Section~\ref{sec:examples}.

\section{Semantics}
\label{sec:appendix:semantics}

In this section, we provide the full definitions of the universal
properties in a virtual equipment corresponding to each connective in
\vett{}, and the most critical details of the soundness and
completeness proof.

TODO

Next, we develop the basics of the model theory for SCT. Because SCT
includes not just a syntax for category theory, but is also indexed by
an ordinary context of dependent type theory $\Gamma$, a model of SCT
is not given by a \emph{single} virtual double category, but instead
by an \emph{indexed family} of VDCs, parameterized by an object of a
category that interprets dependent type theory. We call such a
structure a \emph{VDC-hyperdoctrine}. We then show how to construct a
from any VDC, a VDC-hyperdoctrine indexed by the category of sets,
which has the intuitive reading that any of the VDC judgments $\Gamma
\vdash J$ is interpreted as a family of $J$-data parameterized
by elements of the set $\Gamma$.

%% The first component of this is \emph{soundness}: every category,
%% object, set and transformation denote an object, vertical arrow,
%% horizontal arrow and 2-cell, respectively in any representable virtual
%% equipment, such that all equations in the theory are satisfied.
%% %
%% We combine this with a set theoretic semantics for types $A$ and
%% contexts $\Gamma$ to get a simple semantics of our logic over a
%% virtual equipment.
%% %
%% The second component of this is the \emph{completeness} theorem:
%% informally, the theory contains every category, object, set and
%% transformation that \emph{must} exist in any virtual equipment, and
%% further equations between syntactic forms hold if and only if they
%% hold in every model.
%% %
%% While sounding more ambitious, the completeness theorem is
%% typically simpler as it just amounts to showing that the syntax itself
%% forms a virtual equipment.

\subsection{Notion of Model}

%% 1. A strict double category is a monoid in Span(Cat)
%% 2. A strict double category internal to a topos T is a monoid in Span(T-Cat)
%% 3. A double category with display pro-arrows is a strict double category with a span of profunctors that is representable
%%    C0 <- C1 -> C0
%% 4. UMPs are given on top of that structure

We build up the notion of a model in several stages.

\begin{definition}
  A strict double category is a monoid in the bicategory $Span(Cat)$.
\end{definition}

This data consists of a span $C_0 \leftarrow C_1 \rightarrow C_0$
where $C_0$ is the vertical category and $C_1$ is the category whose
objects are horizontal morphisms and morphisms are squares, with the
two projections giving the left and right ``frame'' for the horizontal
morphisms/squares. The unit gives the horizontal identity morphisms
and the monoid multiplication is the horizontal composition.

\begin{definition}
  A double category with displays (DCD) consists of
  \begin{enumerate}
  \item A strict double category $C$
  \item A category $C_d$ of (horizontal) ``display morphisms'' and ``display squares''.
  \item A span of profunctors:
    % https://q.uiver.app/?q=WzAsOCxbMiwyLCJDXzEiXSxbMCwyLCJDXzAiXSxbNCwyLCJDXzAiXSxbMiwwLCJDX2QiXSxbMCwwLCJDXzAiXSxbNCwwLCJDXzAiXSxbMSwxLCJcXExlZnRhcnJvdyJdLFszLDEsIlxcUmlnaHRhcnJvdyJdLFszLDAsIkNfXFx2ZGFzaCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9fX1dLFs1LDIsIlxcdGV4dHJte0hvbX0iLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifX19XSxbNCwxLCJcXHRleHRybXtIb219IiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn19fV0sWzMsNCwicyIsMl0sWzMsNSwidCJdLFswLDIsInQiLDJdLFswLDEsInMiXV0=
\[\begin{tikzcd}
	{C_0} && {C_d} && {C_0} \\
	& \Leftarrow && \Rightarrow \\
	{C_0} && {C_1} && {C_0}
	\arrow["{C_\vdash}"', "\shortmid"{marking}, from=1-3, to=3-3]
	\arrow["{\textrm{Hom}}", "\shortmid"{marking}, from=1-5, to=3-5]
	\arrow["{\textrm{Hom}}"', "\shortmid"{marking}, from=1-1, to=3-1]
	\arrow["s"', from=1-3, to=1-1]
	\arrow["t", from=1-3, to=1-5]
	\arrow["t"', from=3-3, to=3-5]
	\arrow["s", from=3-3, to=3-1]
\end{tikzcd}\]
\item A fully faithful functor $i : C_d \to C_1$ that respects source and target in that the following commute:
% https://q.uiver.app/?q=WzAsNixbMiwyLCJDXzEiXSxbMCwyLCJDXzAiXSxbNCwyLCJDXzAiXSxbMiwwLCJDX2QiXSxbMCwwLCJDXzAiXSxbNCwwLCJDXzAiXSxbMywwLCJpIiwyXSxbNSwyLCJcXGlkIl0sWzQsMSwiXFxpZCIsMl0sWzMsNCwicyIsMl0sWzMsNSwidCJdLFswLDIsInQiLDJdLFswLDEsInMiXV0=
\[\begin{tikzcd}
	{C_0} && {C_d} && {C_0} \\
	\\
	{C_0} && {C_1} && {C_0}
	\arrow["i"', from=1-3, to=3-3]
	\arrow["\id", from=1-5, to=3-5]
	\arrow["\id"', from=1-1, to=3-1]
	\arrow["s"', from=1-3, to=1-1]
	\arrow["t", from=1-3, to=1-5]
	\arrow["t"', from=3-3, to=3-5]
	\arrow["s", from=3-3, to=3-1]
\end{tikzcd}\]
and $i$ represents $C_\vdash$ in that there is a natural isomorphism:
    \[ e : C_\vdash(\Phi, R) \cong C_1(\Phi, i(R)) \]
    that commutes with the natural transformations $s,t$.
  \end{enumerate}
\end{definition}

In terms of the syntax of SCT, the category $C_0$ models the category
and functor judgments, the category $C_1$ models the profunctor
\emph{contexts} and substitutions and the category $C_d$ models the
profunctor judgment. The profunctor $C_\vdash$ models the
transformation judgment and the functor $i$ models the construction of
a ``singleton'' context $\alpha:\cat C,x:R,\beta:\cat D$. The fact
that $i$ is fully faithful corresponds to the fact that we don't
provide in the syntax a notion of morphism of profunctors separate
from the notion of substitution of singleton contexts.

A DCD is a more general notion that a VDC, but they are closely
related, in that VDCs form a coreflective subcategory of DCDs. This is
analogous to the situation in models of dependent type theory, where
DCDs are analogous to Categories with Families \cite{cwfs,natmodels}
and VDCs are analogous to the more ``syntactic'' notion of a
Contextual Category/C-system \cite{ctxcat,csystem}. First, any DCD
induces a VDC by taking the display proarrows as the proarrows and
interpreting 2-cells using $i$ and $C_\vdash$.  Second, any VDC
presents a DCD whose double category has the original VDC pro-arrows
as the display morphisms and \emph{composable strings} of proarrows as
horizontal morphisms, which gives a strict double category.
%
Taking as morphisms the strict morphisms of DCDs/VDCs, these
constructions form a coreflective embedding of VDCs into DCDs.

The principle advantage of DCDs over VDCs is that the presentation of
their algebraic structure is considerably simplified and is
straightforward to describe as a Generalized Algebraic Theory in the
sense of \citet{CartmellGAT}. This is because we don't \emph{require}
that our profunctor contexts are lists, but instead merely the fact
that their concatenation forms a strict category. Then the
associativity/identity equations for a DCD are precisely those of a
double category.

The final notion of composition that we require for our structure is
that display morphisms have \emph{restrictions} along vertical arrows.

\begin{definition}
  A DCD is an Equipment with displays when
  \begin{enumerate}
  \item The functor $(s,t) : C_d \to C_0 \times C_0$ is a split
    fibration, with restriction operation written as $(f,g)^*R$.
  \item The profunctor $C_\vdash$ respects restrictions in that
    \[ C_\vdash^{f',g'}(\Phi, (f,g)^*R) \cong C_\vdash^{f\circ f',g\circ g'}(\Phi, R) \]
  \end{enumerate}
\end{definition}
Specializing this property give us that $C_\vdash^{f,g}(\Phi,R) \cong
C_\vdash^{\id,\id}(\Phi,(f,g)^*R)$, which justifies that we only need
to give syntax for terms $\Phi \vdash t : R$ where $\Phi$ and $R$ have
the same covariant/contravariant dependencies.

We can then define the remaining connectives by UMPs in an equipment
with displays, adding in the extra strictness criterion that these
connectives appropriately commute with restriction.

\begin{figure}
  \begin{mathpar}
    C_\vdash^{f,g}(\Phi \circ_{C} \Psi, R) \cong C_\vdash^{f,g}(\Phi \circ_C i(U_C) \circ_c \Psi, R) \\
    C_\vdash^{f,g}(\Phi \circ_{C} iP \circ_D iQ \circ_E \Psi, R) \cong C_\vdash^{f,g}(\Phi \circ_C i(P \odot Q) \circ_E \Psi, R) \and (f,g)^*(P \odot Q) = (f,\id)^*P \odot (\id,g)^*Q\\
    C_\vdash^{\id_C,g}(P \circ_c \Phi, R) \cong C_\vdash^{\id_D,g}(\Phi, P \triangleright Q) \and (f,g)^*(P \triangleright Q) = (\id,f)^*P \triangleright (\id,g)^*Q\\
    C_\vdash^{f, \id_C}(\Phi \circ_c R, P) \cong C_\vdash^{f, \id_D}(\Phi, P \triangleleft Q)\and (f,g)^*(P \triangleleft Q) = (f,\id)^*P \triangleleft (g,\id)^*Q\\
    C_\vdash^{f,g}(\Phi,1) \cong 1 \and (f,g)^*1 = 1\\
    C_\vdash^{f,g}(\Phi,P \times Q) \cong C_\vdash^{f,g}(\Phi,P) \times C_\vdash^{f,g}(\Phi, Q)\and (f,g)^*(P \times Q) = (f,g)^*P \times (f,g)^*Q\\
    C_0(C,\smallint R) \cong C_\vdash(\id_C, R)\\
  \end{mathpar}
  \caption{UMPs in an Equipment with Displays}
\end{figure}

Next, each of the connectives of SCT are modeled by different
universal properties that are profunctor isomorphisms involving
principally $C_\vdash$. We define these in Figure\ref{fig:eq-umps}

\begin{definition}
  An \emph{equipment with displays} (ED) is a DCD with all of the
  universal properties in Figure\ref{eq-umps}.
\end{definition}

Finally, to model the logic over SCT provided by the dependently typed
context $\Gamma$, we use a category with families $Ctx$, and interpret
all of the prior constructions in this section to be internal to
presheaves on $Ctx$. This models the syntactic aspect that all double
category structure is parameterized by a context $\Gamma$ and stable
under substitution. Since the category of presheaves is a topos, all
definitions given in set-theoretic language can be interpreted
internally.

\begin{definition}
  A Category with Families consists of
  \begin{enumerate}
  \item A category $\textrm{Ctx}$
  \item with a terminal object $1 : \textrm{Ctx}$
  \item A presheaf $\textrm{Ty} : \widehat {\textrm{Ctx}}$ of types in context.
  \item A presheaf $\textrm{Tm} : \widehat{\int\textrm{Ty}}$ of terms of
    a given type.
  \item With a context extension functor $\textrm{ext} : \int
    \textrm{Ty} \to \textrm{Ctx}$ with universal property:
    \[ \textrm{Ctx}(\Delta,\textrm{ext}(A)) \cong (\gamma : \textrm{Ctx}(\Delta,\textrm{ctx}(A))) \times \textrm{Tm}(A[\gamma])  \]
  \end{enumerate}
\end{definition}

This can be extended in a standard way to model $\Pi,\Sigma, \Id$
types \citet{cwf-stuff}.
%
The final connectives we need are the ``universes'' that internalize
the double category structure as types in the CwF.

\begin{definition}
  Let $(\textrm{Ctx},\textrm{Ty},\textrm{Tm},\textrm{ext})$ be a
  category with families and let $\mathcal V = (C,C_d)$ be a DCD internal to
  $\Set^\textrm{Ctx}$. Then
  \begin{enumerate}
  \item $\mathcal V$ objects are representable as types if there is a
    type given by a section $\textrm{Ob} \in \textrm{Ty}(1)$ with a
    natural isomorphism
    \[ \textrm{Tm}(!_\Gamma^*\textrm{Ob}) \cong C_{0}(\Gamma) \]
  \item $\mathcal V$ vertical arrows are representable as types if
    there is a type
    \[ \textrm{Tm}(Functor)(\Gamma)(a,b) \cong C_0(\Gamma)(a,b)
    \]
    and similarly horizontal displays are representable as types if
    \[ \textrm{Tm}(Prof)(\Gamma)(a,b) \cong \{ R \in C_d(\Gamma) \,|\, s(R) = a \wedge t(R) = b \}
    \]
  \item Closed $\mathcal V$ transformations are representable as types if
    \[ \textrm{Tm}(\textrm{End})(\Gamma)(a,R) \cong C_\vdash^{\id,\id}(r(a),R) \]
  \end{enumerate}
\end{definition}

We then arrive at our final notion of model by collecting all of this
algebraic structure into one definition.
\begin{definition}
  A hyperdoctrine of equipments with displays (HED) is a pair of a
  category with families $Ctx$ modeling $\Sigma,\Pi,\Id$ and a DCD
  internal to $\Set^{Ctx^o}$ with categories, functors, displays and
  unary cells representable as types.
\end{definition}

This notion of HED is straightforwardly, if laboriously, interpretable
as a GAT.

%% \begin{definition}
%%   Given a well-formed signature $\Gamma$ and a virtual equipment
%%   $\mathcal V$, we mutually define the following notions:

%%   \begin{itemize}
%%   \item The set $\sem{\Gamma}_{\mathcal V}$
%%   \item For any $\Gamma \vdash A$ and $\gamma \in \sem{\Gamma}_{\mathcal V}$, a set $\sem{A}_{\mathcal V} \gamma$
%%   \item For any $\Gamma \vdash M : A$ and $\gamma \in \sem{\Gamma}_{\mathcal V}$, an element $\sem{M}_{\mathcal V} \in \sem{A}_{\mathcal V} \gamma$
%%   \item For any $\Gamma \vdash \cat C \isaCat$ and $\gamma \in \sem{\Gamma}_{\mathcal V}$, an object $\sem{\cat C}_{\mathcal V}\gamma$
%%   \item For any $\Gamma\pipe\alpha:\cat C \vdash a :\cat D$ and $\gamma \in \sem{\Gamma}_{\mathcal V}$, a vertical morphism $\sem{\alpha.a}_{\mathcal V}\gamma \in \mathcal V_v(\sem{\cat C}_{\mathcal V}\gamma, \sem{\cat D}_{\mathcal V}\gamma,)$
%%   \item For any $\Gamma\pipe\Xi \vdash R \isaSet$ and $\gamma \in
%%     \sem{\Gamma}_{\mathcal V}$, a horizontal arrow $\sem{R}_{\mathcal
%%       V}\gamma \in \mathcal V_h$ such that $d^\pm\sem{R}_{\mathcal
%%       V}\gamma = \sem{d^\pm\Xi}_{\mathcal V}\gamma$. We also extend
%%     this in the obvious way to transformation contexts
%%     $\sem{\Phi}_{\mathcal V}\gamma$
%%   \item For any $\Gamma\pipe\Phi \vdash t : R$ and $\gamma \in
%%     \sem{\Gamma}_{\mathcal V}$, a 2-cell $\sem{t}_{\mathcal V}\gamma
%%     \in V_h(\sem{\Phi}_{\mathcal V}\gamma;\sem{R}_{\mathcal V}\gamma)$
%%     with $d^\pm\sem{t}_{\mathcal V}\gamma = \id$.
%%   \end{itemize}
  
%%   %% \begin{align*}
%%   %%   \sem{\cdot}_{\mathcal V} &= 1\\
%%   %%   \sem{\Gamma, x:A}_{\mathcal V} &= \sum_{\gamma \in \sem{\Gamma}_{\mathcal V}} \sem{A}_{\mathcal V}\gamma\\
%%   %% \end{align*}
  
%%   %% with an 
%%   %% \begin{align*}
%%   %%   \sem{\Gamma, x:A}_{\mathcal V} &= \sem{\Gamma}_{\mathcal V} \times \sem{A}_{\mathcal V}\\
%%   %%   \sem{\Gamma}_{\mathcal V} &= 1\\\\
%%   %%   \sem{\Sort}_{\mathcal V} &= \mathcal V_0\\
%%   %%   \sem{\varr{\cat C}{\cat D}}_{\mathcal V} &= \mathcal V_v(\sem{\cat C})
%%   %% \end{align*}
%% \end{definition}

\subsection{Initiality}

In this section we give a sketch of an initiality proof of the syntax
of SCT in HEDs. Note that we consider all the following sets up to
$\alpha$-equivalence of names.

\begin{construction}{Completeness}
  SCT presents a HED with
  \begin{enumerate}
  \item Category with Families provided by the contexts,
    substitutions, types and terms.
  \item Objects of $C_0^\Gamma$ provided by the terms $\Gamma \vdash \cat C \isaCat$
  \item Morphisms of $C_0^\Gamma$ provided by terms $\Gamma
    \alpha:\cat C \vdash b \cat D$ with source $\cat C$ and target
    $\cat D$. With identity given by a variable and composition by identity.
  \item Objects of $C_1^\Gamma$ are provided by the profunctor
    contexts $\Gamma \vdash \Phi \isavectx$ with morphisms given by
    transformation substitutions $\Gamma \pipe \Phi \vdash \psi :
    \Psi$.
  \item Horizontal composition of contexts is defined by gluing along
    a variable $\Phi\jnctx \Psi$ and the horizontal identity is given
    by the single category variable $\alpha:\cat C$.
  \item Objects of $C_\vdash^\Gamma$ are provided by the profunctors
    $\Gamma\alpha:\cat C;\beta:\cat D \vdash R$, and a morphism from
    $\alpha:\cat C;\beta:\cat D \vdash R$ to $\alpha':\cat
    C';\beta':\cat D' \vdash R'$ is a triple $(a,t,b)$ of functor
    terms $\alpha:\cat C \vdash a : \cat C'$ and $\beta:\cat D\vdash b
    : \cat D'$ and a term $\alpha:\cat C,x:R,\beta:\cat D \vdash t :
    R'[a/\alpha';b/\beta']$

    Composition $(a,t,b) \circ (a',t',b') = (a[a'],t[t'],b[b'])$ is
    given by component-wise single-place substitution with the triple
    of all variables the identity.
  \item The inclusion functor $i^\Gamma : C_d \to C_1$ is defined on
    types as the singleton context $i(R) = \alpha:\cat
    C,x:R,\beta:\cat D$ and on morphisms as the singleton
    substitution.
  \item The restriction operation $R \circ (a,b)$ is defined as the
    substitution $R[a;b]$.
  \item The remaining universal properties are satisfied using the
    analogous type theoretic construction.
  \end{enumerate}
\end{construction}

\section{Completeness}

%% \begin{figure}
%%   \begin{mathpar}
%%       (\homrallXYtoZ \alpha R P)[\xi] = \homrallXYtoZ \alpha {R[d^+\xi;\alpha/\alpha]} {P[\alpha/\alpha;d^-\xi]}

%%      (\homrlambdaXatYdotZ {x} {\alpha} M)[\phi]
%%       = \homrlambdaXatYdotZ {x} {\alpha} M[\phi,x/x,\gamma/\gamma]

%%      (\homllambdaXatYdotZ {x} {\alpha} M)[\phi]
%%       = \homllambdaXatYdotZ {x} {\alpha} M[\phi,x/x,\gamma/\gamma]


%%   \end{mathpar}
%%   \caption{Substitution}
%% \end{figure
%% }

In this section we establish the most significant portion of the
completeness proof:
\begin{construction}[Double category completeness]
  For any $\Gamma$, define a strict double category as follows
  \begin{enumerate}
  \item Objects are categories $\Gamma \vdash \cat C \isaCat$
  \item Vertical morphisms from $\cat C$ to $\cat D$ are functor/open
    object terms $\Gamma \pipe\alpha:\cat C \vdash B : \cat D$ modulo
    $\alpha$-equivalence.
  \item Horizontal morphisms from $\cat C$ to $\cat D$ are profunctor
    contexts $\Gamma\vdash \Phi \isavectx$ with $d^-\Phi = \cat C$ and
    $d^+\Phi = \cat D$ modulo $\alpha$-equivalence.
  \item Squares from $\Psi$ to $\Phi$ along $A$ and $B$ are
    substitutions $\Gamma \vdash \phi : \Psi \to \Phi$ with $d^-\phi =
    A$ and $d^+\phi = B$ modulo $\alpha$-equivalence.
  \end{enumerate}
\end{construction}
\begin{proof}
  The details are in the linked lemmas. Here we give an overview of
  the relevant structure and properties.
  \begin{enumerate}
  \item Vertical composition is given by substitution of object terms
    and is associative and unital with the variable as the identity
    (Lemma \ref{lem:vertical-cat}).
  \item Horizontal composition is given by the gluing of contexts
    $\Phi\jnctx \Psi$ and is associative and unital with the single
    category variable as the identity (Lemma
    \ref{lem:horizontal-cat}).
  \item Vertical composition of substitutions is given by substitution
    $\phi[\psi]$ and is associative and unital with the identity
    substitution given by a substitution of variables for themselves
    (Lemma \ref{lem:vertical-sq-cat}).
  \item Horizontal composition of substitutions is given by gluing of
    substitutions $\phi \jnctx \psi$ and is associative and unital
    with the identity substitution given by a single functor/open
    object substitution (Lemma \ref{lem:horizontal-sq-cat}).
  \item The process of constructing horizontal identity substitutions
    is functorial in that the horizontal identity of a vertical
    identity arrow is the vertical identity
    (Lemma~\ref{lem:hor-vert-id-id}) and the vertical composition of
    horizontal identities is a horizontal identity
    (Lemma~\ref{lemma:lem-hor-sq-id}).
  \item The process of horizontal composition of substitutions is
    functorial in that the horizontal composition of vertical identity
    squares is the identity (Lemma~\ref{lem:lem-vert-sq-id}) and the
    interchange law holds (Lemma~\ref{lem:interchange}).
  \end{enumerate}
\end{proof}

\begin{definition}
  \label{lem:vertical-sq-cat}
  We define the vertical composition of transformation substitutions
  $\phi[\psi]$ inductively on $\phi$.
  \begin{align*}
    (a/\alpha)[b/\beta] &= a[b/\beta]/\alpha\\
    (\phi_1,t/x,a/\alpha)[\psi_1\jnctx\psi_2] &= \phi_1[\psi_1], t[\psi_2],a[d^+\psi_2]
  \end{align*}
  This covers all cases by \cref{inversion}.

  We define the vertical identity $\id_\Phi$ by induction on $\Phi$
  \begin{align*}
    \id_{\alpha:\cat C} &= \alpha/\alpha\\
    \id_{\Phi,x:R,\alpha:\cat C} &= \id_{\Phi},x/x,\alpha/\alpha
  \end{align*}

  By induction this is seen to be associative:
  \[ \phi[\psi][\sigma] = \phi[\psi[\sigma]] \]
  and unital
  \[ \id_{\Phi}[\phi] = \phi = \phi[\id_{\Psi}] \]
\end{definition}

\begin{lemma}
  \label{lem:sq-vid-hid}
  For any $\cat C$, $\alpha/\alpha : \alpha:\cat C \to \alpha:\cat C$
  is both a horizontal and vertical identity.
\end{lemma}

\begin{lemma}
  \label{lem:sq-vcomp-hid}
  For any $\beta:\cat D \vdash a : \cat C$ and $\alpha:\cat C \vdash a': \cat C'$
  the substitution
  \[ (a'/\alpha')[a/\alpha] : \beta:\cat D \to \alpha':\cat C' \]
  satisfies
  \[ (a'/\alpha')[a/\alpha] = a'[a/\alpha]/\alpha' \]
\end{lemma}

\begin{lemma}
  \label{lem:sq-vid-hcomp}
  For any $\Phi$ and $\Psi$ with $\Phi\jnctx \Psi$ well-defined,
  \[ \id_\Phi \jnctx \id_\Psi = \id_{\Phi\jnctx\Psi} \]
  follows by induction.
\end{lemma}

\begin{lemma}{Interchange}
  \label{lem:sq-vcomp-hcomp}
  We prove the interchange law
  $$(\phi\jnctx\psi)[\phi'\jnctx\psi'] = \phi[\phi'] \jnctx \psi[\psi']$$
  by induction on $\psi$.

  \begin{enumerate}
  \item When $\psi=a/\alpha$
      \begin{align*}
    (\phi\jnctx a/\alpha)[\phi'\jnctx b/\beta]
        &= \phi[\phi']\\
        &= \phi[\phi'] \jnctx (a[b/\beta]/\alpha)\\
        &= \phi[\phi'] \jnctx (a/\alpha)[b/\beta]
  \end{align*}
    \item When $\psi=\psi,t/x,a/\alpha$
      \begin{align*}
        (\phi\jnctx (\psi,t/x,a/\alpha))[\phi' \jnctx (\psi'_1\jnctx\psi'_2)]
        &= ((\phi\jnctx \psi),t/x,a/\alpha)[(\phi' \jnctx \psi'_1)\jnctx\psi'_2]\\
        &= (\phi\jnctx \psi)[\phi' \jnctx \psi'_1],t[\psi'_2]/x,a[d^+\psi'_2]/\alpha\\
        &= (\phi[\psi'] \jnctx \psi[\psi'_1]),t[\psi'_2]/x,a[d^+\psi'_2]/\alpha\\
        &= \phi[\psi'] \jnctx (\psi[\psi'_1],t[\psi'_2]/x,a[d^+\psi'_2]/\alpha)\\
        &= \phi[\psi'] \jnctx (\psi,t/x,a/\alpha)[\psi'_1\jnctx \psi'_2]
      \end{align*}
  \end{enumerate}
  Again, this covers all cases by \cref{inversion}.
\end{lemma}

\begin{figure}
  \begin{mathpar}
    % vertical arrows
    \inferrule*[Right=VComp*]
    {\alpha:\cat C \vdash b : \cat D \and
     \beta:\cat D \vdash c : \cat E}
    {\alpha:\cat C \vdash c[b/\beta] : \cat E}\\

    \beta[b/\beta] = b\and
    c[\beta/\beta] = c\and
    c[b/\beta][a/\alpha] = c[b[a/\alpha]/\beta]\\

    % horizontal arrows
    \inferrule*[Right=HComp*]
    {\Gamma \vdash \Phi \isavectx\\\\
      \Gamma\vdash\Psi\isavectx\\\\
      d^+\Phi = d^-\Psi}
    {\Gamma \vdash \Phi \jnctx \Psi \isavectx}

    d^+(\Phi \jnctx \Psi) = d^+\Psi\and
    d^-(\Phi \jnctx \Psi) = d^-\Phi\\

    \Phi \jnctx (d^+\Phi) = \Phi \and
    (d^-\Phi) \jnctx \Phi = \Phi \and
    (\Phi \jnctx \Psi) \jnctx \Sigma = \Phi \jnctx (\Psi \jnctx \Sigma)\\

    % 2-cells
    %% vertical composition
    \inferrule*[Right=V2Comp*]
    {\Sigma \vdash \psi :: \Psi \and
     \Psi \vdash \phi :: \Phi}
    {\Sigma \vdash \phi[\psi] :: \Phi}

    \inferrule*[Right=V2Id*]
    {}
    {\Phi \vdash \id_\Phi :: \Phi}\\

    \id_\Phi[\phi] = \phi\and
    \phi[\id_\Psi] = \phi\and
    \phi[\psi][\sigma] = \phi[\psi[\sigma]]\\

    %% Horizontal composition
    \inferrule*[Right=H2Comp*]
    {\Phi' \vdash \phi :: \Phi \\\\
     \Psi' \vdash \psi :: \Psi \\\\
     d^+\phi = d^-\psi 
    }
    {\Phi' \jnctx \Psi' \vdash \phi \jnctx \psi :: \Phi \jnctx \Psi}

    d^-(\phi\jnctx\psi) = d^-\phi\and
    d^+(\phi\jnctx\psi) = d^+\phi\and
    
    \phi\jnctx d^+\phi = \phi\and
    d^-\phi \jnctx \phi = \phi\and
    \phi\jnctx(\psi\jnctx\sigma) = (\phi\jnctx\psi)\jnctx\sigma

    %% Interchange
    \inferrule*[Right=Interchange]
    {\Phi'' \vdash \phi' :: \Phi' \and
     \Psi'' \vdash \psi' :: \Psi' \and
     d^+\phi' = d^-\psi'\\\\
     \Phi' \vdash \phi :: \Phi \and
     \Psi' \vdash \psi :: \Psi \and
     d^+\phi = d^-\psi
    }
    {(\phi\jnctx\psi)[\phi'\jnctx\psi'] = \phi[\phi'] \jnctx \psi[\psi']}\\
    
    % Interaction with displays
    \inferrule
    {\Psi \vdash \phi :: \Phi\and
     \Phi \vdash t : R[a/\alpha;b/\beta]}
    {\Psi\vdash t[\phi] : R[a[d^-\phi]/\alpha;b[d^+\phi]/\beta]}

    t[\id_\Phi] = t\and
    t[\phi][\psi] = t[\phi[\psi]]
  \end{mathpar}
  \caption{Syntactic Double Category with Displays Structure}
\end{figure}

\section{Soundness}

We next show how to uniquely interpret the profunctor contexts and
substitutions in an arbitrary HED.

\begin{proof}
  We sketch only the interpretation of profunctor contexts in $C_1$,
  as the rest is a straightforward translation from type theoretic to
  categorical syntax.  We define the translation of a context
  $\sem{\Phi}$ by induction on $\Phi$:

  \begin{align*}
    \sem{\alpha:\cat C} &= \sem{\id^h(\cat C)}\\
    &= \id^h(\sem{\cat C})\\\\
    \sem{\Phi , x:R, \beta:\cat C}\\
    &= \sem{\Phi \circ_h i(R)}\\
    &= \sem{\Phi} \sem{\Phi} \circ_h i(\sem{R})
  \end{align*}
  As these derivations show every step was uniquely determined by the
  homomorphism property. Preservation of identity follows by
  definition. Preservation of composition $\sem{\Phi \jnctx \Psi} =
  \sem{\Phi} \circ_h \sem{\Psi}$ follows by induction on $\Psi$:
  \begin{align*}
    \sem{\Phi \jnctx (\alpha:\cat C)} &= \sem{\Phi} = \sem{\Phi} \circ_h \sem{\id(C)}\\
    \sem{\Phi \jnctx (\Psi,x:R,\alpha:\cat C)}
    &= \sem{(\Phi \jnctx \Psi),x:R,\alpha:\cat C} \\
    &= \sem{(\Phi \jnctx \Psi)} \circ_h i(\sem{R})\\
    &= (\sem{\Phi} \circ_h \sem{\Psi}) \circ_h i(\sem{R})\\
    &= \sem{\Phi} \circ_h (\sem{\Psi} \circ_h i(\sem{R}))\\
    &= \sem{\Phi} \circ_h \sem{\Psi, x:R, \alpha:\cat C}
  \end{align*}
  The interpretation of transformation substitutions is analogous.
\end{proof}

\section{Extended Synthetic Category Theory}

Next, we look at synthetic category theory constructions in SCT.

\subsection{Profunctor Isomorphisms}

We start our study of synthetic category theory constructions with
some isomorphisms that show the interaction between the 5
multiplicative connectives: right/left hom, end, unit and tensor.

First, we fix some terminology
\begin{lemma}
  Let $P, Q : \harr {\cat C} {\cat D}$.
  A homomorphism from $P$ to $Q$ is a term of type
  \[ \homunary {\alpha} {\harrapp P \alpha \beta} {\beta} {\harrapp Q \alpha \beta} \]
  Given homomorphisms $M : P \multimap Q$, $N : Q \multimap R$ we can define their composite as
  \[ (N \circ M) = \lambdaunary {\alpha} {x:\harrapp P \alpha \beta} \beta {\appunary \alpha N \beta {\appunary \alpha M \beta x}} \]
  This notion of composition is associative and unital using the
  $\beta\eta$ equations for the end/right hom connectives, with unit
  $\lambdaunary {\alpha} x \beta x$.

  An isomorphism between $P, Q : \harr {\cat C}{\cat D}$ is then a
  homomorphism $P \multimap Q$ with an inverse $Q \multimap P$.
\end{lemma}

Our first synthetic theorem is that we have that the unit, i.e., the
hom set, is the unit for tensor and hom.
%
The theorem for hom is the synthetic \emph{Yoneda lemma} and the
theorem for tensor is the synthetic \emph{Co-Yoneda lemma}.
\begin{lemma}[{Yoneda and Co-Yoneda}]
  \label{lem:yo-and-co-yo}
  Let $P : \harr {\cat C} {\cat D}$.

  For any $\gamma : \cat E \vdash b : \cat D$, the following are naturally isomorphic to $\harrapp P \alpha b$:
  \begin{enumerate}
  \item $\homrallXYtoZ {\beta} {(\punitinXfromYtoZ {D} {\beta} {b})} {\harrapp P {\alpha} {\beta}}$
  \item $\tensorexistsXwithYandZ {\beta} {\harrapp P \alpha {\beta}} {(\punitinXfromYtoZ {\cat D} {\beta} {b})}$
  \end{enumerate}

  For any $\gamma : \cat E \vdash a : \cat C$, the following are naturally isomorphic to $\harrapp P a \beta$:
  \begin{enumerate}
  \item $\homlallXYtoZ {{\alpha}} {(\punitinXfromYtoZ {C} {\alpha} {a})} {\harrapp P {{\alpha}} {\beta}}$
  \item $\tensorexistsXwithYandZ {\alpha} {(\punitinXfromYtoZ {C} {a} {\alpha})} {\harrapp P {\alpha}{\beta}}$
  \end{enumerate}
\end{lemma}
\begin{proof}
  TODO: what's better, build the substitution in or prove the
  substitution can be built in afterwards? The one building in the
  substitution obscures the connection to the normal tensor/hom/unit
  relationship, but the one with the built in subst is obviously more
  general.
\end{proof}

Next, we have various associativities between the homs, tensor and end
constructions. Semantically, these are related to so-called
\emph{Fubini} theorems about interchange of (co)-ends.
\begin{lemma}[{Fubini}]
  \label{lem:fubini}
  The following isomorphisms hold for any $P : \harr {\cat C}{\cat D},
  P' : \harr {\cat C}{\cat D} Q :\harr {\cat D}{\cat E}, R : \harr
  {\cat E} {\cat F}, S : \harr {\cat C} {\cat E}$. where $\alpha:\cat
  C, \beta:\cat D, \gamma : \cat E, \delta: \cat F$
  \begin{enumerate}
  \item $\tensorexistsXwithYandZ {\beta} {\harrapp P \alpha \beta} {(\tensorexistsXwithYandZ \gamma {\harrapp Q \beta \gamma} {\harrapp R \gamma \delta})} \cong \tensorexistsXwithYandZ {\gamma} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp R \gamma \delta}$
  \item $\homrallXYtoZ {\gamma} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp S \alpha \gamma} \cong \homrallXYtoZ \beta {\harrapp P \alpha \beta} {\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {\harrapp S \alpha \gamma}}$
  \item $\homlallXYtoZ {\alpha} {(\tensorexistsXwithYandZ \beta {\harrapp P \alpha \beta} {\harrapp Q \beta \gamma})} {\harrapp S \alpha \gamma} \cong \homlallXYtoZ \beta {\harrapp Q \beta \gamma} {\homlallXYtoZ \alpha {\harrapp P \alpha \beta} {\harrapp S \alpha \gamma}}$
  \item $\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {(\homlallXYtoZ \alpha {\harrapp P \alpha \beta} {\harrapp S \alpha \gamma})} \cong \homlallXYtoZ \alpha {\harrapp P \alpha \beta} {(\homrallXYtoZ \gamma {\harrapp Q \beta \gamma} {\harrapp S \alpha \gamma})}$
  \item $\pendallXdotY \alpha \homrallXYtoZ \beta P {P'} \cong \pendallXdotY \beta \homlallXYtoZ \alpha P {P'}$
  \end{enumerate}  
\end{lemma}
\begin{proof}
  TODO
\end{proof}
\subsection{Composition, Functoriality, Profunctoriality, Naturality}

Hom sets don't provide primitive syntax for composition of morphisms
in a category. As our first synthetic construction, we can
\emph{define} composition using the elimination form for the unit.
%
\begin{definition}[Composition of Morphisms]
  We define composition of morphisms as the following term of type $\Pi_{\cat C:\Cat}\hombinary {\alpha_1} {\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_2}} {\alpha_2} {\punitinXfromYtoZ {\cat C}{\alpha_2} {\alpha_3}} {\alpha_3} {\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_3}}$:
  \[
  \lambda \cat C. \punitelimtoYwithkontZ {\hlambda {\alpha_1}{\alpha_2} \homrallXYtoZ {\alpha_3} {\punitinXfromYtoZ {\cat C} {\alpha_2} {\alpha_3}} {\punitinXfromYtoZ {\cat C} {\alpha_1} {\alpha_3}}} {\lambdaunary {\alpha} {f : \punitinXfromYtoZ {\cat C}{\alpha} {\alpha_3}} {\alpha_3} f}
  \]
  We call this term $\textrm{comp}$
\end{definition}
This has the same flavor as a directed type theory: to construct the
composite it is sufficient to define the action on the identity
morphism, which is of course the identity for composition.
%
Note that we gave a slight bias to the definition to follow by
induction on the \emph{first} function, whereas we could make the
following alternative definition, naturally of type
$\pendallXdotY {\alpha_2} \homrallXYtoZ {\alpha_3} {\punitinXfromYtoZ {\cat C}{\alpha_2} {\alpha_3}}
{(\homlallXYtoZ {{\alpha_1}} {\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_2}}{\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_3}})}$:
\[
  \punitelimtoYwithkontZ {\hlambda {\alpha_2}{\alpha_3} \homlallXYtoZ {{\alpha_1}} {\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_2}}{\punitinXfromYtoZ {\cat C}{\alpha_1} {\alpha_3}} } {\lambdaunary {\alpha} {g : \punitinXfromYtoZ {\cat C}{\alpha_1}{\alpha}} {\alpha} g}
\]

\begin{lemma}[Equivalence of Composition Definitions]
  TODO
\end{lemma}

It should follow by $\beta\eta$ that this is associative and unital.

Next, let's prove synthetically that every functor $F : \varr{\cat
  C}{\cat D}$ is functorial in this notion of composition.
\begin{definition}
  For any $F : \varr {\cat C} {\cat D}$, we can define a morphism $F_1
  : \homunary {\alpha_1} {\punitinXfromYtoZ {\cat C} {\alpha_1}
    {\alpha_2}} {\alpha_2} {\punitinXfromYtoZ {\cat D} {F \alpha_1}
    {F \alpha_2}}$ as
  \[ F_1 = \punitelimtoYwithkontZ {\hlambda {\alpha_1}{\alpha_2} \punitinXfromYtoZ {\cat D} {F \alpha_1}{F \alpha_2}}
  {\pendlambdaXdotY \alpha \punitrefl {\cat D} {F \alpha}}
  \]
  Note that
  \[ A[\id_\alpha/\alpha] = \id_{A} \]
  \[ A[f;g] = A[f];A[g] \]
\end{definition}
Note the similarity to the proof that all functions are congruences in
MLTT/HoTT.

And similarly, every profunctor $R : \harr {\cat C}{\cat D}$ is
\emph{pro-functorial}.
\begin{definition}
  For any $R : \varr {\cat C} {\cat D}$, we can define left and right
  actions of composition:
  \[ \homunary {\alpha_1} {\tensorexistsXwithYandZ {\alpha_2} {(\punitinXfromYtoZ {\cat C} {\alpha_1}{\alpha_2})} {\tensorexistsXwithYandZ {\alpha_3} {(\harrapp R {\alpha_2} {\alpha_3})}}{(\punitinXfromYtoZ {\cat C} {\alpha_3}{\alpha_4})}} {\alpha_4} {\harrapp R {\alpha_1}{\alpha_4}}
  \]
  Furthermore we can show that they are functorial in that the induced functions
  TODO
  are equal
\end{definition}

Next we can define natural transformations as specific kinds of terms
whose type is $\pendallXdotY {\alpha} \punitinXfromYtoZ {\cat D} {F
  \alpha}{G \alpha}$. In fact we can generalize this to any
endo-profunctor $P$:
\begin{definition}[Natural element]
  A natural element of an endo-profunctor $P : \harr {\cat C}{\cat C}$
  is a term of type $\pendallXdotY {\alpha} \harrapp P \alpha \alpha$.

  A natural transformation is the special case where $P =
  \punitinXfromYtoZ {\cat D} {F \alpha}{G \alpha}$ for functors $F, G
  : \varr {\cat C}{\cat D}$.

  This is natural in the sense that the incuded terms
  \[ \homunary {\alpha_1}{\punitinXfromYtoZ {} {\alpha_1}{\alpha_2}} {\alpha_2} {\harrapp P {\alpha_1}{\alpha_2}}  \]
  and
  \[ \pendallXdotY {\alpha_2} \homlallXYtoZ {\alpha_1} {\punitinXfromYtoZ {} {\alpha_1}{\alpha_2}} {\harrapp P {\alpha_1}{\alpha_2}}\]

  are equal under the associativity equivalence between these two
  types.
\end{definition}

\subsection{Yoneda Lemma and Representable Presheaves}

Given any category $\cat C$, we can define the positive and negative
Yoneda embeddings $Y^\pm : \cat C \to \pmPresheaf {\cat C}$ using the
hom profunctor. Note that both of these functors are covariant in
$\cat C$, so semantically, $\posPresheaf {\cat C}$ should be
interpreted as $(\Set^{\cat C})^o$.

\begin{definition}
  Define the negative Yoneda embedding $Y^-[\alpha]$
  \[ \alpha:\cat C \vdash Y^-[\alpha] = \lambda \alpha':\cat C. \punitinXfromYtoZ {\cat C}{\alpha'}{\alpha} : \negPresheaf {\cat C} \]

  The positive Yoneda embedding is defined similarly $Y^+[\alpha]$.
\end{definition}

The Yoneda lemma says that the set of natural transformations from
$Y^-[\alpha]$ to a presheaf $p$ is naturally isomorphic to the
elements of the presheaf itself: $\negPresheafApp \alpha p$. In
encoding this statement in our type theory, we find that we can use
two different interpretations of ``natural transformations''.

On the one hand, a natural transformation should be a morphism in the
presheaf category. This interpretation of the Yoneda lemma would mean
that we have a natural isomorphism of profunctors:
\[ \alpha:\cat C; \pi:\negPresheaf {\cat C} \vdash \punitinXfromYtoZ{\negPresheaf {\cat C}} {Y^-[\alpha]} {\pi} \cong \negPresheafApp \alpha \pi \]
Attempting to prove this we become stuck very quickly because we know
nothing about the structure of morphisms in the presheaf category.

On the other hand, a natural transformation of presheaves $\pi$ and
$\rho$ can be defined as a family of functions from $\negPresheafApp
\alpha \pi$ to $\negPresheafApp \alpha \rho$, or in other words as an
\emph{end}. Specializing to the Yoneda lemma, we interpret ``a natural
transformation from $Y^-[\alpha]$ to $\pi$'' as the following, which simplifies using $\beta$ reduction:
\[ \alpha:\cat C; \pi:\negPresheaf {\cat C} \vdash \homrallXYtoZ {\alpha':\cat C} {\negPresheafApp {\alpha'} {Y^-[\alpha]}}{\negPresheafApp {\alpha'} \pi} = \homrallXYtoZ {\alpha':\cat C} {(\punitinXfromYtoZ {\cat C}{\alpha'}{\alpha})}{(\negPresheafApp {\alpha'} \pi)} \]
And then the Yoneda lemma becomes:
\[ \alpha:\cat C; \pi:\negPresheaf {\cat C} \vdash \homrallXYtoZ {\alpha':\cat C} {(\punitinXfromYtoZ {\cat C}{\alpha'}{\alpha})}{(\negPresheafApp {\alpha'} \pi)} \cong \negPresheafApp \alpha \pi\]
Which is an instance of our earlier Lemma\,\ref{lem:yo-and-co-yo}
which follows quite easily.

Then we are left with the question of whether these two forms of the
Yoneda lemma are equivalent, or slightly more generally are these two definitions of natural transformation of presheaves equivalent:
\[ \rho:\negPresheaf{\cat C}; \pi:\negPresheaf {\cat C} \vdash \punitinXfromYtoZ{\negPresheaf {\cat C}} {\rho} {\pi} \]
and
\[ \rho:\negPresheaf{\cat C}; \pi:\negPresheaf {\cat C} \vdash \homrallXYtoZ {\alpha:\cat C} {\negPresheafApp \alpha \rho}{\negPresheafApp \alpha \pi} \]
While we can show that there is a morphism from the hom set to the
end, the inverse does not seem provable, and seems analogous to the
\emph{univalence} axiom in homotopy type theory, as it tells us that
the morphisms of the universe are given by a particular kind of
function in our logic.

\subsection{Adjoint Functors and Representable Profunctors}

Next, we demonstrate that the two common definitions of adjoint
functors are equivalent: isomorphism of hom-sets and units and
co-units.
%
The proof goes through most easily, and utilizes duality most
effectively, if we factorize the construction through an intermediate
notion of when a functor \emph{represents} a profunctor.

\begin{definition}[Functor Represents a Profunctor]
  A functor $G : \varr{\cat D}{\cat C}$ right-represents a profunctor $R :
  \harr {\cat C}{\cat D}$ when there is an isomorphism of profunctors:
  \[ \punitinXfromYtoZ {\cat C} {\alpha} {G \beta} \cong \harrapp R {\alpha}{\beta}\]

  We say a functor $F : \varr{\cat C}{\cat D}$ \emph{left-represents} a profunctor $R : \harr {\cat C}{\cat D}$ when there is an isomorphism of profunctors
  \[ \punitinXfromYtoZ {\cat D} {F \alpha} {\beta} \cong \harrapp R {\alpha}{\beta}\]
\end{definition}

This is a parameterized generalization of the notion of an object
representing a functor $R : C^{op} \to Set$.
These notions are precisely dual. $F$ left-represents a profunctor $R$
precisely if it right-represents it in the opposite SCT.

Note that trivially any functor $G$ right-represents
$\hlambda\alpha\beta \punitinXfromYtoZ {\cat D}{\alpha} {G \beta}$ and
dually, any functor $F$ left-represents
$\hlambda\alpha\beta\punitinXfromYtoZ {\cat C}{F\alpha}{\beta}$.

Then we can show that any right-representation isomorphism is
determined by a co-unit:
\begin{lemma}[(Co)-unit of a Representation]
  If $G: \varr {\cat D}{\cat C}$ right-represents $R : \harr {\cat
    C}{\cat D}$, then there is a natural element, the co-unit:
  \[ \pendallXdotY \beta \harrapp R {G\beta} \beta \]
  Such that the half of the isomorphism 
  \[ \punitinXfromYtoZ {\cat C} {\alpha} {G \beta} \multimap \harrapp R {\alpha}{\beta} \]
  is defined by composition with the natural element.

  Dually, any $F$ left-representing isomorphism with $R$ is determined
  by a ``unit'' of type $\pendallXdotY \alpha \harrapp R {\alpha}
  {F\alpha}$.
\end{lemma}
\begin{proof}
  A homomorphism $\punitinXfromYtoZ {\cat C} {\alpha} {G \beta} \multimap \harrapp R {\alpha}{\beta}$ is by definition a term of type
  \[ \pendallXdotY \alpha \homrallXYtoZ {\beta} {(\punitinXfromYtoZ {\cat C} \alpha {G \beta})} {\harrapp R \alpha \beta} \]
  By \cref{lem:fubini}, this type is isomorphic to 
  \[ \pendallXdotY \beta \homlallXYtoZ {\alpha} {(\punitinXfromYtoZ {\cat C} \alpha {G \beta})} {\harrapp R \alpha \beta} \]
  By \cref{lem:yo-and-co-yo}, this type is isomorphic to
  \[ \pendallXdotY \beta {{\harrapp R {(G \beta)} \beta}} \]

  Therefore this half of the isomorphism is determined by a natural
  element. The construction in the proof of \cref{lem:yo-and-co-yo} is
  indeed by composition (i.e., unit elimination).

  The $F$ case is precisely dual.
\end{proof}

Combining these two, we get the unit-counit definition for adjoint
functors

\begin{definition}[Adjunction by unit/co-unit]
  We say $G : \varr {\cat D}{\cat C}$ is right adjoint to $F : \varr
  {\cat C}{\cat D}$ if there is a unit
  \[ \eta : \pendallXdotY \alpha \punitinXfromYtoZ \alpha {G(F(\alpha))}\]
  and a co-unit
  \[ \epsilon : \pendallXdotY \beta \punitinXfromYtoZ {F(G(\beta))} \beta \]

  satisfying the triangle identities...
  \[ \id_{R[\beta]} = R[\epsilon_{\beta}] \circ \eta_{R[\beta]} \]
  \[ \id_{L[\alpha]} = \epsilon_{L[\alpha]} \circ L[\eta_{\alpha}] \]
\end{definition}

\begin{theorem}[Adjunctions]
  $G$ is right adjoint to $F$ if and only if there is a natural isomorphism
  $\punitinXfromYtoZ {\cat D} {(F \alpha)} \beta \cong \punitinXfromYtoZ {\cat D} \alpha {G \beta}$
\end{theorem}
\begin{proof}
  First, by \cref{lem:co-unit}, the forward direction of the
  isomorphism is equivalent to providing a term
  \[ \eta : \pendallXdotY \alpha \punitinXfromYtoZ \alpha {G(F(\alpha)) } \]

  Second, the backward direction of the isomorphism is equivalent to
  providing a term
  \[ \epsilon : \pendallXdotY \beta \punitinXfromYtoZ {F(G(\beta))} \beta \]

  And the triangle laws state exactly that the induced functions are
  isomorphisms.
\end{proof}

\subsection{Kan Extensions/Lifts}

As a further example of the synthetic approach to universal
properties, we consider right and left \emph{Kan extensions}, which
are generalizations of limits and colimits, respectively.

The right Kan extension of $F$ along $J$ is the ``best'' (maximal) way to
fill in the following square:
\[% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAGEQBfU9TXfIRQBGclVqMWbACLdeIDNjwEiZYePrNWiDgHJu4mFADm8IqABmAJwgBbJGRA4ISAEzVNUnQCk5lm-aIjs5IohJabABiBlxAA
\begin{tikzcd}
\cat C \arrow[d, "J"] \arrow[r, "F"] & \cat D \\
\cat C'                              &  
\end{tikzcd}\]
I.e. a functor $\textrm{Ran}_J F : \cat C' \to \cat D$ with a
universal natural transformation $\textrm{Ran}_J F \circ J \Rightarrow
F$. A left kan extension $\textrm{Lan}_J F$ is the same but with a
natural transformation $F \Rightarrow \textrm{Lan}_J F \circ J $.

We can express the concept in SCT as representing a certain profunctor
constructed using the profunctor hom:
\begin{definition}[Kan Extensions]
  Given functors $F : \varr {\cat C}{\cat D}$ and $J : \varr {\cat
    C}{\cat C'}$, a right Kan extension is a functor $\textrm{Ran}_J F
  : \varr {\cat C'}{\cat D} $that right-represents the profunctor
  \[ \hlambda {\beta:\cat D}{\alpha': \cat C} \homrallXYtoZ {\alpha}{(\punitinXfromYtoZ {\cat C'}{\alpha'}{J\alpha})} {\punitinXfromYtoZ {\cat D}{\beta}{F \alpha}} \]

  A left Kan extensions is a functor $\textrm{Lan}_J F : \varr {\cat
    C'}{\cat D}$ is a functor satisfying the dual property: it
  \emph{left}-represents the profunctor
  \[\hlambda {\alpha':\cat C}{\beta:\cat D} \homlallXYtoZ {\alpha}{(\punitinXfromYtoZ {\cat C'}{J\alpha}{\alpha'})} {\punitinXfromYtoZ {\cat D}{F \alpha}{\beta}}
  \]
\end{definition}

The limit of a functor $F : \varr{\cat C}{\cat D}$ is a special case
of a Kan extension where $J : \varr{\cat C}{1}$ is the unique functor
to the terminal category. Similarly, the colimit of $F$ is the left
Kan extension with respect to the same $J$.
%
Specializing to this case, the representability for limits means:
\[ \punitinXfromYtoZ {\cat D}{\beta}{\textrm{lim} F} \cong \homrallXYtoZ {\alpha}{(\punitinXfromYtoZ {\cat 1}{\alpha'}{()})}{\punitinXfromYtoZ {\cat D}{\beta}{F \alpha}} \]
And if we view a morphism in $\cat 1$ as being trivial, then this
essentially states that mapping $\beta$ to $\textrm{lim} F$ is the
same thing as constructing a cone: for all $\alpha :\cat C$, a
morphism from $\beta$ to $F \alpha$, naturally in $\alpha$.

The usual formulation of Kan extensions is in terms of a universal
morphism.
%
We can reproduce this formulation using our established theory of
equivalences for homs of profunctors.
\begin{lemma}
  One half of the representability isomorphism for a right Kan
  extension $\textrm{Ran}_J F$ is determined by a natural
  transformation
  \[ \pendallXdotY \alpha \punitinXfromYtoZ {\cat D}{(\textrm{Ran}_JF)(J\alpha)}{F\alpha} \]

  Dually, one half of the representability isomorphism for a left Kan
  extension $\textrm{Lan}_J F$ is determined by a natural
  transformation
  \[ \pendallXdotY \alpha \punitinXfromYtoZ {\cat D}{F\alpha}{(\textrm{Lan}_JF)(J\alpha)} \]
\end{lemma}
\begin{proof}
  By \cref{lem:unit-repr}, one half of representability is determined by a natural element
  \[ \pendallXdotY {\alpha'} \homrallXYtoZ {\alpha}{(\punitinXfromYtoZ {\cat C'}{\alpha'}{J\alpha})} {\punitinXfromYtoZ {\cat D}{(\textrm{Ran}_J F)\alpha'}{F \alpha}} \]
  which, by \cref{lem:fubini} is isomorphic to
  \[
  \pendallXdotY {\alpha} \homlallXYtoZ {\alpha'}{(\punitinXfromYtoZ {\cat C'}{\alpha'}{J\alpha})}{\punitinXfromYtoZ {\cat D}{(\textrm{Ran}_J F)\alpha'}{F \alpha}}
  \]
  which, by \cref{lem:yo-and-co-yo}, is isomorphic to 
  \[ \pendallXdotY \alpha \punitinXfromYtoZ {\cat D}{(\textrm{Ran}_JF)(J\alpha)}{F\alpha} \]
  by taking $P = \hlambda {\alpha'}{\alpha} {\punitinXfromYtoZ {\cat D}{(\textrm{Ran}_J F)\alpha'}{F \alpha}}$.

  The proof for left Kan extensions follows by \cref{lem:duality}.
\end{proof}

\end{document}
